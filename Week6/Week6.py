# CS50's Introduction to Programming with Python (CS50P) 2022 
# https://cs50.harvard.edu/python/2022/weeks/6/
# https://www.youtube.com/playlist?list=PLhQjrBD2T3817j24-GogXmWqO5Q5vYy0V
# https://youtu.be/KD-Yoel6EVQ

# https://cs50.harvard.edu/python/2022/notes/6/

"""
Lecture 6

    File I/O
    open
    with
    CSV
    Binary Files and PIL
    Summing Up
"""

# File I/O

# Up until now, everything we’ve programmed has stored information in memory. That is, once the program is ended, all information gathered from the user or generated by the program is lost.
# File I/O is the ability of a program to take a file as input or create a file as output.
# To begin, in the terminal window type code names.py and code as follows:

name = input("What's your name?" )
print(f"hello, {name}")
# Notice that running this code has the desired output. The user can input a name. The output is as expected.

# However, what if we wanted to allow multiple names to be inputted? How might we achieve this? Recall that a list is a data structure that allows us to store multiple values into a single variable. Code as follows:

names = []

for _ in range(3):
    name = input("What's your name?" )
    names.append(name)
# Notice that the user will be prompted three times for input. The append method is used to add the name to our names list.

# This code could be simplified to the following:

names = []

for _ in range(3):
    names.append(input("What's your name?" ))
# Notice that this has the same result as the prior block of code.

# Now, let’s enable the ability to print the list of names as a sorted list. Code as follows:
names = []

for _ in range(3):
    names.append(input("What's your name?" ))

for name in sorted(names):
    print(f"hello, {name}")
# Notice that once this program is executed, all information is lost. File I/O allows your program to store this information such that it can be used later.

# You can learn more in Python’s documentation of sorted.
# https://docs.python.org/3/library/functions.html#sorted





# OPEN

# open is a functionality built into Python that allows you to open a file and utilize it in your program. The open function allows you to open a file such that you can read from it or write to it.
# To show you how to enable file I/O in your program, let’s rewind a bit and code as follows:

name = input("What's your name? ")

file = open("names.txt", "w")
file.write(name)
file.close()
# Notice that the open function opens a file called names.txt with writing enabled, as signified by the w. The code above assigns that opened file to a variable called file. The line file.write(name) writes the name to the text file. The line after that closes the file.

# Testing out your code by typing python names.py, you can input a name and it saves to the text file. However, if you run your program multiple times using different names, you will notice that this program will entirely rewrite the names.txt file each time.
# Ideally, we want to be able to append each of our names to the file. Remove the existing text file by typing rm names.txt in the terminal window. Then, modify your code as follows:

name = input("What's your name? ")

file = open("names.txt", "a")
file.write(name)
file.close()
# Notice that the only change to our code is that the w has been changed to a for “append”. Rerunning this program multiple times, you will notice that names will be added to the file. However, you will notice a new problem!

# Examining your text file after running your program multiple times, you’ll notice that the names are running together. The names are being appended without any gaps between each of the names. You can fix this issue. Again, remove the existing text file by typing rm names.txt in the terminal window. Then, modify your code as follows:

name = input("What's your name? ")

file = open("names.txt", "a")
file.write(f"{name}\n")
file.close()
# Notice that the line with file.write has been modified to add a line break at the end of each name.

# This code is working quite well. However, there are ways to improve this program. It so happens that it’s quite easy to forget to close the file.

# You can learn more in Python’s documentation of open.
# https://docs.python.org/3/library/functions.html#open





# WITH

# The keyword with allows you to automate the closing of a file.
# Modify your code as follows:

name = input("What's your name? ")

with open("names.txt", "a") as file:
    file.write(f"{name}\n")
# Notice that the line below with is indented.

# Up until this point, we have been exclusively writing to a file. What if we want to read from a file. To enable this functionality, modify your code as follows:

with open("names.txt", "r") as file:
    lines = file.readlines()

for line in lines:
    print("hello,", line)
# Notice that readlines has a special ability to read all the lines of a file and store them in a file called lines. Running your program, you will notice that the output is quite ugly. There seem to be multiple line breaks where there should be only one.

# There are many approaches to fix this issue. However, here is a simple way to fix this error in our code:

with open("names.txt", "r") as file:
    lines = file.readlines()

for line in lines:
    print("hello,", line.rstrip())
# Notice that rstrip has the effect of removing the extraneous line break at the end of each line.

# Still, this code could be simplified even further:

with open("names.txt", "r") as file:
    for line in file:
        print("hello,", line.rstrip())
# Notice that running this code, it is correct. However, notice that we are not sorting the names.

# This code could be further improved to allow for the sorting of the names:

names = []

with open("names.txt") as file:
    for line in file:
        names.append(line.rstrip())

for name in sorted(names):
    print(f"hello, {name}")
# Notice that names is a blank list where we can collect the names. Each name is appended to the names list in memory. Then, each name in the sorted list in memory is printed. Running your code, you will see that the names are now properly sorted.

# What if we wanted the ability to store more than just the names of students? What if we wanted to store both the student’s name and their house as well?





# CSV

# CSV stands for “comma separated values”.
# In your terminal window, type code students.csv. Ensure your new CSV file looks like the following:

Hermoine,Gryffindor
Harry,Gryffindor
Ron,Gryffindor
Draco,Slytherin

# Let’s create a new program by typing code students.py and code as follows:

with open("students.csv") as file:
    for line in file:
        row = line.rstrip().split(",")
        print(f"{row[0]} is in {row[1]}")
# Notice that rstrip removes the end of each line in our CSV file. split tells the compiler where to find the end of each of our values in our CSV file. row[0] is the first element in each line of our CSV file. row[1] is the second element in each line in our CSV file.

# The above code is effective at dividing each line or “record” of our CSV file. However, it’s a bit cryptic to look at if you are unfamiliar with this type of syntax. Python has built-in ability that could further simplify this code. Modify your code as follows:

with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        print(f"{name} is in {house}")

# Notice that the split function actually returns two values: The one before the comma and the one after the comma. Accordingly, we can rely upon that functionality to assign two variables at once instead of one!

# Imagine that we would again like to provide this list as sorted output? You can modify your code as follows:

students = []

with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        students.append(f"{name} is in {house}")

for student in sorted(students):
    print(student)
# Notice that we create a list called students. We append each string to this list. Then, we output a sorted version of our list.

# Recall that Python allows for dictionaries where a key can be associated with a value. This code could be further improved

students = []

with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        student = {}
        student["name"] = name
        student["house"] = house
        students.append(student)

for student in students:
    print(f"{student['name']} is in {student['house']}")
# Notice that we create an empty dictionary called student. We add the values for each student, including their name and house into the student dictionary. Then, we append that student to the list called students.

# We can improve our code to illustrate this as follows:

students = []

with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        student = {"name": name, "house": house}
        students.append(student)

for student in students:
    print(f"{student['name']} is in {student['house']}")
# Notice that this produces the desired outcome, minus the sorting of students.

# Unfortunately, we cannot sort the students as we had prior because each student is now a dictionary inside of a list. It would be helpful if Python could sort the students list of student dictionaries that sorts this list of dictionaries by the student’s name.
# To implement this in our code, make the following changes:

students = []

with open("students.csv") as file:
    for line in file:
        name, house = line.rstrip().split(",")
        students.append({"name": name, "house": house})


def get_name(student):
    return student["name"]


for student in sorted(students, key=get_name):
    print(f"{student['name']} is in {student['house']}")
