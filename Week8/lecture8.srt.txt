1
00:00:00,000 --> 00:00:03,479
[CLASSICAL MUSIC]

2
00:00:03,479 --> 00:00:23,880


3
00:00:23,880 --> 00:00:26,580
DAVID J. MALAN: All right,
this is CS50's Introduction

4
00:00:26,580 --> 00:00:27,900
to Programming with Python.

5
00:00:27,900 --> 00:00:31,530
My name is David Malan, and this is our
week on object-oriented programming,

6
00:00:31,530 --> 00:00:32,790
or OOP.

7
00:00:32,790 --> 00:00:34,770
It turns out that, in
the world of programming,

8
00:00:34,770 --> 00:00:37,570
there's different paradigms
of programming languages.

9
00:00:37,570 --> 00:00:40,208
There's different ways of
solving problems with code,

10
00:00:40,208 --> 00:00:42,000
and it's a little hard
to see this at first

11
00:00:42,000 --> 00:00:43,920
if you've only learned one language.

12
00:00:43,920 --> 00:00:47,403
But over time, if and when you learn
other languages besides Python,

13
00:00:47,403 --> 00:00:50,070
you'll start to notice certain
patterns and certain capabilities

14
00:00:50,070 --> 00:00:52,020
of some languages but not another.

15
00:00:52,020 --> 00:00:54,780
Thus far, within the
world of Python, you and I

16
00:00:54,780 --> 00:00:58,560
have largely been writing code that's
procedural in nature, whereby we're

17
00:00:58,560 --> 00:01:00,720
writing procedures;
we're writing functions;

18
00:01:00,720 --> 00:01:03,150
and we're doing things top to bottom.

19
00:01:03,150 --> 00:01:05,459
Everything is step by
step by step, as you would

20
00:01:05,459 --> 00:01:07,200
expect in general from an algorithm.

21
00:01:07,200 --> 00:01:09,270
But along the way,
we've actually dabbled

22
00:01:09,270 --> 00:01:14,070
in another paradigm known as functional
programming with Python whereby we've

23
00:01:14,070 --> 00:01:15,870
been able to pass functions around.

24
00:01:15,870 --> 00:01:18,670
We even had an anonymous
function some weeks ago.

25
00:01:18,670 --> 00:01:22,482
And that's evidence of features of
a functional programming language,

26
00:01:22,482 --> 00:01:24,690
even though we've just
scratched the surface thereof.

27
00:01:24,690 --> 00:01:28,080
Today we focus on another paradigm,
and this one in more detail--

28
00:01:28,080 --> 00:01:30,150
namely object-oriented programming.

29
00:01:30,150 --> 00:01:32,970
And now, while some of you might
have prior programming experience

30
00:01:32,970 --> 00:01:36,510
and have learned languages like Java,
which are, by design, fundamentally

31
00:01:36,510 --> 00:01:40,290
object-oriented, Python indeed
allows you a bit of flexibility

32
00:01:40,290 --> 00:01:43,230
when it comes to how you
solve problems with code.

33
00:01:43,230 --> 00:01:46,470
But it turns out
object-oriented programming

34
00:01:46,470 --> 00:01:49,020
is a pretty compelling
solution to problems

35
00:01:49,020 --> 00:01:52,650
that you invariably encounter as
your programs get longer, larger,

36
00:01:52,650 --> 00:01:54,370
and more complicated.

37
00:01:54,370 --> 00:01:56,340
So indeed, OOP, for
our purposes, is going

38
00:01:56,340 --> 00:02:00,810
to be a solution to a problem that
builds on so many of the lessons past.

39
00:02:00,810 --> 00:02:02,470
So let's go ahead and do this.

40
00:02:02,470 --> 00:02:05,850
Let's start by writing a
program very procedurally

41
00:02:05,850 --> 00:02:07,620
by opening up VS Code here.

42
00:02:07,620 --> 00:02:10,889
I'm going to go ahead and create
a program called student.py.

43
00:02:10,889 --> 00:02:14,100
And in this program, I want to
do something relatively simple

44
00:02:14,100 --> 00:02:18,360
initially, as we might have done
some weeks ago now, where I just

45
00:02:18,360 --> 00:02:22,170
ask a user for their name and, maybe
in the context of the Harry Potter

46
00:02:22,170 --> 00:02:26,310
universe, their house, and just
print out where that student is from.

47
00:02:26,310 --> 00:02:30,150
And let's gradually enhance this program
by adding more and more features to it

48
00:02:30,150 --> 00:02:33,870
and see if we don't stumble upon
problems that, up until now,

49
00:02:33,870 --> 00:02:36,960
we might not have had very elegant,
well-designed solutions to.

50
00:02:36,960 --> 00:02:40,230
But if we introduce, explicitly,
object-oriented programming

51
00:02:40,230 --> 00:02:43,230
as a programming technique, I
bet we can clean up our code

52
00:02:43,230 --> 00:02:47,220
and set the stage for writing even more
sophisticated programs, longer programs

53
00:02:47,220 --> 00:02:48,100
down the line.

54
00:02:48,100 --> 00:02:51,780
So in student.py, let me go
ahead and do a name variable,

55
00:02:51,780 --> 00:02:54,270
setting it equal to the
return value of input,

56
00:02:54,270 --> 00:02:57,060
and just prompt the user
for their name like this.

57
00:02:57,060 --> 00:02:59,790
And then let me go ahead and do
the same for a house variable

58
00:02:59,790 --> 00:03:03,060
and prompt the user for their
house, using input like this.

59
00:03:03,060 --> 00:03:05,220
And let's do something super simple now.

60
00:03:05,220 --> 00:03:07,860
Let's just go ahead and
print out an f string

61
00:03:07,860 --> 00:03:11,310
that says something
like name from house,

62
00:03:11,310 --> 00:03:13,950
just so that I can confirm that
the contents of these variables

63
00:03:13,950 --> 00:03:14,987
are indeed as I expect.

64
00:03:14,987 --> 00:03:17,070
I'm not going to do any
error checking or trimming

65
00:03:17,070 --> 00:03:18,320
or anything like that for now.

66
00:03:18,320 --> 00:03:21,420
I'm really just going to spit back
out whatever the user just typed in.

67
00:03:21,420 --> 00:03:24,390
All right, let me go ahead
and run Python of student.py.

68
00:03:24,390 --> 00:03:29,100
Let's use our go-to, like Harry, as
in Harry Potter, from Gryffindor.

69
00:03:29,100 --> 00:03:32,970
And when I hit Enter, now let's see
if I see that Harry from Gryffindor

70
00:03:32,970 --> 00:03:34,050
is indeed the case.

71
00:03:34,050 --> 00:03:37,380
All right, so I think we have a working
program at this point, but let's

72
00:03:37,380 --> 00:03:40,560
now introduce some of those lessons
learned way back from week zero

73
00:03:40,560 --> 00:03:42,570
where we started writing
our own functions,

74
00:03:42,570 --> 00:03:46,260
not necessarily because it solves
the problem more correctly--

75
00:03:46,260 --> 00:03:47,910
I daresay this is correct as is.

76
00:03:47,910 --> 00:03:52,050
But it begins to give us building
blocks that we can extend so

77
00:03:52,050 --> 00:03:54,130
as to solve more complicated programs.

78
00:03:54,130 --> 00:03:58,360
So let me go back up to student.py,
and let's go ahead now and do this.

79
00:03:58,360 --> 00:04:01,890
Let's put the entire logic I just
wrote inside of our typical method

80
00:04:01,890 --> 00:04:05,460
called main, and let me indent those
three lines so that at least they're

81
00:04:05,460 --> 00:04:07,350
now combined into one main method.

82
00:04:07,350 --> 00:04:12,225
But instead of using input
on line 2 an input on line 3,

83
00:04:12,225 --> 00:04:14,100
don't we go ahead and
assume, for the moment,

84
00:04:14,100 --> 00:04:16,992
that we've got some function
called get_name in the world,

85
00:04:16,992 --> 00:04:19,950
and let's go ahead and assume we've
got another function like get_house

86
00:04:19,950 --> 00:04:21,720
in the world that don't take parameters.

87
00:04:21,720 --> 00:04:24,180
But their purpose in
life is, by their name,

88
00:04:24,180 --> 00:04:28,450
going to be to get the user's name and
to get their users house, respectively.

89
00:04:28,450 --> 00:04:32,070
And then I'm going to print out
the exact same f string as before.

90
00:04:32,070 --> 00:04:34,320
I, of course, need to
implement these functions now.

91
00:04:34,320 --> 00:04:38,310
So let me go lower in my file and
define a function called get_name.

92
00:04:38,310 --> 00:04:41,370
Nothing in these parentheses because
it's not going to take a parameter.

93
00:04:41,370 --> 00:04:44,078
And I'm going to go ahead and do
something like name equals input

94
00:04:44,078 --> 00:04:48,750
("Name"), just like before, and then
I'm going to go ahead and return name.

95
00:04:48,750 --> 00:04:52,020
So it's a super simple function,
but it's an abstraction.

96
00:04:52,020 --> 00:04:55,452
I now have a function called
get_name whose implementation details

97
00:04:55,452 --> 00:04:56,910
I don't have to care about anymore.

98
00:04:56,910 --> 00:04:58,470
I just know that the function exists.

99
00:04:58,470 --> 00:05:00,270
And I can tighten this up, in fact, .

100
00:05:00,270 --> 00:05:02,880
Don't really need a
name variable on line 8

101
00:05:02,880 --> 00:05:05,880
if I'm immediately going to return
that same name variable on line 9.

102
00:05:05,880 --> 00:05:07,822
So let me just tighten
this up a little bit

103
00:05:07,822 --> 00:05:09,780
even though it doesn't
change the functionality

104
00:05:09,780 --> 00:05:15,730
and just immediately return the return
value of the inputs function call here.

105
00:05:15,730 --> 00:05:18,900
Let's do something very
similar now for get_house,

106
00:05:18,900 --> 00:05:20,730
which will similarly take no arguments.

107
00:05:20,730 --> 00:05:22,650
I'm going to go ahead
and return the return

108
00:05:22,650 --> 00:05:25,530
value of input, this time
prompting the user for their house.

109
00:05:25,530 --> 00:05:27,270
And I need one final detail.

110
00:05:27,270 --> 00:05:32,220
At the very bottom, let's continue our
habit of doing if the name of this file

111
00:05:32,220 --> 00:05:35,730
equals, equals, quote, unquote,
main, then let's go ahead

112
00:05:35,730 --> 00:05:38,860
and actually call main and
recall that we have that in place

113
00:05:38,860 --> 00:05:42,460
so that, if this eventually becomes
part of a module, a library of sorts,

114
00:05:42,460 --> 00:05:44,790
I don't accidentally call main blindly.

115
00:05:44,790 --> 00:05:50,250
I only do it if I mean to run main
from the command line on this file.

116
00:05:50,250 --> 00:05:53,460
All right, so if I didn't make
any mistakes here, let me go ahead

117
00:05:53,460 --> 00:05:57,420
and, in my terminal window, again,
run Python of student.py, Enter.

118
00:05:57,420 --> 00:05:59,250
Let's type in Harry, Enter.

119
00:05:59,250 --> 00:06:01,560
Let's type in Gryffindor, Enter.

120
00:06:01,560 --> 00:06:02,880
And we're set.

121
00:06:02,880 --> 00:06:05,580
Harry from Gryffindor
seems to still be working.

122
00:06:05,580 --> 00:06:09,420
So we haven't really solved
the problem any more correctly,

123
00:06:09,420 --> 00:06:11,882
but I've laid the
foundation to maybe now do

124
00:06:11,882 --> 00:06:13,590
some more interesting
things because I've

125
00:06:13,590 --> 00:06:16,890
had these building blocks in place.

126
00:06:16,890 --> 00:06:21,090
But let me propose that we could be
doing this a little bit differently.

127
00:06:21,090 --> 00:06:22,990
get_name, get_house is fine.

128
00:06:22,990 --> 00:06:26,430
But at the end of the day, I'm really
trying to get a student from the user.

129
00:06:26,430 --> 00:06:30,070
I want their name and their
house, not just one or the other.

130
00:06:30,070 --> 00:06:32,820
So maybe it would be
a little cleaner still

131
00:06:32,820 --> 00:06:36,090
to define a function
called get_student and let

132
00:06:36,090 --> 00:06:38,310
get_student do all of this work for us.

133
00:06:38,310 --> 00:06:42,990
Now, theoretically, get_student could
call get_name and could call get_house.

134
00:06:42,990 --> 00:06:44,760
But because these
functions are so short,

135
00:06:44,760 --> 00:06:48,870
I think I'm OK with just defining
one function, called get_student,

136
00:06:48,870 --> 00:06:50,670
that similarly won't take any arguments.

137
00:06:50,670 --> 00:06:52,240
But it's going to do two things.

138
00:06:52,240 --> 00:06:55,880
It's going to get the students name,
by prompting them with input as before.

139
00:06:55,880 --> 00:06:57,630
And it's going to get
the student's house,

140
00:06:57,630 --> 00:07:01,110
by also prompting them as before.

141
00:07:01,110 --> 00:07:02,430
Now, hmm.

142
00:07:02,430 --> 00:07:04,830
I want to return the
student, but I think

143
00:07:04,830 --> 00:07:06,870
I might have painted
myself into a corner

144
00:07:06,870 --> 00:07:10,110
here because I now have two
variables-- name and house.

145
00:07:10,110 --> 00:07:13,260
And yet, up until now, we've pretty
much returned one or the other.

146
00:07:13,260 --> 00:07:15,010
We've returned one value.

147
00:07:15,010 --> 00:07:17,490
So any suggestions
for how we can perhaps

148
00:07:17,490 --> 00:07:22,380
solve this problem that I just created
for myself, whereby I want to return,

149
00:07:22,380 --> 00:07:28,080
really, a student, but I currently have
a name variable and a house variable.

150
00:07:28,080 --> 00:07:30,555
I'd minimally like to
return both of those.

151
00:07:30,555 --> 00:07:33,210
AUDIENCE: I believe that,
we can return a dictionary,

152
00:07:33,210 --> 00:07:35,010
includes the name and the house.

153
00:07:35,010 --> 00:07:36,843
DAVID J. MALAN: Yeah,
so we absolutely could

154
00:07:36,843 --> 00:07:40,980
return a dictionary-- a dict object in
Python, whereby maybe one key is name;

155
00:07:40,980 --> 00:07:43,650
one key is house; and the
values thereof are exactly

156
00:07:43,650 --> 00:07:44,900
the values of these variables.

157
00:07:44,900 --> 00:07:46,810
So we could totally do that.

158
00:07:46,810 --> 00:07:49,360
I worry that that might be
getting a little complicated.

159
00:07:49,360 --> 00:07:51,900
I wonder if there's a
simpler way instead.

160
00:07:51,900 --> 00:07:54,985
Any other instincts-- even if
you're not sure it would work?

161
00:07:54,985 --> 00:07:56,527
AUDIENCE: Return both name and house?

162
00:07:56,527 --> 00:07:58,318
DAVID J. MALAN: Return
both name and house.

163
00:07:58,318 --> 00:07:59,430
I like the sound of that.

164
00:07:59,430 --> 00:08:00,248
It sounds simple.

165
00:08:00,248 --> 00:08:03,040
I don't have to figure out what a
dictionary is going to look like.

166
00:08:03,040 --> 00:08:05,730
And in fact, this, too,
would be a valid approach,

167
00:08:05,730 --> 00:08:07,230
even if you've not seen this before.

168
00:08:07,230 --> 00:08:11,610
It turns out, in Python, that
you can return multiple values,

169
00:08:11,610 --> 00:08:12,960
but that's a bit of a white lie.

170
00:08:12,960 --> 00:08:16,320
Or we could take Muhammad's approach
of actually returning a dictionary

171
00:08:16,320 --> 00:08:17,820
and putting multiple keys therein.

172
00:08:17,820 --> 00:08:19,830
So here, again, we have
yet another example

173
00:08:19,830 --> 00:08:22,380
of how you can solve the same
problem in at least two ways,

174
00:08:22,380 --> 00:08:24,720
and I daresay we're
about to see even more.

175
00:08:24,720 --> 00:08:27,900
So one way you could solve
this problem, whereby

176
00:08:27,900 --> 00:08:32,919
you want to return multiple values,
would be to do something like this.

177
00:08:32,919 --> 00:08:37,650
I could go ahead and literally return
not just name, but I could put a comma

178
00:08:37,650 --> 00:08:39,270
and also return house.

179
00:08:39,270 --> 00:08:41,970
This is not necessarily something
you can do in other languages

180
00:08:41,970 --> 00:08:44,159
if you have programmed in
other languages before.

181
00:08:44,159 --> 00:08:45,420
It depends on the language.

182
00:08:45,420 --> 00:08:49,290
But it looks like, thanks to
this comma, maybe I can, in fact,

183
00:08:49,290 --> 00:08:51,930
return two values as
[INAUDIBLE] proposed.

184
00:08:51,930 --> 00:08:55,380
Well, if I'm returning to
values in this way on line 10,

185
00:08:55,380 --> 00:08:57,908
how do I get both
values at the same time?

186
00:08:57,908 --> 00:08:59,200
Well, there's a couple of ways.

187
00:08:59,200 --> 00:09:01,830
Let me go up to my main function.

188
00:09:01,830 --> 00:09:04,410
I know, minimally, I'm going
to have to change the get_name

189
00:09:04,410 --> 00:09:05,940
and get_house to get_student.

190
00:09:05,940 --> 00:09:09,030
But what am I going to
store the return value in?

191
00:09:09,030 --> 00:09:11,520
I think I could actually do this.

192
00:09:11,520 --> 00:09:14,920
And we have seen this technique
before, where you can unpack,

193
00:09:14,920 --> 00:09:17,550
so to speak, sequences of
values that are coming back.

194
00:09:17,550 --> 00:09:21,090
And indeed, consider this
to be exactly that. name,

195
00:09:21,090 --> 00:09:25,020
house is some kind of sequence that
I'm returning of values-- name, house.

196
00:09:25,020 --> 00:09:27,300
So if I want to unpack
those and store the return

197
00:09:27,300 --> 00:09:30,010
values in two separate
variables, I can, in fact,

198
00:09:30,010 --> 00:09:34,200
use the commas on the left-hand side of
my assignment operator, the equal sign,

199
00:09:34,200 --> 00:09:35,410
to do just that.

200
00:09:35,410 --> 00:09:40,020
Now, to be clear, I don't need to call
these variables name and house here.

201
00:09:40,020 --> 00:09:43,500
I could simplify this and
use just n here and h here,

202
00:09:43,500 --> 00:09:46,590
and then I could return just n and h.

203
00:09:46,590 --> 00:09:51,200
But I would argue that's not very clear
to the reader as to what's going on.

204
00:09:51,200 --> 00:09:52,950
So I think, in this
case, even though it's

205
00:09:52,950 --> 00:09:56,010
a coincidence that I've used the
same variable names in get_student

206
00:09:56,010 --> 00:09:59,890
and get_name, and in main, it's a
little more readable to someone like me.

207
00:09:59,890 --> 00:10:01,560
So I'm going to leave it as is.

208
00:10:01,560 --> 00:10:04,060
Well, let's go ahead and
see, now, if this works.

209
00:10:04,060 --> 00:10:07,170
Let me clear my screen down here
and run Python of student.py, Enter.

210
00:10:07,170 --> 00:10:08,370
Let's again type in Harry.

211
00:10:08,370 --> 00:10:11,040
Let's again type in Gryffindor, Enter.

212
00:10:11,040 --> 00:10:14,790
And voila, we still see that
Harry is from Gryffindor.

213
00:10:14,790 --> 00:10:16,950
But what are we actually doing here?

214
00:10:16,950 --> 00:10:19,660
What are we actually doing
by returning this value?

215
00:10:19,660 --> 00:10:24,320
Well, it turns out that what
we've just done is use a tuple.

216
00:10:24,320 --> 00:10:29,810
A tuple is another type of data in
Python that's a collection of values--

217
00:10:29,810 --> 00:10:32,300
x, y or x, y, z.

218
00:10:32,300 --> 00:10:36,770
It's similar in spirit to a list,
in that sense, but it's immutable.

219
00:10:36,770 --> 00:10:37,648
It's not mutable.

220
00:10:37,648 --> 00:10:38,690
Now, what does that mean?

221
00:10:38,690 --> 00:10:41,720
A list, as we've seen it before,
is a data structure in Python

222
00:10:41,720 --> 00:10:43,460
that you can change the values of.

223
00:10:43,460 --> 00:10:47,240
You can go into bracket 0 for the first
location and change the value there.

224
00:10:47,240 --> 00:10:50,210
You can go to bracket 1, bracket
2, bracket 3 and actually change

225
00:10:50,210 --> 00:10:51,450
the values in lists.

226
00:10:51,450 --> 00:10:54,800
But if you have no intention of
changing the values of variables

227
00:10:54,800 --> 00:10:57,748
and you want to return,
effectively, multiple values,

228
00:10:57,748 --> 00:10:59,540
you don't have to even
return it as a list.

229
00:10:59,540 --> 00:11:03,410
You can return it as a tuple
instead, just by using a comma.

230
00:11:03,410 --> 00:11:07,010
And it turns out we can make
explicit that-- here's the white lie.

231
00:11:07,010 --> 00:11:10,490
I'm not actually returning
to values per se.

232
00:11:10,490 --> 00:11:13,400
Whenever you use a comma
in this way on line 9,

233
00:11:13,400 --> 00:11:17,510
you're actually returning
one value, which is a tuple.

234
00:11:17,510 --> 00:11:20,280
Inside of that tuple now are two values.

235
00:11:20,280 --> 00:11:23,790
So it's similar in spirit to
returning one list with two thing Here

236
00:11:23,790 --> 00:11:26,300
I'm returning one tuple with two things.

237
00:11:26,300 --> 00:11:28,970
And the mere fact that I've
used a comma and nothing else

238
00:11:28,970 --> 00:11:31,370
tells Python that I indeed
want to return a tuple.

239
00:11:31,370 --> 00:11:34,100
But there's more explicit
syntax that we can use instead.

240
00:11:34,100 --> 00:11:39,290
I can actually-- more verbosely-- put
explicit parentheses around the values

241
00:11:39,290 --> 00:11:42,440
of this tuple just to make
more clear to me, to the reader

242
00:11:42,440 --> 00:11:44,090
that this isn't two values per se.

243
00:11:44,090 --> 00:11:46,520
This is one value with
two things inside of it.

244
00:11:46,520 --> 00:11:48,440
And what I can actually
do then, too, is--

245
00:11:48,440 --> 00:11:51,020
I don't have to unpack
this up here, so to speak.

246
00:11:51,020 --> 00:11:54,830
I can actually go up here and maybe
give a more apt name, like student,

247
00:11:54,830 --> 00:11:58,370
and I can name the value,
or rather name the variable

248
00:11:58,370 --> 00:12:01,340
in which I'm storing the
return value of get_student as,

249
00:12:01,340 --> 00:12:02,810
quote, unquote, "student."

250
00:12:02,810 --> 00:12:05,180
So maybe this is a
little better design now

251
00:12:05,180 --> 00:12:08,630
because I'm sort of abstracting
away what a student is.

252
00:12:08,630 --> 00:12:11,660
It's implemented at the moment
as a tuple with two values.

253
00:12:11,660 --> 00:12:15,890
But at least, now I have a variable
called what I mean, a student.

254
00:12:15,890 --> 00:12:17,360
But there's going to be a catch.

255
00:12:17,360 --> 00:12:21,590
On line 3, I still want to print out
that student's name and their house.

256
00:12:21,590 --> 00:12:24,560
But I don't have a name variable
anymore, and I don't have a house.

257
00:12:24,560 --> 00:12:28,640
And I also don't have a dictionary, as
was proposed earlier, so I can't even

258
00:12:28,640 --> 00:12:31,830
go at those keys by name.

259
00:12:31,830 --> 00:12:35,180
But what a tuple is-- it's very
similar in spirit to a list,

260
00:12:35,180 --> 00:12:36,980
but it is indeed just immutable.

261
00:12:36,980 --> 00:12:39,800
And what I mean by that is
I can still index into it

262
00:12:39,800 --> 00:12:45,050
numerically by saying
student [0] for the item

263
00:12:45,050 --> 00:12:47,000
in the first location in that tuple.

264
00:12:47,000 --> 00:12:50,420
And then over here, instead of
house, I can say student [1].

265
00:12:50,420 --> 00:12:54,275
student [1] is going to give me
the second location in that tuple.

266
00:12:54,275 --> 00:12:56,150
Let me go ahead and
clear my terminal window.

267
00:12:56,150 --> 00:12:58,100
Again, run Python of student.py.

268
00:12:58,100 --> 00:12:59,240
Let's type in Harry.

269
00:12:59,240 --> 00:13:04,520
Let's type in Gryffindor, Enter,
and we still have some working code.

270
00:13:04,520 --> 00:13:07,190
Let me pause here now
and see if there are

271
00:13:07,190 --> 00:13:11,510
any questions on this
technique of returning a tuple

272
00:13:11,510 --> 00:13:14,735
and indexing into it in this way.

273
00:13:14,735 --> 00:13:17,120
AUDIENCE: I guess, what's
an actual use case where

274
00:13:17,120 --> 00:13:21,347
you would use a tuple versus a list
or something else that's similar?

275
00:13:21,347 --> 00:13:23,180
DAVID J. MALAN: It's a
really good question.

276
00:13:23,180 --> 00:13:25,280
When would you use a
tuple versus a list?

277
00:13:25,280 --> 00:13:28,190
When you want to program
defensively, or, in general,

278
00:13:28,190 --> 00:13:31,380
when you know that the values in
this variable shouldn't change,

279
00:13:31,380 --> 00:13:34,320
so why would you use a data type
that allows them to be changed?

280
00:13:34,320 --> 00:13:37,790
It just invites mistakes,
bugs down the line, either

281
00:13:37,790 --> 00:13:40,650
by you or colleagues who are
interacting with your code.

282
00:13:40,650 --> 00:13:44,090
So tuple is just another
way where you can increase

283
00:13:44,090 --> 00:13:47,720
the probability of correctness by just
not letting anyone, yourself included,

284
00:13:47,720 --> 00:13:49,740
change the contents therein.

285
00:13:49,740 --> 00:13:52,260
So it's just another
tool in your toolkit.

286
00:13:52,260 --> 00:13:55,340
But let's make clear, then,
what I mean by "immutable."

287
00:13:55,340 --> 00:13:58,850
Again, I claim that "immutable" means
that you cannot change the value.

288
00:13:58,850 --> 00:14:01,020
Well, let's go ahead and try to do this.

289
00:14:01,020 --> 00:14:03,740
Let me go ahead and run this
program once more as is--

290
00:14:03,740 --> 00:14:05,300
Python of student.py.

291
00:14:05,300 --> 00:14:09,410
Let me go ahead and
type in, for instance--

292
00:14:09,410 --> 00:14:11,387
how about Padma's name?

293
00:14:11,387 --> 00:14:13,220
And I'm going to go
ahead and say that Padma

294
00:14:13,220 --> 00:14:14,930
is in Gryffindor as in the movies.

295
00:14:14,930 --> 00:14:16,940
And we see-- Padma from Gryffindor.

296
00:14:16,940 --> 00:14:20,810
But technically, I went down this
rabbit hole in looking at Harry Potter

297
00:14:20,810 --> 00:14:21,560
more closely.

298
00:14:21,560 --> 00:14:24,980
Technically, in the books, Padma,
I believe, was from Ravenclaw.

299
00:14:24,980 --> 00:14:27,080
So this is actually a
mistake or an inconsistency

300
00:14:27,080 --> 00:14:28,730
between the movies and the books.

301
00:14:28,730 --> 00:14:31,610
Let's see if we can't fix this
inconsistency in our code.

302
00:14:31,610 --> 00:14:33,200
So how about we do this?

303
00:14:33,200 --> 00:14:36,350
If the student's name that's
inputted equals Padma,

304
00:14:36,350 --> 00:14:40,220
why don't we override
whatever the house is

305
00:14:40,220 --> 00:14:42,890
and change it to be properly Gryffindor.

306
00:14:42,890 --> 00:14:46,070
Let me go ahead and do if student--

307
00:14:46,070 --> 00:14:49,700
now, if I want to get at Padma's name,
I'm going to have to do student [0].

308
00:14:49,700 --> 00:14:52,610
I have to know what location
the name is in in this tuple.

309
00:14:52,610 --> 00:14:57,740
But if that value equals equals Padma,
let's go ahead with this if statement

310
00:14:57,740 --> 00:14:58,670
and make a change.

311
00:14:58,670 --> 00:15:02,190
Let's change the student's [1] value.

312
00:15:02,190 --> 00:15:04,610
So the second value, if
we're zero indexing--

313
00:15:04,610 --> 00:15:07,370
let's change it to be another
house in the world of Harry Potter

314
00:15:07,370 --> 00:15:08,930
called Ravenclaw.

315
00:15:08,930 --> 00:15:11,750
So I'm just fixing
maybe the user's input.

316
00:15:11,750 --> 00:15:14,180
They watched the movie so
they type in Padma Gryffindor,

317
00:15:14,180 --> 00:15:17,330
but, mm-mm, in the books,
it was Padma from Ravenclaw.

318
00:15:17,330 --> 00:15:20,240
All right, let me go ahead and
go down to my terminal window,

319
00:15:20,240 --> 00:15:24,040
clear my terminal, and do
Python of student.py, Enter.

320
00:15:24,040 --> 00:15:26,995
I'm going to do Harry as well as
Gryffindor, just to demonstrate

321
00:15:26,995 --> 00:15:29,770
that that is still working as intended.

322
00:15:29,770 --> 00:15:33,970
Let me clear my screen again, though,
and run Python of student.py on Padma,

323
00:15:33,970 --> 00:15:37,480
and I'll put her, too, in Gryffindor,
as in the movies, and hit Enter.

324
00:15:37,480 --> 00:15:40,930
And now I just see a big
mess of errors on the screen.

325
00:15:40,930 --> 00:15:42,700
Some kind of exception has been thrown.

326
00:15:42,700 --> 00:15:45,160
And indeed, a type error has happened.

327
00:15:45,160 --> 00:15:48,730
I'm using a data type wherein there's
an error, and what is that error?

328
00:15:48,730 --> 00:15:53,030
Well, 'tuple' object does
not support item assignment.

329
00:15:53,030 --> 00:15:57,355
It's a little arcanely expressed-- that
is, it's not really very user friendly.

330
00:15:57,355 --> 00:15:59,230
But if you think about
what those words mean,

331
00:15:59,230 --> 00:16:01,450
'tuple" object does not
support item assignment.

332
00:16:01,450 --> 00:16:03,470
So assignment is copying
from right to left.

333
00:16:03,470 --> 00:16:05,200
So somehow, that's invalid.

334
00:16:05,200 --> 00:16:10,270
And here is a manifestation
of the immutability of tuples.

335
00:16:10,270 --> 00:16:14,200
You cannot change location
0 or 1 or anything inside.

336
00:16:14,200 --> 00:16:15,250
That is a feature.

337
00:16:15,250 --> 00:16:17,270
That is the design of a tuple.

338
00:16:17,270 --> 00:16:20,020
So if I want to override
that, I think I'm

339
00:16:20,020 --> 00:16:23,140
going to have to use a different
type of data that we've used before--

340
00:16:23,140 --> 00:16:24,730
namely a list, and that's fine.

341
00:16:24,730 --> 00:16:28,420
If you want to enable yourself
and colleagues using your code

342
00:16:28,420 --> 00:16:31,090
to change the contents
of that container,

343
00:16:31,090 --> 00:16:34,360
well, we can go ahead and
return not a tuple using

344
00:16:34,360 --> 00:16:37,550
explicit parentheses or no
parentheses, just the comma,

345
00:16:37,550 --> 00:16:39,250
but I can use square brackets.

346
00:16:39,250 --> 00:16:41,920
And if I'm using square brackets
on the left and the right,

347
00:16:41,920 --> 00:16:44,440
this is indeed explicitly a list.

348
00:16:44,440 --> 00:16:47,050
Same idea, but it's mutable.

349
00:16:47,050 --> 00:16:50,000
That is to say you can change
the contents of a list.

350
00:16:50,000 --> 00:16:53,110
So making no other changes,
just returning a list

351
00:16:53,110 --> 00:16:57,820
with square brackets instead of a tuple
with parentheses or just the comma.

352
00:16:57,820 --> 00:17:01,030
Let me go ahead now and run
Python of student.py, Enter.

353
00:17:01,030 --> 00:17:04,000
Let me type in Harry
and Gryffindor again.

354
00:17:04,000 --> 00:17:05,470
That's still working.

355
00:17:05,470 --> 00:17:06,400
Good to see.

356
00:17:06,400 --> 00:17:11,410
Let me run this once more and type in
Padma and Gryffindor, as in the movies,

357
00:17:11,410 --> 00:17:15,339
but no, now we've corrected
it to be Padma from Ravenclaw,

358
00:17:15,339 --> 00:17:17,970
as in the books instead.

359
00:17:17,970 --> 00:17:22,560
Any questions now on tuples
versus lists or this idea

360
00:17:22,560 --> 00:17:26,549
of immutability versus mutability.

361
00:17:26,549 --> 00:17:31,845
AUDIENCE: Can we use a nested
tuple in Python, like a nest list?

362
00:17:31,845 --> 00:17:32,970
DAVID J. MALAN: Absolutely.

363
00:17:32,970 --> 00:17:35,250
You can have not only
nested lists in Python,

364
00:17:35,250 --> 00:17:38,282
where one of the elements in a
list could be another list-- so you

365
00:17:38,282 --> 00:17:41,490
have some square brackets out here; you
might have some other square brackets

366
00:17:41,490 --> 00:17:42,030
inside.

367
00:17:42,030 --> 00:17:44,830
You can absolutely do the
same with a tuple as well.

368
00:17:44,830 --> 00:17:47,820
There is no constraint on the types
of values you can put in there.

369
00:17:47,820 --> 00:17:50,140
We've not had occasion
to do that in this case.

370
00:17:50,140 --> 00:17:54,030
I'm just returning a simple
tuple with two elements.

371
00:17:54,030 --> 00:17:56,310
But yes, you could
absolutely do that, too.

372
00:17:56,310 --> 00:17:59,415
Other questions on tuples versus lists?

373
00:17:59,415 --> 00:18:03,210
AUDIENCE: OK, for example,
when I see the square brackets,

374
00:18:03,210 --> 00:18:05,258
is it mainly used for the list?

375
00:18:05,258 --> 00:18:07,050
DAVID J. MALAN: Oh, a
really good question.

376
00:18:07,050 --> 00:18:07,860
Sort of.

377
00:18:07,860 --> 00:18:12,248
So when you create a value like
a list, you use square brackets,

378
00:18:12,248 --> 00:18:14,040
and that would indeed
be a visual indicator

379
00:18:14,040 --> 00:18:16,470
that this is definitely a list.

380
00:18:16,470 --> 00:18:19,050
If you instead see parentheses,
that's a visual indicator,

381
00:18:19,050 --> 00:18:21,690
when creating a value, that
it's definitely a tuple.

382
00:18:21,690 --> 00:18:26,400
However, somewhat confusingly,
both lists and tuples

383
00:18:26,400 --> 00:18:30,390
use square brackets when you
access the contents of them.

384
00:18:30,390 --> 00:18:34,020
When you index into them
at location 0 or location 1

385
00:18:34,020 --> 00:18:36,070
you always use square brackets.

386
00:18:36,070 --> 00:18:37,500
So that's the distinction there.

387
00:18:37,500 --> 00:18:38,880
Good question.

388
00:18:38,880 --> 00:18:42,930
Allow me to propose now, if I may, that
we solve this problem yet another way,

389
00:18:42,930 --> 00:18:46,260
and let's see if we're either making
things better or for worse than us.

390
00:18:46,260 --> 00:18:49,920
Recall that dictionaries, or dict
objects, also exist in Python.

391
00:18:49,920 --> 00:18:53,250
And a dictionary is this
collection of keys and values.

392
00:18:53,250 --> 00:18:55,470
And the upside, in
particular, of a dictionary

393
00:18:55,470 --> 00:18:57,090
is that they have better semantics.

394
00:18:57,090 --> 00:18:59,640
You don't just have to
assume that a name is always

395
00:18:59,640 --> 00:19:03,300
going to be at location 0; house is
always going to be at location 1.

396
00:19:03,300 --> 00:19:06,930
That's the kind of thing, especially if
you had three, four, or more values--

397
00:19:06,930 --> 00:19:09,990
eventually you or someone is
going to get confused and forget

398
00:19:09,990 --> 00:19:12,960
what the order is and you're
going to write buggy code.

399
00:19:12,960 --> 00:19:15,330
So a dictionary is a
little more powerful

400
00:19:15,330 --> 00:19:18,990
in that you can semantically
associate keys, little descriptions,

401
00:19:18,990 --> 00:19:20,040
with the values--

402
00:19:20,040 --> 00:19:22,525
those keys and those
values, respectively.

403
00:19:22,525 --> 00:19:25,650
So let me go ahead and do this, and we
can do this in a few different ways.

404
00:19:25,650 --> 00:19:28,950
But let me propose that we
focus on get_student here .

405
00:19:28,950 --> 00:19:30,580
And let's go ahead and do this.

406
00:19:30,580 --> 00:19:35,880
Let me go ahead and delete the
implementation of get_student as is.

407
00:19:35,880 --> 00:19:40,080
Let me create a student variable and
initialize it to an empty dictionary.

408
00:19:40,080 --> 00:19:43,080
And I can do that with
just two curly braces here.

409
00:19:43,080 --> 00:19:46,950
And then let me go ahead and set
two keys inside of that dictionary.

410
00:19:46,950 --> 00:19:49,710
Inside of the student, there
will be, quote unquote, a "name"

411
00:19:49,710 --> 00:19:53,610
key, and the value of that is going to
be whatever the return value of input

412
00:19:53,610 --> 00:19:55,620
is when I prompt the
user for their name.

413
00:19:55,620 --> 00:19:59,700
And then the "house" key, inside
of that same student dictionary,

414
00:19:59,700 --> 00:20:02,730
is going to be the return value
of whatever the user types

415
00:20:02,730 --> 00:20:07,020
in for their house. , And lastly I'm
going to go ahead and return student.

416
00:20:07,020 --> 00:20:11,010
So now I am literally
returning one thing, still,

417
00:20:11,010 --> 00:20:15,300
but this time, it's a dict rather
than a tuple, rather than a list.

418
00:20:15,300 --> 00:20:18,060
But there are still two things
in it, technically four things

419
00:20:18,060 --> 00:20:19,710
if you count the keys and the values.

420
00:20:19,710 --> 00:20:22,088
But there's two key value pairs.

421
00:20:22,088 --> 00:20:24,630
Now, my code up here is going
to have to change a little bit.

422
00:20:24,630 --> 00:20:27,390
And let's simplify this and
remove, for instance, now

423
00:20:27,390 --> 00:20:31,470
the Padma if statement just to
focus on what's changing at hand.

424
00:20:31,470 --> 00:20:34,020
And let me go ahead now
and leave line 2 alone.

425
00:20:34,020 --> 00:20:37,710
I'm still going to have a student
variable that gets assigned the return

426
00:20:37,710 --> 00:20:39,150
value of get_student.

427
00:20:39,150 --> 00:20:45,390
But what I want to do here now is
actually access the keys inside of that

428
00:20:45,390 --> 00:20:49,080
dictionary-- not by numeric index,
which was for tuples and lists--

429
00:20:49,080 --> 00:20:52,530
0 and 1, but by way of the keys.

430
00:20:52,530 --> 00:20:55,290
Now, normally, I might be in
the habit, as I personally

431
00:20:55,290 --> 00:20:58,920
am, of using double quotes-- quote,
unquote, "name" inside of there

432
00:20:58,920 --> 00:21:02,170
and quote, unquote,
"house" inside of there.

433
00:21:02,170 --> 00:21:05,820
But before I even run this
code and show you a mistake--

434
00:21:05,820 --> 00:21:08,760
see an error on the screen,
does anyone want to call out

435
00:21:08,760 --> 00:21:10,680
what I have done wrong here?

436
00:21:10,680 --> 00:21:12,360
This is just an f string.

437
00:21:12,360 --> 00:21:16,710
I just want to print out the value of
the name key, the value of the house

438
00:21:16,710 --> 00:21:18,660
key in this dictionary.

439
00:21:18,660 --> 00:21:21,070
AUDIENCE: [INAUDIBLE]

440
00:21:21,070 --> 00:21:21,348


441
00:21:21,348 --> 00:21:23,640
DAVID J. MALAN: Your audio
was a little garbled for us.

442
00:21:23,640 --> 00:21:26,230
But I think I heard double
quotes and single quotes.

443
00:21:26,230 --> 00:21:29,710
So I'm going to assume that, indeed,
you've identified precisely the issue.

444
00:21:29,710 --> 00:21:31,560
I'm just going to
confuse Python right now.

445
00:21:31,560 --> 00:21:35,820
Even though this is an f string inside
of double quotes, prefixed with an f,

446
00:21:35,820 --> 00:21:39,005
I can't actually use my double
quotes inside my double quotes

447
00:21:39,005 --> 00:21:41,130
because that's going to
potentially confuse Python.

448
00:21:41,130 --> 00:21:44,370
If I run this program now,
Python of student.py and hit

449
00:21:44,370 --> 00:21:46,180
Enter, I get a syntax error.

450
00:21:46,180 --> 00:21:48,000
So the program didn't even run fully.

451
00:21:48,000 --> 00:21:51,970
It just couldn't be understood because
it got confused by those double quotes.

452
00:21:51,970 --> 00:21:54,060
So the simplest fix
here would indeed just

453
00:21:54,060 --> 00:21:58,260
be to use not double quotes but
single quotes around the keys,

454
00:21:58,260 --> 00:22:02,058
or conversely, flip the double quotes
on the outside to single quotes,

455
00:22:02,058 --> 00:22:03,600
then use double quotes in the inside.

456
00:22:03,600 --> 00:22:05,110
You just want to be consistent.

457
00:22:05,110 --> 00:22:09,060
So a subtle detail, but again, this
is now specific to dictionary syntax.

458
00:22:09,060 --> 00:22:14,673
This isn't fundamental to how we're
solving this current problem at hand.

459
00:22:14,673 --> 00:22:16,090
Well, let's go ahead and try this.

460
00:22:16,090 --> 00:22:18,400
Let me go ahead now and
run Python of student.py.

461
00:22:18,400 --> 00:22:19,840
Let's go ahead and type in Harry.

462
00:22:19,840 --> 00:22:20,920
Let's type in Gryffindor.

463
00:22:20,920 --> 00:22:24,070
And hopefully, Harry is
back from Gryffindor.

464
00:22:24,070 --> 00:22:25,360
No syntax errors.

465
00:22:25,360 --> 00:22:26,260
No other errors.

466
00:22:26,260 --> 00:22:28,000
I think I'm back in business here.

467
00:22:28,000 --> 00:22:31,120
And what I do like to be
clear about using a dictionary

468
00:22:31,120 --> 00:22:34,000
is that it's allowing me
just better semantics.

469
00:22:34,000 --> 00:22:38,950
And again, I don't have to remember,
memorize, document that 0 is name;

470
00:22:38,950 --> 00:22:40,180
1 is house.

471
00:22:40,180 --> 00:22:43,312
Instead, "name" is name
and "house" is house.

472
00:22:43,312 --> 00:22:45,520
It's just a little clearer,
a little more expressive.

473
00:22:45,520 --> 00:22:49,270
So that's generally a good thing,
especially if we stored more data about

474
00:22:49,270 --> 00:22:52,990
students than just their name and their
house-- if you had three fields, four,

475
00:22:52,990 --> 00:22:54,640
five, 10 different fields--

476
00:22:54,640 --> 00:22:58,870
no one's going to want to remember or be
able to remember forever which is zero

477
00:22:58,870 --> 00:23:00,610
which is 1, which is 2, and so forth.

478
00:23:00,610 --> 00:23:04,960
Better to introduce names, like
"name" and "house" in this case.

479
00:23:04,960 --> 00:23:07,120
But let me tighten this up further.

480
00:23:07,120 --> 00:23:10,540
I'm typically in the habit of not
introducing variables unnecessarily,

481
00:23:10,540 --> 00:23:12,250
unless they make the code more readable.

482
00:23:12,250 --> 00:23:15,940
And an alternative way to format
the same code would be this.

483
00:23:15,940 --> 00:23:19,330
Strictly speaking, I don't need
to create an empty dictionary,

484
00:23:19,330 --> 00:23:23,380
then add one key to it,
then add a second key to it,

485
00:23:23,380 --> 00:23:25,360
and then return that dictionary.

486
00:23:25,360 --> 00:23:29,470
I can actually consolidate this all
into one statement, if you will.

487
00:23:29,470 --> 00:23:30,950
Let me go ahead and do this.

488
00:23:30,950 --> 00:23:35,470
Let me go ahead and say name
equals inputs return value,

489
00:23:35,470 --> 00:23:38,567
house equals inputs
return value, and then,

490
00:23:38,567 --> 00:23:41,650
instead of returning any variable name
student, which I'm going to propose

491
00:23:41,650 --> 00:23:44,200
doesn't need to exist
anymore, let me just create

492
00:23:44,200 --> 00:23:46,430
and return the dictionary all at once.

493
00:23:46,430 --> 00:23:50,470
Let me do, quote, unquote, "name" in
lowercase here, and then the variable.

494
00:23:50,470 --> 00:23:52,030
It's storing the user's name.

495
00:23:52,030 --> 00:23:55,210
Then, quote, unquote, "house," as
my second key, the value of which

496
00:23:55,210 --> 00:23:57,070
is going to be house, the variable.

497
00:23:57,070 --> 00:23:58,150
Now, is this better?

498
00:23:58,150 --> 00:23:59,012
Maybe, maybe not.

499
00:23:59,012 --> 00:24:00,970
Maybe the first way was
a little more readable,

500
00:24:00,970 --> 00:24:03,400
and that's totally fine
to create variables

501
00:24:03,400 --> 00:24:05,830
if they improve the
readability of your code.

502
00:24:05,830 --> 00:24:09,850
But just know that you can also create
and return a dictionary on the fly

503
00:24:09,850 --> 00:24:12,225
like this, so to speak,
all in one line, and I

504
00:24:12,225 --> 00:24:14,350
think it's arguably pretty
reasonable in this case.

505
00:24:14,350 --> 00:24:14,860
Why?

506
00:24:14,860 --> 00:24:16,088
It's just pretty short.

507
00:24:16,088 --> 00:24:18,880
I probably wouldn't do this if it
got longer and longer and longer.

508
00:24:18,880 --> 00:24:22,600
I might minimally then start moving
my key value pairs to separate lines.

509
00:24:22,600 --> 00:24:27,470
But this would just be a slightly more
compact way of doing this as well.

510
00:24:27,470 --> 00:24:29,390
But let me propose we
do one more change.

511
00:24:29,390 --> 00:24:32,950
Let's go ahead and introduce
that same special casing of Padma

512
00:24:32,950 --> 00:24:36,460
to fix her house from Gryffindor,
for instance, to Ravenclaw.

513
00:24:36,460 --> 00:24:38,230
How do we do this with dictionaries?

514
00:24:38,230 --> 00:24:41,620
Well, dictionaries,
like lists, are mutable.

515
00:24:41,620 --> 00:24:45,400
You can change what is in
them, just like you can lists.

516
00:24:45,400 --> 00:24:46,240
How do you do that?

517
00:24:46,240 --> 00:24:48,032
It's just a little
different syntactically.

518
00:24:48,032 --> 00:24:50,290
So let's go back into
main and do this fix.

519
00:24:50,290 --> 00:24:57,700
If the student variable has a name
key that equals equals Padma, then,

520
00:24:57,700 --> 00:25:04,390
indented, go ahead and change the value
of the house key inside of that student

521
00:25:04,390 --> 00:25:08,660
dictionary to be, quote,
unquote, "Ravenclaw" instead.

522
00:25:08,660 --> 00:25:11,410
So very similar in spirit
to what we did with a list.

523
00:25:11,410 --> 00:25:16,270
But instead of using location 0 and 1,
we're much more clearly, explicitly,

524
00:25:16,270 --> 00:25:19,390
semantically using, quote, unquote,
"name" and, quote, unquote,

525
00:25:19,390 --> 00:25:24,250
"house," because you index into lists
and tuples using numbers, but you index

526
00:25:24,250 --> 00:25:27,910
into dictionaries using
strings, as I've done here.

527
00:25:27,910 --> 00:25:31,240
All right, let me go ahead
and run Python of student.py.

528
00:25:31,240 --> 00:25:33,190
We'll again do Harry from Gryffindor.

529
00:25:33,190 --> 00:25:35,140
And I think all is well.

530
00:25:35,140 --> 00:25:38,710
Let me run it one more time this
time with Padma, who, in the movies,

531
00:25:38,710 --> 00:25:43,360
is from Gryffindor, but should
really be from Ravenclaw.

532
00:25:43,360 --> 00:25:49,240
Any questions then on this progression
from tuples to lists to dictionaries?

533
00:25:49,240 --> 00:25:53,450
We haven't necessarily introduced
anything new, other than those tuples,

534
00:25:53,450 --> 00:25:56,260
which have been available
to us all this time.

535
00:25:56,260 --> 00:25:59,980
But the goal at the moment is just
to demonstrate this distinction

536
00:25:59,980 --> 00:26:02,230
among these different
data types and how they

537
00:26:02,230 --> 00:26:04,350
each work a little bit differently.

538
00:26:04,350 --> 00:26:10,420
AUDIENCE: What if a combination
of lists is there in our tuple?

539
00:26:10,420 --> 00:26:16,140
We can change the list because are
immutable but lists are mutable?

540
00:26:16,140 --> 00:26:17,140
DAVID J. MALAN: Correct.

541
00:26:17,140 --> 00:26:19,300
You can change the
contents of lists, and you

542
00:26:19,300 --> 00:26:23,110
can put most anything you want in them--
other lists or strings, as I've done,

543
00:26:23,110 --> 00:26:24,580
integers, or anything else.

544
00:26:24,580 --> 00:26:27,910
Tuples you can do the exact same
thing, but you cannot change them once

545
00:26:27,910 --> 00:26:29,080
you've created them.

546
00:26:29,080 --> 00:26:33,040
A dictionary is more like a
list in that it is mutable.

547
00:26:33,040 --> 00:26:34,210
You can change it.

548
00:26:34,210 --> 00:26:37,600
But the way you index
into a dictionary is

549
00:26:37,600 --> 00:26:40,540
by way of these keys, these
strings, as we keep saying,

550
00:26:40,540 --> 00:26:42,250
rather than by numbers--

551
00:26:42,250 --> 00:26:45,100
those numeric indices.

552
00:26:45,100 --> 00:26:47,860
All right, well, let me
propose that there is yet

553
00:26:47,860 --> 00:26:50,450
another way of solving this problem.

554
00:26:50,450 --> 00:26:53,890
And I would argue that there's
now an opportunity at hand.

555
00:26:53,890 --> 00:26:56,770
Even though this program isn't
particularly complicated--

556
00:26:56,770 --> 00:27:01,210
all I'm doing is collecting a
name from the user and a house

557
00:27:01,210 --> 00:27:03,160
from the user-- you
could imagine wanting,

558
00:27:03,160 --> 00:27:05,290
longer term, to collect
even more information,

559
00:27:05,290 --> 00:27:07,780
like the student's
patronus or magical spell

560
00:27:07,780 --> 00:27:10,660
or a whole bunch of other information
that might belong in a student.

561
00:27:10,660 --> 00:27:15,310
And right now, we're just using
these very general purpose data

562
00:27:15,310 --> 00:27:16,450
types in Python--

563
00:27:16,450 --> 00:27:20,090
a tuple to combine some values
together; a list to do the same,

564
00:27:20,090 --> 00:27:23,620
but let us change it later; a
dictionary, which is more powerful

565
00:27:23,620 --> 00:27:25,270
because it's a little more structured.

566
00:27:25,270 --> 00:27:28,690
It does have keys, and it
has values, not just values.

567
00:27:28,690 --> 00:27:30,230
But you know what?

568
00:27:30,230 --> 00:27:33,520
We wouldn't have to be having this
conversation if the authors of Python

569
00:27:33,520 --> 00:27:37,105
had just given us a data
type called student.

570
00:27:37,105 --> 00:27:38,980
Wouldn't it have been
nice if there were just

571
00:27:38,980 --> 00:27:42,180
a type of variable I could
create in my code called student?

572
00:27:42,180 --> 00:27:43,930
Then we wouldn't have
to figure out, well,

573
00:27:43,930 --> 00:27:46,420
do we use a tuple or a
list or a dictionary?

574
00:27:46,420 --> 00:27:48,340
But that's pretty reasonable.

575
00:27:48,340 --> 00:27:52,180
You can imagine just how slippery
of a slope that is, so to speak,

576
00:27:52,180 --> 00:27:55,150
if the creators of a
language had to anticipate

577
00:27:55,150 --> 00:27:58,240
all the possible types of
data that programmers like you

578
00:27:58,240 --> 00:28:00,380
and me want to store in your programs.

579
00:28:00,380 --> 00:28:02,890
So they just gave us these
general purpose tools.

580
00:28:02,890 --> 00:28:05,740
But they gave us another
general purpose tool

581
00:28:05,740 --> 00:28:09,370
that's going to allow us to
create our own data types as well

582
00:28:09,370 --> 00:28:14,300
and actually give them names,
and that terminology is a class.

583
00:28:14,300 --> 00:28:20,110
A class is like a blueprint
for pieces of data objects.

584
00:28:20,110 --> 00:28:24,160
A class is a mold that you
can define and give a name.

585
00:28:24,160 --> 00:28:26,860
And when you use that mold
or you use that blueprint,

586
00:28:26,860 --> 00:28:31,010
you get types of data that are
designed exactly as you want.

587
00:28:31,010 --> 00:28:36,220
So in short, classes allow you to
invent your own data types in Python

588
00:28:36,220 --> 00:28:37,360
and give them a name.

589
00:28:37,360 --> 00:28:41,290
And this is a primary feature
of object oriented programming,

590
00:28:41,290 --> 00:28:44,050
to be able to create your
own objects in this way

591
00:28:44,050 --> 00:28:48,280
and, in the case of Python in classes,
even give them some custom names.

592
00:28:48,280 --> 00:28:50,350
So what does this mean in real terms?

593
00:28:50,350 --> 00:28:52,390
Well, let me go ahead
and come back to VS Code

594
00:28:52,390 --> 00:28:56,500
here, and let me propose that we
introduce a little bit of new syntax.

595
00:28:56,500 --> 00:28:58,930
I'm going to go ahead and
clear my terminal window first.

596
00:28:58,930 --> 00:29:02,800
I'm going to go to the top of my file,
and I'm just going to start a thought

597
00:29:02,800 --> 00:29:03,910
but not finish it yet.

598
00:29:03,910 --> 00:29:09,070
I'm going to use this new keyword for
classes, called, literally, class,

599
00:29:09,070 --> 00:29:11,720
so the new keyword we're
going to have here.

600
00:29:11,720 --> 00:29:13,923
And if I go back to
our slides here, this

601
00:29:13,923 --> 00:29:16,090
would be the official URL
where you can read up more

602
00:29:16,090 --> 00:29:18,010
on this particular feature of Python.

603
00:29:18,010 --> 00:29:22,090
In the official tutorial, class
is a new keyword we can use.

604
00:29:22,090 --> 00:29:25,510
Now, this is coincidentally related to
students because students take classes,

605
00:29:25,510 --> 00:29:28,510
but it has nothing to do with the
fact that we're dealing with students.

606
00:29:28,510 --> 00:29:31,780
Class is a general purpose
term in a lot of languages--

607
00:29:31,780 --> 00:29:35,500
Python among them-- that allow you
to define these custom containers

608
00:29:35,500 --> 00:29:38,630
with custom names for pieces of data.

609
00:29:38,630 --> 00:29:39,880
So let's go back to VS Code.

610
00:29:39,880 --> 00:29:41,350
Let's use this new keyword.

611
00:29:41,350 --> 00:29:44,500
And let me propose that we
create a class called Student.

612
00:29:44,500 --> 00:29:47,020
And by convention, I'm going
to use a capital S here,

613
00:29:47,020 --> 00:29:49,570
and I'm going to go
ahead, and with a colon,

614
00:29:49,570 --> 00:29:52,490
get to, later, the
implementation of this class.

615
00:29:52,490 --> 00:29:55,615
So I'm just going to use dot dot dot,
which is a valid placeholder for now,

616
00:29:55,615 --> 00:29:57,823
that just indicates to me
that I'm going to come back

617
00:29:57,823 --> 00:29:58,990
to implementing this later.

618
00:29:58,990 --> 00:30:02,110
But as of now, it does, in fact, exist.

619
00:30:02,110 --> 00:30:08,470
I now have a student class defined for
me that I can now use in my code here.

620
00:30:08,470 --> 00:30:09,860
How am I going to use it?

621
00:30:09,860 --> 00:30:13,240
Well, first of all, let
me go down to get_student,

622
00:30:13,240 --> 00:30:18,610
and let me change this code to no longer
use a dictionary but to use this class.

623
00:30:18,610 --> 00:30:19,660
I'm going to do this.

624
00:30:19,660 --> 00:30:22,810
I'm going to give myself a variable
called student, as I've done before,

625
00:30:22,810 --> 00:30:26,170
but I'm going to set it
equal to capital Student ().

626
00:30:26,170 --> 00:30:28,900


627
00:30:28,900 --> 00:30:32,200
So I'm going to do what appears
to be calling a function

628
00:30:32,200 --> 00:30:35,590
and that function, Student
with a capital S, notice,

629
00:30:35,590 --> 00:30:39,490
matches the name that I gave
this class at the top of my file.

630
00:30:39,490 --> 00:30:41,170
All right, what do I next want to do?

631
00:30:41,170 --> 00:30:43,330
I'm going to go ahead and
give this student a name.

632
00:30:43,330 --> 00:30:46,060
Now, if I were still
using a dictionary, I

633
00:30:46,060 --> 00:30:50,560
would say student, quote, unquote,
"name," using square brackets.

634
00:30:50,560 --> 00:30:52,120
But this is not a dictionary.

635
00:30:52,120 --> 00:30:54,490
It turns out classes
have what, for now, we'll

636
00:30:54,490 --> 00:30:58,910
call attributes, properties of sorts
that allow you to specify values inside

637
00:30:58,910 --> 00:30:59,410
of them.

638
00:30:59,410 --> 00:31:01,720
And the syntax for that
happens to be a dot.

639
00:31:01,720 --> 00:31:03,160
We've seen dots before.

640
00:31:03,160 --> 00:31:06,340
We've used it in the context of
modules and libraries, more generally.

641
00:31:06,340 --> 00:31:08,860
This is another similar
in spirit use of a dot

642
00:31:08,860 --> 00:31:12,140
that allows you to get at
something inside of something else.

643
00:31:12,140 --> 00:31:15,190
So student.name is
going to be the syntax

644
00:31:15,190 --> 00:31:18,070
I use for giving this student a name.

645
00:31:18,070 --> 00:31:21,670
And that name is going to be whatever
the return value of "Name" is.

646
00:31:21,670 --> 00:31:24,970
And then I'm going to go ahead
and say student.house to give

647
00:31:24,970 --> 00:31:29,272
another attribute called "House" and
give that the return value of input

648
00:31:29,272 --> 00:31:30,730
here, prompting the user for house.

649
00:31:30,730 --> 00:31:33,610
And then, as before, I'm
just going to return student.

650
00:31:33,610 --> 00:31:37,180
But now what's really
powerful about class,

651
00:31:37,180 --> 00:31:39,790
and object-oriented
programming more generally,

652
00:31:39,790 --> 00:31:43,360
is that I've created this custom
data type called, literally,

653
00:31:43,360 --> 00:31:47,340
Student, capital S. I've stored
one such student in a variable

654
00:31:47,340 --> 00:31:50,820
like I can always do in a variable
called student, lowercase s.

655
00:31:50,820 --> 00:31:52,320
But I could call it anything I want.

656
00:31:52,320 --> 00:31:56,160
It just makes sense to call it student
as well, but lowercase for clarity.

657
00:31:56,160 --> 00:31:58,300
And then I'm returning that variable.

658
00:31:58,300 --> 00:32:01,680
And because of my syntax
in lines 14 and 15,

659
00:32:01,680 --> 00:32:05,070
that has the result of
putting inside of that class

660
00:32:05,070 --> 00:32:09,300
a name attribute and a house attribute.

661
00:32:09,300 --> 00:32:11,610
I just need to make one
more change up here.

662
00:32:11,610 --> 00:32:13,410
I'm going to go ahead
and remove our Padma

663
00:32:13,410 --> 00:32:15,510
code, just so we can
focus only on what's new,

664
00:32:15,510 --> 00:32:17,400
rather than fixing her house.

665
00:32:17,400 --> 00:32:20,190
And I'm going to go in here
and change the syntax that

666
00:32:20,190 --> 00:32:21,930
previously was for dictionaries.

667
00:32:21,930 --> 00:32:26,970
Again, dictionaries use square
brackets and then strings in quotes--

668
00:32:26,970 --> 00:32:29,970
either single quotes or double
quotes, depending on the context.

669
00:32:29,970 --> 00:32:33,210
Here, though, I'm going to
change this to be student.name,

670
00:32:33,210 --> 00:32:37,440
and over here, I'm going to
change it to be student.house.

671
00:32:37,440 --> 00:32:40,800
And that's just going to be my new
syntax for getting the contents of what

672
00:32:40,800 --> 00:32:43,230
appears to be a class called student.

673
00:32:43,230 --> 00:32:47,460
Let me go ahead and rerun
Python of student.py, Enter.

674
00:32:47,460 --> 00:32:49,320
Let's type in Harry's name as before.

675
00:32:49,320 --> 00:32:52,500
Let's put him in Gryffindor,
crossing our fingers as we often do,

676
00:32:52,500 --> 00:32:56,500
and Harry is indeed from Gryffindor.

677
00:32:56,500 --> 00:32:58,150
What, though, have I done?

678
00:32:58,150 --> 00:33:01,000
Let's introduce one other
bit of terminology here

679
00:33:01,000 --> 00:33:05,590
it turns out that I can create a
class, using that class keyword.

680
00:33:05,590 --> 00:33:09,970
But any time you use a class, you're
creating what are called objects.

681
00:33:09,970 --> 00:33:14,680
And here is the word objects, as an
object-oriented programming, or OOP.

682
00:33:14,680 --> 00:33:16,243
Let me go back to my code here.

683
00:33:16,243 --> 00:33:18,910
And even though I haven't really
implemented much of it at all--

684
00:33:18,910 --> 00:33:20,950
I literally just left it
with a dot, dot, dot--

685
00:33:20,950 --> 00:33:25,420
that's enough code, lines 1 and 2,
to just invent a new data type called

686
00:33:25,420 --> 00:33:29,710
Student, capital S, that may or may not
have some future functionality as well.

687
00:33:29,710 --> 00:33:31,390
That's enough to create a class.

688
00:33:31,390 --> 00:33:34,150
What, though, am I doing on line 11?

689
00:33:34,150 --> 00:33:40,100
On line 11, what I'm technically doing
is creating an object of that class.

690
00:33:40,100 --> 00:33:42,010
So this, too, is another term of art.

691
00:33:42,010 --> 00:33:44,780
You create objects from classes.

692
00:33:44,780 --> 00:33:47,020
So if we go back to that
metaphor, that a class is

693
00:33:47,020 --> 00:33:50,910
like a blueprint for a house
or a class is like a mold,

694
00:33:50,910 --> 00:33:54,760
an object is when you use that
blueprint to build a specific house

695
00:33:54,760 --> 00:33:58,450
or something that comes out of-- in
plaster, the mold, when you actually

696
00:33:58,450 --> 00:34:01,270
use that mold to create such an object.

697
00:34:01,270 --> 00:34:04,900
So a class is, again, the
definition of a new data type.

698
00:34:04,900 --> 00:34:10,120
The object is the incarnation of,
or technically instantiation of.

699
00:34:10,120 --> 00:34:13,570
And another term for objects
would actually be an instance.

700
00:34:13,570 --> 00:34:16,190
You have instances of classes as well.

701
00:34:16,190 --> 00:34:17,440
So that's a lot of vocabulary.

702
00:34:17,440 --> 00:34:19,690
But at the end of the day,
it just boils down to this.

703
00:34:19,690 --> 00:34:22,730
You can define your own class,
which is really your own data type.

704
00:34:22,730 --> 00:34:26,800
You can then store attributes inside
of it, using this dot notation here.

705
00:34:26,800 --> 00:34:31,040
And then you can access those same
attributes using code like this here.

706
00:34:31,040 --> 00:34:33,969
And now, I have a proper
"student" data type,

707
00:34:33,969 --> 00:34:36,610
and I don't have to
hack something together

708
00:34:36,610 --> 00:34:39,010
using a tuple or a list
or even a dictionary.

709
00:34:39,010 --> 00:34:43,510
I now have a proper data type called
"student" that the authors of Python

710
00:34:43,510 --> 00:34:46,060
didn't give me; I gave myself.

711
00:34:46,060 --> 00:34:50,800
Any questions now on classes, this
new keyword, class, or this idea

712
00:34:50,800 --> 00:34:53,605
of these objects or instances thereof?

713
00:34:53,605 --> 00:34:58,317
AUDIENCE: Is the class
object mutable or immutable?

714
00:34:58,317 --> 00:34:59,650
DAVID J. MALAN: A good question.

715
00:34:59,650 --> 00:35:02,200
And we've clearly laid the stage
for having that conversation

716
00:35:02,200 --> 00:35:03,550
about every data type now.

717
00:35:03,550 --> 00:35:07,960
We will see that they are mutable,
but you can make them immutable.

718
00:35:07,960 --> 00:35:10,100
So you can get the best of both worlds.

719
00:35:10,100 --> 00:35:13,420
Now, by writing some actual code-- and
we'll write more code than the dot,

720
00:35:13,420 --> 00:35:18,205
dot, dot in just a bit, other questions
on classes or these objects thereof?

721
00:35:18,205 --> 00:35:21,635
AUDIENCE: Then what would be
the properties of those classes?

722
00:35:21,635 --> 00:35:24,760
DAVID J. MALAN: So at the moment, the
properties of-- or the attributes of,

723
00:35:24,760 --> 00:35:28,270
as I've been calling them thus far--
would just be "Name" and "House."

724
00:35:28,270 --> 00:35:32,320
It turns out that there may very well
be other attributes built into classes

725
00:35:32,320 --> 00:35:33,550
that we may see before long.

726
00:35:33,550 --> 00:35:36,160
But for now, the only two
attributes that I care about

727
00:35:36,160 --> 00:35:38,320
are the ones that I myself created--

728
00:35:38,320 --> 00:35:42,222
namely "Name" and "House" or,
again, what I would call attributes.

729
00:35:42,222 --> 00:35:43,930
And in a little bit,
we're going to start

730
00:35:43,930 --> 00:35:47,560
calling those same attributes, more
technically, instance variables.

731
00:35:47,560 --> 00:35:50,710
"Name" and "House," as I
presented them here in VS Code

732
00:35:50,710 --> 00:35:55,750
are really just variables called
"name" and called "house" inside

733
00:35:55,750 --> 00:36:00,130
of an object whose type is student.

734
00:36:00,130 --> 00:36:02,590
All right, so what more can
we do with these classes?

735
00:36:02,590 --> 00:36:06,190
Well, again, on line 11 is
where we're instantiating

736
00:36:06,190 --> 00:36:11,020
an object of the student class and
assigning it to a student variable.

737
00:36:11,020 --> 00:36:12,400
We're then adding attributes--

738
00:36:12,400 --> 00:36:16,000
"Name" and "House," respectively--
on lines 12 and 13 currently.

739
00:36:16,000 --> 00:36:17,950
Both of those have values
that are technically

740
00:36:17,950 --> 00:36:21,220
strings or strs, because that's what
the return value of the input is.

741
00:36:21,220 --> 00:36:23,980
But those attributes values
could actually be any data type.

742
00:36:23,980 --> 00:36:26,980
We're just keeping things simple
and focusing on defining students

743
00:36:26,980 --> 00:36:28,330
in terms of two strings--

744
00:36:28,330 --> 00:36:29,380
"Name" and "House."

745
00:36:29,380 --> 00:36:32,140
And then, on line 14, we're
returning that variable.

746
00:36:32,140 --> 00:36:35,320
We're returning that object to
main so that we can actually

747
00:36:35,320 --> 00:36:37,710
print out who is from what house.

748
00:36:37,710 --> 00:36:40,960
Well, let's go ahead and add a bit more
functionality here because, right now,

749
00:36:40,960 --> 00:36:44,170
on lines 12 and 13,
this is a little manual.

750
00:36:44,170 --> 00:36:47,350
And it's a little reckless of
me to just be putting anything

751
00:36:47,350 --> 00:36:50,320
I want inside of this student object.

752
00:36:50,320 --> 00:36:53,030
It turns out with classes,
unlike with dictionaries,

753
00:36:53,030 --> 00:36:57,640
we can actually standardize, all the
more, what those attributes can be

754
00:36:57,640 --> 00:37:00,310
and what kinds of values
you can set them to.

755
00:37:00,310 --> 00:37:02,390
So let me go ahead and do this.

756
00:37:02,390 --> 00:37:04,360
Let me propose that it
would actually be really

757
00:37:04,360 --> 00:37:08,860
nice if, instead of doing
this here, let me go ahead

758
00:37:08,860 --> 00:37:10,820
and simplify my code as follows.

759
00:37:10,820 --> 00:37:13,720
Let me go ahead and give myself
a local variable called name

760
00:37:13,720 --> 00:37:17,200
and set it equal to the return value of
input, like we've done many times now

761
00:37:17,200 --> 00:37:17,800
already.

762
00:37:17,800 --> 00:37:20,320
Let me give myself one other
variable for now, called house,

763
00:37:20,320 --> 00:37:23,350
and set it equal to the
return value of input

764
00:37:23,350 --> 00:37:25,300
as well, prompting the
user for their house.

765
00:37:25,300 --> 00:37:30,400
And now, instead of creating a
student object from my student class

766
00:37:30,400 --> 00:37:34,520
and then manually putting the
name attribute inside of it

767
00:37:34,520 --> 00:37:37,150
and the house attribute
inside of it, let

768
00:37:37,150 --> 00:37:39,470
me actually do something more powerful.

769
00:37:39,470 --> 00:37:40,600
Let me do this.

770
00:37:40,600 --> 00:37:45,340
Let me call that Student function,
which is identical to the class name--

771
00:37:45,340 --> 00:37:48,130
just by defining a
class, you get a function

772
00:37:48,130 --> 00:37:52,600
whose name is identical to the class
name, with the capital letter included.

773
00:37:52,600 --> 00:37:54,610
But instead of just
doing open parenthesis,

774
00:37:54,610 --> 00:37:58,160
closed parenthesis, let
me pass in the name that I

775
00:37:58,160 --> 00:38:02,810
want to fill this object with and the
house that I want to put in that object

776
00:38:02,810 --> 00:38:03,360
as well.

777
00:38:03,360 --> 00:38:09,360
And now let me set the return value as
before to be student equals like this.

778
00:38:09,360 --> 00:38:11,080
So what have I done that's different?

779
00:38:11,080 --> 00:38:13,580
Fundamentally, I'm still getting
user input in the same way.

780
00:38:13,580 --> 00:38:16,760
I'm using input on line
11 and input on line 12.

781
00:38:16,760 --> 00:38:21,110
And I just so happen to be storing
those return values in local variables.

782
00:38:21,110 --> 00:38:24,860
And now we're setting the stage for
the more powerful features of classes

783
00:38:24,860 --> 00:38:27,200
and object-oriented
programming more generally.

784
00:38:27,200 --> 00:38:31,490
Notice that I'm deliberately
passing to this capital S Student

785
00:38:31,490 --> 00:38:33,860
function, name, house--

786
00:38:33,860 --> 00:38:36,300
I'm passing in arguments
to the function.

787
00:38:36,300 --> 00:38:39,740
Now, the student class is not going
to know what to do with those yet,

788
00:38:39,740 --> 00:38:44,780
but now I'm standardizing how I'm
passing data into this student class.

789
00:38:44,780 --> 00:38:47,840
And ultimately, it's going to
give me an opportunity to error

790
00:38:47,840 --> 00:38:51,172
check those inputs, to make sure that
the name is valid, that it has a value

791
00:38:51,172 --> 00:38:52,880
and it's not just the
user hitting Enter.

792
00:38:52,880 --> 00:38:56,060
It's going to allow me to ensure
that it's a valid house, that it's

793
00:38:56,060 --> 00:38:59,210
Gryffindor or Hufflepuff
or Ravenclaw or Slytherin

794
00:38:59,210 --> 00:39:02,900
or not just hitting Enter or some
random value that the user types in.

795
00:39:02,900 --> 00:39:05,900
Because I'm passing "Name"
and "House" to the student

796
00:39:05,900 --> 00:39:08,810
class, this particular
function, I'm going

797
00:39:08,810 --> 00:39:11,430
to have more control over
the correctness of my data.

798
00:39:11,430 --> 00:39:14,540
So let's now go up to the student
class, which, up until now,

799
00:39:14,540 --> 00:39:16,130
I left as just dot, dot, dot.

800
00:39:16,130 --> 00:39:19,610
It turns out that, in
the context of classes,

801
00:39:19,610 --> 00:39:23,900
there are a number of not
just attributes or instance

802
00:39:23,900 --> 00:39:27,050
variables that you can put
inside, but also methods.

803
00:39:27,050 --> 00:39:32,090
Classes come with certain methods,
or functions inside of them,

804
00:39:32,090 --> 00:39:35,690
that you can define, and they
just behave in a special way,

805
00:39:35,690 --> 00:39:37,880
by nature of how Python works.

806
00:39:37,880 --> 00:39:42,620
These functions allow you to
determine behavior in a standard way.

807
00:39:42,620 --> 00:39:45,080
They are special methods in that sense.

808
00:39:45,080 --> 00:39:46,350
Now, what do I mean by this.

809
00:39:46,350 --> 00:39:48,080
Well, let me go back to VS Code here.

810
00:39:48,080 --> 00:39:53,000
And let me propose that I start
to define a standard function

811
00:39:53,000 --> 00:39:56,900
called underscore underscore,
or Dunder, as it's

812
00:39:56,900 --> 00:39:59,930
abbreviated, init,
underscore underscore,

813
00:39:59,930 --> 00:40:02,930
and then I'm going to go
ahead and do open parentheses,

814
00:40:02,930 --> 00:40:06,860
and then I'm going to put in
here, literally, the word self.

815
00:40:06,860 --> 00:40:08,400
More on that in just a moment.

816
00:40:08,400 --> 00:40:11,810
But now, inside of this function,
I'm going to have an opportunity

817
00:40:11,810 --> 00:40:16,790
to customize this class's objects.

818
00:40:16,790 --> 00:40:20,330
That is to say this underscore,
underscore init method,

819
00:40:20,330 --> 00:40:25,190
or Dunder init method is specifically
known as an instance method,

820
00:40:25,190 --> 00:40:26,690
and it's called exactly this.

821
00:40:26,690 --> 00:40:28,880
This is designed by
the authors of Python.

822
00:40:28,880 --> 00:40:34,310
And if you want to initialize the
contents of an object from a class,

823
00:40:34,310 --> 00:40:37,880
you define this method, and we'll
see what it's about to do here.

824
00:40:37,880 --> 00:40:41,240
Let me go back to VS Code, and
let me do something like this.

825
00:40:41,240 --> 00:40:47,750
self.name = name, and
self.house = house.

826
00:40:47,750 --> 00:40:51,230
But I don't want to just init
this object very generically.

827
00:40:51,230 --> 00:40:56,180
I want this method, called init,
to take in not just self but name,

828
00:40:56,180 --> 00:40:58,380
house as well.

829
00:40:58,380 --> 00:40:59,908
Now, what in the world is going on?

830
00:40:59,908 --> 00:41:01,700
Because there's a lot
of weird syntax here.

831
00:41:01,700 --> 00:41:03,380
There's this Dunder init method--

832
00:41:03,380 --> 00:41:05,810
double underscore,
init, double underscore.

833
00:41:05,810 --> 00:41:08,750
There's, all of a sudden,
this parameter called self.

834
00:41:08,750 --> 00:41:12,470
And then there's this new
syntax-- self.name and self.house.

835
00:41:12,470 --> 00:41:16,552
Now you're seeing really a manifestation
of object-oriented programming.

836
00:41:16,552 --> 00:41:18,260
It's not all that
different fundamentally

837
00:41:18,260 --> 00:41:20,552
from what we've been doing
for weeks with dictionaries,

838
00:41:20,552 --> 00:41:23,120
by adding keys to dictionaries.

839
00:41:23,120 --> 00:41:28,340
But in this case, we're adding
variables to objects, a.k.a.

840
00:41:28,340 --> 00:41:30,480
instance variables to objects.

841
00:41:30,480 --> 00:41:31,470
Now, what's going on?

842
00:41:31,470 --> 00:41:32,550
Let's do this in reverse.

843
00:41:32,550 --> 00:41:34,730
Let's go back to the line
of code we wrote earlier.

844
00:41:34,730 --> 00:41:38,720
On line 15, I am treating
the name of this class--

845
00:41:38,720 --> 00:41:41,930
Student with a capital
S-- as a function.

846
00:41:41,930 --> 00:41:44,600
And I am passing in two values--

847
00:41:44,600 --> 00:41:45,920
"Name" and "House."

848
00:41:45,920 --> 00:41:48,710
What I've highlighted here
on the screen, on line 15,

849
00:41:48,710 --> 00:41:51,260
is generally known as
a constructor call.

850
00:41:51,260 --> 00:41:56,870
This is a line of code that is going
to construct a student object for me.

851
00:41:56,870 --> 00:42:02,810
Using synonyms, it is going to
instantiate a student object for me.

852
00:42:02,810 --> 00:42:05,600
And again, how is it going
to create that object?

853
00:42:05,600 --> 00:42:09,440
It's going to use the student class
as a template, as a mold of sorts

854
00:42:09,440 --> 00:42:12,290
so that every student
is structured the same.

855
00:42:12,290 --> 00:42:13,880
Every student is going to have a name.

856
00:42:13,880 --> 00:42:15,463
Every student's going to have a house.

857
00:42:15,463 --> 00:42:20,900
But because I can pass in arguments
to this Student function, capital S,

858
00:42:20,900 --> 00:42:26,670
I'm going to be able to customize
the contents of that object.

859
00:42:26,670 --> 00:42:29,660
So if you think about the real world--
if you've ever been on a street

860
00:42:29,660 --> 00:42:34,675
or a neighborhood where all of the
houses look the same but they might be

861
00:42:34,675 --> 00:42:37,550
painted differently; they might be
decorated a little bit differently

862
00:42:37,550 --> 00:42:40,940
on the outside, all of those houses
might have been built using the exact

863
00:42:40,940 --> 00:42:42,560
same blueprint--

864
00:42:42,560 --> 00:42:43,890
a mold, if you will.

865
00:42:43,890 --> 00:42:48,073
But then you can specialize exactly
the finer points of those houses.

866
00:42:48,073 --> 00:42:50,990
By painting the outside a different
color or planting different trees,

867
00:42:50,990 --> 00:42:52,520
you can style them differently.

868
00:42:52,520 --> 00:42:57,750
Similar in spirit here, we
have a Student blueprint

869
00:42:57,750 --> 00:43:01,590
that's always going to have now a name
and a house, but it's up to you and me

870
00:43:01,590 --> 00:43:04,180
to pass in any name and
any house that we want.

871
00:43:04,180 --> 00:43:06,040
Now, where is this function?

872
00:43:06,040 --> 00:43:09,120
The fact that I'm calling Student,
capital, S and then a parenthesis

873
00:43:09,120 --> 00:43:11,252
and a closed parenthesis
with arguments inside

874
00:43:11,252 --> 00:43:12,960
suggest that there's
a function somewhere

875
00:43:12,960 --> 00:43:17,490
in the world that has been defined,
with def, that's going to be called.

876
00:43:17,490 --> 00:43:20,430
Well, as you might have
guessed by now, the function

877
00:43:20,430 --> 00:43:25,500
that will always be called, by
definition of how Python classes work,

878
00:43:25,500 --> 00:43:29,980
is a function called double
underscore, init, double underscore.

879
00:43:29,980 --> 00:43:30,480
Why?

880
00:43:30,480 --> 00:43:33,330
It's a crazy name, but it's
what the authors of Python

881
00:43:33,330 --> 00:43:38,760
chose to just implement the
initialization of an object in Python.

882
00:43:38,760 --> 00:43:40,900
Now, the only weird thing--

883
00:43:40,900 --> 00:43:43,140
especially weird thing,
I will admit, is this.

884
00:43:43,140 --> 00:43:49,110
It would be way clearer, to me, too, if
the only two parameters for init we're

885
00:43:49,110 --> 00:43:50,670
just name, house.

886
00:43:50,670 --> 00:43:53,550
That's how we've defined every
function thus far in the class.

887
00:43:53,550 --> 00:43:57,300
You just specify the parameters that
you want the function to accept.

888
00:43:57,300 --> 00:44:00,330
And that lines up with
what I'm doing on line 15.

889
00:44:00,330 --> 00:44:04,530
I am only passing in two
things to the student function.

890
00:44:04,530 --> 00:44:07,832
But it turns out that
the authors of Python

891
00:44:07,832 --> 00:44:09,540
need to give us a
little bit of help here

892
00:44:09,540 --> 00:44:14,460
because suppose that you pass in
"Name" and "House" to this init method.

893
00:44:14,460 --> 00:44:17,820
And a method is just a
function inside of a class.

894
00:44:17,820 --> 00:44:20,310
What are you going to do
with the name and the house?

895
00:44:20,310 --> 00:44:22,350
Literally, where are
you going to put them?

896
00:44:22,350 --> 00:44:26,520
If you want to remember the name
and the house for this student,

897
00:44:26,520 --> 00:44:29,170
you've got to be able to
store those values somewhere.

898
00:44:29,170 --> 00:44:32,430
And how do you store them
in the current object

899
00:44:32,430 --> 00:44:34,830
that has just been "instantiated?"

900
00:44:34,830 --> 00:44:37,620
Well, the authors of Python
decided that the convention

901
00:44:37,620 --> 00:44:41,940
is going to be that this init
method also, semi secretly, takes

902
00:44:41,940 --> 00:44:44,640
a third argument, that
has to come first.

903
00:44:44,640 --> 00:44:46,650
By convention, it's
called self, but you could

904
00:44:46,650 --> 00:44:48,233
call it technically anything you want.

905
00:44:48,233 --> 00:44:50,190
But the convention is
to always call it self.

906
00:44:50,190 --> 00:44:53,520
And self, as its name
implies, gives you access

907
00:44:53,520 --> 00:44:56,790
to the current object
that was just created.

908
00:44:56,790 --> 00:44:58,020
What does that mean?

909
00:44:58,020 --> 00:45:02,160
Again, now, on line 14, now that
it's moved down a little bit,

910
00:45:02,160 --> 00:45:04,080
this line here is a constructor.

911
00:45:04,080 --> 00:45:06,180
It constructs a student object.

912
00:45:06,180 --> 00:45:08,280
But there's nothing in
that object initially.

913
00:45:08,280 --> 00:45:09,750
There's no name; there's no house.

914
00:45:09,750 --> 00:45:12,780
But the object exists in
the computer's memory.

915
00:45:12,780 --> 00:45:16,560
It's up to, now, you to store the name
and the house inside of that object.

916
00:45:16,560 --> 00:45:17,500
How do you do that?

917
00:45:17,500 --> 00:45:21,480
Well, Python will just automatically
call this init method for you,

918
00:45:21,480 --> 00:45:27,480
and it's going to automatically pass
in a reference to an argument that

919
00:45:27,480 --> 00:45:32,370
represents the current object that it
just constructed in memory for you,

920
00:45:32,370 --> 00:45:34,710
and it's up to you to
populate it with values.

921
00:45:34,710 --> 00:45:37,680
And what this means is that,
inside of your init method,

922
00:45:37,680 --> 00:45:42,870
you can literally do self.name
to create a new attribute, a.k.a.

923
00:45:42,870 --> 00:45:46,170
an instance variable, inside
of that otherwise empty

924
00:45:46,170 --> 00:45:48,420
object and put this name inside of it.

925
00:45:48,420 --> 00:45:51,875
It allows you to do self.house
and store that value of house.

926
00:45:51,875 --> 00:45:54,000
Now, you could call these
things anything you want.

927
00:45:54,000 --> 00:45:54,750
They could be n.

928
00:45:54,750 --> 00:45:56,400
They could be h, as before.

929
00:45:56,400 --> 00:46:00,270
But that's really not
very self-explanatory.

930
00:46:00,270 --> 00:46:04,260
Much better to do this kind of
convention. self.name equals name.

931
00:46:04,260 --> 00:46:06,330
self.house equals house.

932
00:46:06,330 --> 00:46:11,700
And this is like installing into the
otherwise empty object the value name

933
00:46:11,700 --> 00:46:16,080
and house and storing them in,
really, identically named instance

934
00:46:16,080 --> 00:46:17,710
variables in the object.

935
00:46:17,710 --> 00:46:20,820
And again, an object is
just an instance of a class.

936
00:46:20,820 --> 00:46:23,190
Now, I know that was
a lot of vocabulary.

937
00:46:23,190 --> 00:46:24,880
That's a lot of weird syntax.

938
00:46:24,880 --> 00:46:28,620
So any questions on this init
method, whose purpose in life,

939
00:46:28,620 --> 00:46:33,545
again, is to initialize an otherwise
empty object when you first create it?

940
00:46:33,545 --> 00:46:36,810
AUDIENCE: So what is the difference
between the init method and default

941
00:46:36,810 --> 00:46:37,497
constructor?

942
00:46:37,497 --> 00:46:38,830
DAVID J. MALAN: A good question.

943
00:46:38,830 --> 00:46:41,580
So in other languages--
if you programmed before.

944
00:46:41,580 --> 00:46:45,180
For instance, Java-- there are
functions that are explicitly called

945
00:46:45,180 --> 00:46:47,910
constructors that construct an object.

946
00:46:47,910 --> 00:46:49,410
They initialize it with values.

947
00:46:49,410 --> 00:46:53,310
Python technically calls this init
method the initialization method.

948
00:46:53,310 --> 00:46:54,960
It initializes the value.

949
00:46:54,960 --> 00:47:00,870
It's on line 15 now of my code, if I
scroll back down, that I'm technically

950
00:47:00,870 --> 00:47:02,430
constructing the object.

951
00:47:02,430 --> 00:47:05,340
It turns out there's another
special method in Python,

952
00:47:05,340 --> 00:47:07,290
that we won't talk
about in detail today,

953
00:47:07,290 --> 00:47:11,130
called underscore underscore,
new, underscore underscore

954
00:47:11,130 --> 00:47:13,380
that actually handles
the process of creating

955
00:47:13,380 --> 00:47:15,450
an empty object in memory for us.

956
00:47:15,450 --> 00:47:17,830
But, generally speaking,
you, the programmer,

957
00:47:17,830 --> 00:47:19,930
don't need to manipulate
the new function.

958
00:47:19,930 --> 00:47:20,910
It just works for you.

959
00:47:20,910 --> 00:47:23,760
Instead, you define your
own init method here

960
00:47:23,760 --> 00:47:27,060
and init function inside of
your class, and that method

961
00:47:27,060 --> 00:47:29,927
initializes the contents of the object.

962
00:47:29,927 --> 00:47:32,760
So there's technically a distinction
between constructing the object

963
00:47:32,760 --> 00:47:35,260
with new and initializing it with init.

964
00:47:35,260 --> 00:47:39,270
But in the world of Python, you pretty
much only worry about the init method.

965
00:47:39,270 --> 00:47:42,270
Python generally does
the other part for you.

966
00:47:42,270 --> 00:47:43,020
A good question.

967
00:47:43,020 --> 00:47:44,325
Others?

968
00:47:44,325 --> 00:47:48,150
AUDIENCE: What about if you want
to store more than one name or more

969
00:47:48,150 --> 00:47:49,080
than one house?

970
00:47:49,080 --> 00:47:49,770
DAVID J. MALAN: A good question.

971
00:47:49,770 --> 00:47:52,680
If you want to store more than
one name or more than one house,

972
00:47:52,680 --> 00:47:54,100
you can do this in different ways.

973
00:47:54,100 --> 00:47:57,930
You could create other attributes--
technically called instance variables--

974
00:47:57,930 --> 00:48:01,710
like self.name1, self.name2.

975
00:48:01,710 --> 00:48:03,720
But we've seen, in the
past, that that is not

976
00:48:03,720 --> 00:48:06,300
a very good design, just to
have multiple variables to store

977
00:48:06,300 --> 00:48:07,260
multiple things.

978
00:48:07,260 --> 00:48:12,630
Maybe, instead, you have an instance
variable called self.names, plural,

979
00:48:12,630 --> 00:48:15,978
and you set it equal to a list
of names or a list of houses.

980
00:48:15,978 --> 00:48:19,020
Now, in this case, I don't think that
really solves a problem because I'm

981
00:48:19,020 --> 00:48:22,950
trying to implement a student, singular,
so it doesn't really make sense

982
00:48:22,950 --> 00:48:24,240
to have multiple first names.

983
00:48:24,240 --> 00:48:27,150
Maybe a nickname, maybe a last
name, so we could add those, too.

984
00:48:27,150 --> 00:48:29,370
But I don't think we need
multiple names per se

985
00:48:29,370 --> 00:48:31,320
and, in this case, multiple houses.

986
00:48:31,320 --> 00:48:34,500
But absolutely, you could do that using
some of our familiar building blocks

987
00:48:34,500 --> 00:48:35,910
like lists.

988
00:48:35,910 --> 00:48:37,530
Other questions?

989
00:48:37,530 --> 00:48:40,300
AUDIENCE: How are classes or
objects represented in memory?

990
00:48:40,300 --> 00:48:43,050
DAVID J. MALAN: How are classes
and objects represented in memory?

991
00:48:43,050 --> 00:48:44,940
So the class is technically just code.

992
00:48:44,940 --> 00:48:48,330
It is the code on the top of my
file-- lines 1 through fou4--

993
00:48:48,330 --> 00:48:52,260
that defines that blueprint,
that template, if you will.

994
00:48:52,260 --> 00:48:54,840
Objects are stored in
the computer's memory

995
00:48:54,840 --> 00:48:56,350
by taking up some number of bytes.

996
00:48:56,350 --> 00:48:59,130
So you're probably familiar with
bytes or kilobytes or megabytes.

997
00:48:59,130 --> 00:49:01,770
There's some chunk of
bytes, probably all

998
00:49:01,770 --> 00:49:03,720
in the same location in
the computer's memory

999
00:49:03,720 --> 00:49:07,920
or RAM, where those objects are stored.

1000
00:49:07,920 --> 00:49:11,490
But that's what Python, the
program, handles for you.

1001
00:49:11,490 --> 00:49:14,940
Python the interpreter figures out where
in the computer's memory to put it.

1002
00:49:14,940 --> 00:49:18,030
You and I, the programmers, get to
think and solve problems at this level.

1003
00:49:18,030 --> 00:49:21,930
Python, the interpreter, handles
those lower level details for you.

1004
00:49:21,930 --> 00:49:25,170
How about one final question
on classes and objects?

1005
00:49:25,170 --> 00:49:28,110
AUDIENCE: So my question
is if we can the same do

1006
00:49:28,110 --> 00:49:31,630
the same thing with the
dictionaries, so why to use classes?

1007
00:49:31,630 --> 00:49:32,880
DAVID J. MALAN: Good question.

1008
00:49:32,880 --> 00:49:34,770
If you can do the same things
as you can with dictionaries,

1009
00:49:34,770 --> 00:49:35,970
why should you use classes?

1010
00:49:35,970 --> 00:49:38,400
Because we are just scratching
the surface now of what

1011
00:49:38,400 --> 00:49:39,840
you can do with classes.

1012
00:49:39,840 --> 00:49:42,660
Allow me to go back, now,
to my keyboard and show you

1013
00:49:42,660 --> 00:49:44,370
more of what you can do with classes.

1014
00:49:44,370 --> 00:49:47,760
But in short, you can do
much more with classes.

1015
00:49:47,760 --> 00:49:51,810
You can ensure the correctness of
your data much more with classes.

1016
00:49:51,810 --> 00:49:53,160
You can error-check things.

1017
00:49:53,160 --> 00:49:57,390
And generally, you can design more
complicated software more effectively.

1018
00:49:57,390 --> 00:49:59,460
And we'll continue to
see, today, features

1019
00:49:59,460 --> 00:50:02,400
of Python and object-oriented
programming more generally

1020
00:50:02,400 --> 00:50:04,870
that allows us to do just that.

1021
00:50:04,870 --> 00:50:09,330
So let me propose, in fact, that first,
let's just tighten up this current

1022
00:50:09,330 --> 00:50:13,920
implementation, which again has us with
an init method that just declares two

1023
00:50:13,920 --> 00:50:16,890
instance variables-- self.name and
self.house, house, which, again,

1024
00:50:16,890 --> 00:50:21,420
just creates those variables inside of
the otherwise empty object and assigns

1025
00:50:21,420 --> 00:50:22,110
them values--

1026
00:50:22,110 --> 00:50:23,700
name and house, respectively.

1027
00:50:23,700 --> 00:50:25,980
Let me go ahead and just
do one little thing here.

1028
00:50:25,980 --> 00:50:27,780
I don't really need
this student variable.

1029
00:50:27,780 --> 00:50:31,740
Let me just tighten this up so that
each time we improve or change the code,

1030
00:50:31,740 --> 00:50:34,980
we're focusing, really, on
just the minimal changes alone.

1031
00:50:34,980 --> 00:50:37,258
So I've not fundamentally
done anything different.

1032
00:50:37,258 --> 00:50:39,300
I just got rid of the
variable name, and I'm just

1033
00:50:39,300 --> 00:50:43,110
returning the return value
of this student function

1034
00:50:43,110 --> 00:50:45,120
that's constructing
my new object for me.

1035
00:50:45,120 --> 00:50:48,840
So I'm just tightening things up as
we've done many times in the past.

1036
00:50:48,840 --> 00:50:53,310
Well, what if something goes
wrong in creating this student?

1037
00:50:53,310 --> 00:50:56,790
For instance, what if the user does
not give us a name, and they just hit

1038
00:50:56,790 --> 00:50:58,800
Enter when prompted for name.

1039
00:50:58,800 --> 00:51:01,230
I don't want to put in
my computer's memory

1040
00:51:01,230 --> 00:51:04,380
a bogus student object that has no name.

1041
00:51:04,380 --> 00:51:07,830
I'd ideally like to check for
errors before I even create it

1042
00:51:07,830 --> 00:51:09,570
so I don't create a nameless student.

1043
00:51:09,570 --> 00:51:13,780
It would just be weird and probably a
bug to have an object that has no name.

1044
00:51:13,780 --> 00:51:16,200
Similarly, I don't want
the user to be able to type

1045
00:51:16,200 --> 00:51:18,720
in something random as their house.

1046
00:51:18,720 --> 00:51:21,360
At least in the world of
Harry Potter, there's really

1047
00:51:21,360 --> 00:51:23,790
only four houses, at Hogwarts at least.

1048
00:51:23,790 --> 00:51:25,680
There's, again,
Gryffindor and Hufflepuff

1049
00:51:25,680 --> 00:51:29,610
and Ravenclaw and Slytherin--
a list of four valid houses.

1050
00:51:29,610 --> 00:51:34,290
It would be nice if I somehow validated
that the user's input is indeed

1051
00:51:34,290 --> 00:51:35,550
in that list.

1052
00:51:35,550 --> 00:51:39,930
Now, I could do all of that
validation in my get_student function.

1053
00:51:39,930 --> 00:51:41,730
I could check, is the name empty?

1054
00:51:41,730 --> 00:51:44,430
If so, don't create the student object.

1055
00:51:44,430 --> 00:51:46,680
Is the house one of those four houses?

1056
00:51:46,680 --> 00:51:49,080
If not, don't create the student object.

1057
00:51:49,080 --> 00:51:52,740
But that would be rather
decoupled from the student itself.

1058
00:51:52,740 --> 00:51:57,630
get_student currently exists as just
my own function in my student.py file.

1059
00:51:57,630 --> 00:52:01,110
But classes-- and really,
object-oriented programming-- more

1060
00:52:01,110 --> 00:52:05,280
generally encourages you
to encapsulate, inside

1061
00:52:05,280 --> 00:52:09,730
of a class, all functionality
related to that class.

1062
00:52:09,730 --> 00:52:12,360
So if you want to validate
that a name exists--

1063
00:52:12,360 --> 00:52:14,760
if you want to validate
that a house is correct,

1064
00:52:14,760 --> 00:52:20,040
that belongs just fundamentally in
the class called student itself,

1065
00:52:20,040 --> 00:52:22,590
not in some random function
that you wrote elsewhere.

1066
00:52:22,590 --> 00:52:24,870
Again, this is just
methodology because, again,

1067
00:52:24,870 --> 00:52:28,560
if we think about writing code that
gets longer and longer, more and more

1068
00:52:28,560 --> 00:52:31,260
complicated, it should make
just intuitive sense that,

1069
00:52:31,260 --> 00:52:34,230
if you keep all the house--

1070
00:52:34,230 --> 00:52:37,200
all of the name and all of the
house-related code in the student,

1071
00:52:37,200 --> 00:52:38,700
it's just better organization.

1072
00:52:38,700 --> 00:52:41,568
Keep all of the related code
together, and that's probably

1073
00:52:41,568 --> 00:52:43,110
going to set you up for more success.

1074
00:52:43,110 --> 00:52:45,150
And indeed, that's part
of this methodology

1075
00:52:45,150 --> 00:52:47,130
of object-oriented programming.

1076
00:52:47,130 --> 00:52:51,930
Let me go ahead now and
change my students classes

1077
00:52:51,930 --> 00:52:53,880
init method to do this.

1078
00:52:53,880 --> 00:52:56,360
If the name is blank--

1079
00:52:56,360 --> 00:52:59,350
so if not name-- and we've seen
this kind of syntax before.

1080
00:52:59,350 --> 00:53:02,680
If you say in Python,
Pythonically, if not name,

1081
00:53:02,680 --> 00:53:04,480
that's doing something like this.

1082
00:53:04,480 --> 00:53:07,290
If name equals, equals, quote, unquote--

1083
00:53:07,290 --> 00:53:09,040
but I can do this a
little more elegantly.

1084
00:53:09,040 --> 00:53:11,950
Just say, if not name,
would be the more Pythonic.

1085
00:53:11,950 --> 00:53:15,575
Well, I want to return an error.

1086
00:53:15,575 --> 00:53:17,200
I might want to do something like this.

1087
00:53:17,200 --> 00:53:18,910
Print missing name.

1088
00:53:18,910 --> 00:53:20,530
But this is not good enough.

1089
00:53:20,530 --> 00:53:23,980
It does not suffice to
just print out missing name

1090
00:53:23,980 --> 00:53:26,080
and then let the rest
of the code go through.

1091
00:53:26,080 --> 00:53:27,788
All right, well, what
could I do instead?

1092
00:53:27,788 --> 00:53:30,788
In the past, we've seen another
technique I could do sys.exit,

1093
00:53:30,788 --> 00:53:33,580
and I could say something like
missing name, and I could go up here

1094
00:53:33,580 --> 00:53:34,750
and I could import sys.

1095
00:53:34,750 --> 00:53:37,960
But this is a really obnoxious
solution to the problem.

1096
00:53:37,960 --> 00:53:41,230
Just because you or maybe
a colleague messed up

1097
00:53:41,230 --> 00:53:43,750
and called a function
with an invalid name,

1098
00:53:43,750 --> 00:53:45,670
you're going to quit my whole program?

1099
00:53:45,670 --> 00:53:49,745
That's really, really
extreme of a response,

1100
00:53:49,745 --> 00:53:52,120
and you probably don't want
to do that if your program is

1101
00:53:52,120 --> 00:53:53,050
in the middle of running.

1102
00:53:53,050 --> 00:53:54,633
You might want to clean some stuff up.

1103
00:53:54,633 --> 00:53:57,940
You might want to save files you don't
want to just exit a program sometimes

1104
00:53:57,940 --> 00:54:01,190
in some arbitrary line, just
because input was invalid.

1105
00:54:01,190 --> 00:54:03,350
So I don't think we
want to do that either.

1106
00:54:03,350 --> 00:54:07,360
But we do, now, have a
mechanism for signaling errors.

1107
00:54:07,360 --> 00:54:09,500
Unfortunately, I can't
do something like this.

1108
00:54:09,500 --> 00:54:13,630
I could try returning none and say,
uh-uh, this student does not exist.

1109
00:54:13,630 --> 00:54:15,670
I'm going to hand you back none instead.

1110
00:54:15,670 --> 00:54:16,930
But it's too late.

1111
00:54:16,930 --> 00:54:21,400
If we scroll back down to where I'm
creating the student, it's on line 17

1112
00:54:21,400 --> 00:54:23,080
now where I've highlighted this code.

1113
00:54:23,080 --> 00:54:25,540
The student has already been created.

1114
00:54:25,540 --> 00:54:28,750
There is an object somewhere
in the computer's memory

1115
00:54:28,750 --> 00:54:30,370
that's structured as a student.

1116
00:54:30,370 --> 00:54:32,710
It just doesn't have
any values inside of it.

1117
00:54:32,710 --> 00:54:35,560
But it's too late,
therefore, to return none.

1118
00:54:35,560 --> 00:54:36,670
That ship has sailed.

1119
00:54:36,670 --> 00:54:37,950
The object exists.

1120
00:54:37,950 --> 00:54:40,450
You can't just suddenly say,
nope, nope, there is no object.

1121
00:54:40,450 --> 00:54:41,620
There is an object.

1122
00:54:41,620 --> 00:54:43,600
It's up to you to signal an error.

1123
00:54:43,600 --> 00:54:45,350
And how do you signal an error?

1124
00:54:45,350 --> 00:54:48,100
Well, we've actually seen this
before, but we haven't had occasion

1125
00:54:48,100 --> 00:54:49,600
to create our own errors.

1126
00:54:49,600 --> 00:54:54,760
It turns out, in Python, there's
another keyword related to exceptions

1127
00:54:54,760 --> 00:54:58,570
that Python itself uses to raise
all of those exceptions we've

1128
00:54:58,570 --> 00:54:59,770
talked about in the past.

1129
00:54:59,770 --> 00:55:04,480
When you've caught things like value
errors or other such exceptions that

1130
00:55:04,480 --> 00:55:09,070
come with Python, well, it turns
out you, the programmer can raise--

1131
00:55:09,070 --> 00:55:12,890
that is create your own exceptions
when something just really goes wrong--

1132
00:55:12,890 --> 00:55:15,760
not wrong enough that you want to
quit and exit the whole program,

1133
00:55:15,760 --> 00:55:18,970
but enough that you need to
somehow alert the programmer

1134
00:55:18,970 --> 00:55:20,590
that there has been an error.

1135
00:55:20,590 --> 00:55:23,590
Something exceptional, in
a very bad way-- something

1136
00:55:23,590 --> 00:55:29,270
exceptional has happened, and let them
try to catch that exception as needed.

1137
00:55:29,270 --> 00:55:32,260
So let me go back to VS
Code here and propose

1138
00:55:32,260 --> 00:55:36,490
that, if the user passes in an
invalid name-- it's just empty,

1139
00:55:36,490 --> 00:55:37,840
so there's not a name.

1140
00:55:37,840 --> 00:55:39,860
Well, what I really want to do is this.

1141
00:55:39,860 --> 00:55:43,060
I want to raise a value error.

1142
00:55:43,060 --> 00:55:45,190
And we've seen the value errors before.

1143
00:55:45,190 --> 00:55:47,830
We've created value errors
accidentally before.

1144
00:55:47,830 --> 00:55:51,430
And generally, you and I have
tried to catch them if they happen.

1145
00:55:51,430 --> 00:55:55,390
Well, the flip side of this feature of
exceptions in a language like Python

1146
00:55:55,390 --> 00:55:58,120
is that you, the programmer,
can also raise exceptions

1147
00:55:58,120 --> 00:56:00,010
when something exceptional happens.

1148
00:56:00,010 --> 00:56:01,810
And you can even be more precise.

1149
00:56:01,810 --> 00:56:05,260
You don't have to raise a generic value
error and let the programmer figure out

1150
00:56:05,260 --> 00:56:06,100
what went wrong.

1151
00:56:06,100 --> 00:56:10,300
You can treat value error and all
exceptions in Python like functions

1152
00:56:10,300 --> 00:56:14,590
and actually pass to them an explanatory
message like, quote, unquote,

1153
00:56:14,590 --> 00:56:17,890
"Missing name," so that at least
the programmer, when they encounter

1154
00:56:17,890 --> 00:56:19,450
this error, knows, oh, I messed up.

1155
00:56:19,450 --> 00:56:22,840
I didn't make sure that
the user has a name.

1156
00:56:22,840 --> 00:56:25,130
And now, what do you want to do instead?

1157
00:56:25,130 --> 00:56:28,720
Well, now, if you're the programmer,
you could do something like this.

1158
00:56:28,720 --> 00:56:34,690
You could try to create a student
except if there's a value error.

1159
00:56:34,690 --> 00:56:37,210
Then you could handle it in some way.

1160
00:56:37,210 --> 00:56:39,490
And I'm going to wave my
hand with a dot, dot, dot,

1161
00:56:39,490 --> 00:56:40,790
at how you would handle it.

1162
00:56:40,790 --> 00:56:44,650
But you would handle it using try and
accept, just like we have in the past,

1163
00:56:44,650 --> 00:56:46,660
and that would allow
you, the programmer,

1164
00:56:46,660 --> 00:56:48,170
to try to create the student.

1165
00:56:48,170 --> 00:56:52,300
But if something goes wrong,
OK, I'll handle it nonetheless.

1166
00:56:52,300 --> 00:56:54,970
So what's new here, again,
is this raise keyword,

1167
00:56:54,970 --> 00:56:59,230
that just lets you and I
actually raise our own exceptions

1168
00:56:59,230 --> 00:57:00,460
to signal these errors.

1169
00:57:00,460 --> 00:57:03,010
Well, let me go back to
my code here, and I'm just

1170
00:57:03,010 --> 00:57:06,190
going to go ahead and not bother
trying or catching this error.

1171
00:57:06,190 --> 00:57:09,100
For now, we'll just focus
on raising it and assume

1172
00:57:09,100 --> 00:57:12,370
that, from our recon exceptions,
you could add try and accept

1173
00:57:12,370 --> 00:57:13,840
as needed in places.

1174
00:57:13,840 --> 00:57:16,930
Let me go back to the code here and
propose that something else could

1175
00:57:16,930 --> 00:57:18,430
go wrong with house.

1176
00:57:18,430 --> 00:57:19,810
If there is a name, we're good.

1177
00:57:19,810 --> 00:57:22,090
But if we're given a
house but it's invalid,

1178
00:57:22,090 --> 00:57:24,940
we should probably raise
an exception for that, too.

1179
00:57:24,940 --> 00:57:26,200
So what if we do this?

1180
00:57:26,200 --> 00:57:32,200
If house is not in the list containing
"Gryffindor," quote, unquote,

1181
00:57:32,200 --> 00:57:34,720
"Hufflepuff," quote, unquote--

1182
00:57:34,720 --> 00:57:38,890
let's see, "Ravenclaw," quote,
unquote, or "Slytherin,"

1183
00:57:38,890 --> 00:57:41,830
quote, unquote, then,
with my colon, let's

1184
00:57:41,830 --> 00:57:43,420
raise another type of value error.

1185
00:57:43,420 --> 00:57:45,460
But rather than raise
a generic value error,

1186
00:57:45,460 --> 00:57:49,750
let's pass in an argument,
quote, unquote, "Invalid house."

1187
00:57:49,750 --> 00:57:52,690
And so here we now see
a capability that we

1188
00:57:52,690 --> 00:57:55,910
can do with classes that
we can't with dictionaries.

1189
00:57:55,910 --> 00:58:00,560
If you add an attribute to a
dictionary, a key to a dictionary,

1190
00:58:00,560 --> 00:58:02,090
it's going in no matter what.

1191
00:58:02,090 --> 00:58:05,987
Even if the name is empty, even if the
house is a completely random string

1192
00:58:05,987 --> 00:58:07,820
of text that's not one
of these four houses,

1193
00:58:07,820 --> 00:58:09,350
it's going into that dictionary.

1194
00:58:09,350 --> 00:58:12,710
But with a class, and by
way of this init method,

1195
00:58:12,710 --> 00:58:17,760
you and I can now control exactly what's
going to be installed, if you will,

1196
00:58:17,760 --> 00:58:19,040
inside of this object.

1197
00:58:19,040 --> 00:58:22,460
You have a little more
control now over correctness.

1198
00:58:22,460 --> 00:58:26,600
And so now let me go ahead and scroll
back down to my terminal window

1199
00:58:26,600 --> 00:58:27,290
and clear it.

1200
00:58:27,290 --> 00:58:29,480
Let me run Python of student.py.

1201
00:58:29,480 --> 00:58:31,250
Let me type in something like Harry.

1202
00:58:31,250 --> 00:58:33,950
Let me type in Gryffindor,
Enter, and we see

1203
00:58:33,950 --> 00:58:35,660
that, indeed, Harry is from Gryffindor.

1204
00:58:35,660 --> 00:58:37,650
What if I made a mistake, though?

1205
00:58:37,650 --> 00:58:40,760
What if I ran Python of student.py
and typed Harry as the name,

1206
00:58:40,760 --> 00:58:44,420
but this time typed in Number
Four, Privet Drive, which

1207
00:58:44,420 --> 00:58:47,480
is where he grew up, instead
of his proper Hogwarts house.

1208
00:58:47,480 --> 00:58:51,320
Let me hit Enter now, and
now you see a value error.

1209
00:58:51,320 --> 00:58:54,470
But this isn't one that Python
generated for us, per se.

1210
00:58:54,470 --> 00:58:56,150
I raised this error.

1211
00:58:56,150 --> 00:58:59,660
And therefore, if I went in and wrote
more code in my get_student function,

1212
00:58:59,660 --> 00:59:04,650
I could also catch this error
with our usual try except syntax.

1213
00:59:04,650 --> 00:59:09,260
So all we have now is not just classes
in our toolkit, but even more powers

1214
00:59:09,260 --> 00:59:12,590
when it comes to exceptions, and
not just catching them ourselves

1215
00:59:12,590 --> 00:59:15,350
but raising them ourselves, too.

1216
00:59:15,350 --> 00:59:21,700
Any questions now on this use of
classes and init and now this ability

1217
00:59:21,700 --> 00:59:26,020
to raise exceptions when something goes
wrong inside of the initialization?

1218
00:59:26,020 --> 00:59:29,430
AUDIENCE: So what if the
user has a middle name--

1219
00:59:29,430 --> 00:59:31,300
name, middle name, and last name?

1220
00:59:31,300 --> 00:59:32,740
How would you fix that?

1221
00:59:32,740 --> 00:59:35,260
DAVID J. MALAN: Good question.

1222
00:59:35,260 --> 00:59:38,900
If you wanted the student to have a
first name, middle name, and last name,

1223
00:59:38,900 --> 00:59:41,050
we could do this in a
bunch of different ways.

1224
00:59:41,050 --> 00:59:44,440
The simplest, though, if-- let
me clear my screen here, and let

1225
00:59:44,440 --> 00:59:46,030
me just temporarily do this.

1226
00:59:46,030 --> 00:59:51,340
Let me propose that the init method take
in a first argument, a middle argument,

1227
00:59:51,340 --> 00:59:53,000
and a last argument.

1228
00:59:53,000 --> 00:59:57,820
And then what I think I would do down
here is ultimately have first = first,

1229
00:59:57,820 --> 01:00:00,910
and then I would do the same
thing for middle and last.

1230
01:00:00,910 --> 01:00:05,560
So middle and middle,
and then last and last.

1231
01:00:05,560 --> 01:00:08,590
And then what I would
have to do here is,

1232
01:00:08,590 --> 01:00:11,200
when I actually ask the
user for their name,

1233
01:00:11,200 --> 01:00:12,730
I might need to really go all out.

1234
01:00:12,730 --> 01:00:15,160
I might need to ask them
first for their first name

1235
01:00:15,160 --> 01:00:18,910
and store that in a variable called
first, and therefore pass in first.

1236
01:00:18,910 --> 01:00:21,820
I might similarly need to ask
them for their middle name

1237
01:00:21,820 --> 01:00:25,510
and store that in a variable and then
pass in a second argument, middle.

1238
01:00:25,510 --> 01:00:28,360
And then lastly, if you will,
let me go ahead and create

1239
01:00:28,360 --> 01:00:31,900
a third variable called last, get
the input for their last name,

1240
01:00:31,900 --> 01:00:34,030
and pass that in as well.

1241
01:00:34,030 --> 01:00:38,140
I could instead just use one input and
just ask them for their whole name.

1242
01:00:38,140 --> 01:00:42,580
So type in David Malan, Enter, or
David J. Malan-- all three of them,

1243
01:00:42,580 --> 01:00:45,670
and maybe I could use
Python's split function,

1244
01:00:45,670 --> 01:00:47,588
maybe a regular expression
to tease it apart.

1245
01:00:47,588 --> 01:00:49,630
That's probably going to
be messy because there's

1246
01:00:49,630 --> 01:00:52,090
going to be people who don't
have just two or three names.

1247
01:00:52,090 --> 01:00:53,470
They might have four or five.

1248
01:00:53,470 --> 01:00:55,960
So maybe sometimes it's better
to have multiple prompts.

1249
01:00:55,960 --> 01:00:58,300
But that's not a problem
because, with a class,

1250
01:00:58,300 --> 01:01:02,290
we have the expressiveness to
take in more arguments if we want.

1251
01:01:02,290 --> 01:01:04,040
We could even take a list if we wanted.

1252
01:01:04,040 --> 01:01:06,915
But I think we'd probably want to
have even more error checking then,

1253
01:01:06,915 --> 01:01:11,470
not just for name but for first,
and then maybe for middle, and then

1254
01:01:11,470 --> 01:01:12,220
maybe for last.

1255
01:01:12,220 --> 01:01:14,530
So it just is more and more
code, though there would be

1256
01:01:14,530 --> 01:01:17,030
ways to perhaps consolidate that, too.

1257
01:01:17,030 --> 01:01:22,480
Let me undo all of that and see if there
are other questions now on classes.

1258
01:01:22,480 --> 01:01:24,310
AUDIENCE: I assume
classes are something I

1259
01:01:24,310 --> 01:01:25,935
might do at the beginning of a project.

1260
01:01:25,935 --> 01:01:28,600
Can I just put them in a
different file and import them

1261
01:01:28,600 --> 01:01:32,065
into my project, or my
main code as needed?

1262
01:01:32,065 --> 01:01:33,190
DAVID J. MALAN: Absolutely.

1263
01:01:33,190 --> 01:01:34,190
A really good question.

1264
01:01:34,190 --> 01:01:36,065
You could imagine wanting
to use this student

1265
01:01:36,065 --> 01:01:40,660
class, not just in student.py but in
other files or other projects of yours.

1266
01:01:40,660 --> 01:01:44,440
And absolutely, you can create
your own library of classes

1267
01:01:44,440 --> 01:01:47,980
by putting the student class
in your own module or package,

1268
01:01:47,980 --> 01:01:50,590
per our discussion in the past
about libraries more generally.

1269
01:01:50,590 --> 01:01:52,240
And absolutely, you can do that.

1270
01:01:52,240 --> 01:01:54,850
And later today, what
we see is we've actually

1271
01:01:54,850 --> 01:01:58,160
been using classes-- you and I--
before, in third party libraries.

1272
01:01:58,160 --> 01:02:00,410
So you, too, can absolutely do the same.

1273
01:02:00,410 --> 01:02:03,685
How about one more question on classes?

1274
01:02:03,685 --> 01:02:06,550
AUDIENCE: Can you have
optional variables in classes?

1275
01:02:06,550 --> 01:02:09,670
And two, can you have your
own error names, like--

1276
01:02:09,670 --> 01:02:13,240
let's be egotistical and say
I want to raise Eric error?

1277
01:02:13,240 --> 01:02:16,180
DAVID J. MALAN: Short answer, yes.

1278
01:02:16,180 --> 01:02:18,760
These init functions are just
like Python functions more

1279
01:02:18,760 --> 01:02:21,010
generally, even though they're
special in that they're

1280
01:02:21,010 --> 01:02:23,682
going to get called
automatically by Python for you.

1281
01:02:23,682 --> 01:02:25,390
But if you wanted to
make house optional,

1282
01:02:25,390 --> 01:02:26,765
you could do something like this.

1283
01:02:26,765 --> 01:02:31,780
You could give it a default value
in the init function's signature

1284
01:02:31,780 --> 01:02:34,270
so to speak-- in that first
line of code on line two.

1285
01:02:34,270 --> 01:02:36,885
And that would allow me to
not have to pass in house.

1286
01:02:36,885 --> 01:02:39,760
In this case, I'm going to continue
to always pass in name and house,

1287
01:02:39,760 --> 01:02:41,500
but you could make things optional.

1288
01:02:41,500 --> 01:02:45,460
And yes, to your second question, if you
wanted to have your own error message,

1289
01:02:45,460 --> 01:02:50,812
like an Eric error, you could actually
create your own Eric error exception.

1290
01:02:50,812 --> 01:02:53,020
And we'll see, in a little
bit, that there's actually

1291
01:02:53,020 --> 01:02:58,060
a whole suite of exceptions that exist,
and you, too, can invent those as well.

1292
01:02:58,060 --> 01:03:01,390
Let me propose, though,
that we now introduce

1293
01:03:01,390 --> 01:03:06,250
one other aspect of this whereby we try
printing out what a student looks like.

1294
01:03:06,250 --> 01:03:08,920
At the moment, if I scroll
back down to my main function,

1295
01:03:08,920 --> 01:03:11,800
I'm still printing the student's
name and house very manually.

1296
01:03:11,800 --> 01:03:14,830
I'm going inside of the
object, doing student.name,

1297
01:03:14,830 --> 01:03:17,710
and I'm going inside of the object
again and getting student.house,

1298
01:03:17,710 --> 01:03:20,740
just to see where the student is from.

1299
01:03:20,740 --> 01:03:23,650
But wouldn't it be nice if I
could just print the student,

1300
01:03:23,650 --> 01:03:25,570
like I've been printing for weeks--

1301
01:03:25,570 --> 01:03:29,470
any, int, or float, or str,
or any other data type?

1302
01:03:29,470 --> 01:03:32,500
Well, let's see what happens if
I just try printing the student,

1303
01:03:32,500 --> 01:03:36,167
instead of manually going inside and
trying to create that sentence myself.

1304
01:03:36,167 --> 01:03:39,250
Well, in my terminal window-- let me
go ahead and run Python of student.py

1305
01:03:39,250 --> 01:03:40,150
again.

1306
01:03:40,150 --> 01:03:41,230
Let me type in Harry.

1307
01:03:41,230 --> 01:03:42,550
Let me type in Gryffindor.

1308
01:03:42,550 --> 01:03:50,350
And voila, Harry-- whoa, OK, main
student object at 0x102733e80.

1309
01:03:50,350 --> 01:03:51,910
Well, what is going on?

1310
01:03:51,910 --> 01:03:53,702
Well, if you were to
run the same code, you

1311
01:03:53,702 --> 01:03:55,993
might actually see something
different on your computer

1312
01:03:55,993 --> 01:03:57,190
in terms of that number.

1313
01:03:57,190 --> 01:04:01,960
But what you're really seeing is the
underlying representation, as a string,

1314
01:04:01,960 --> 01:04:03,640
of this specific object.

1315
01:04:03,640 --> 01:04:06,880
In particular, you're seeing where
in the computer's memory it is.

1316
01:04:06,880 --> 01:04:12,730
This number, 30x102733e80, refers
to, essentially, a specific location

1317
01:04:12,730 --> 01:04:14,560
in the computer's memory or RAM.

1318
01:04:14,560 --> 01:04:19,150
That's not really that interesting
for me or you or, generally speaking,

1319
01:04:19,150 --> 01:04:22,270
programmers, but it's just
the default way of describing,

1320
01:04:22,270 --> 01:04:25,780
via print, what this thing is.

1321
01:04:25,780 --> 01:04:28,250
But I can override this as well.

1322
01:04:28,250 --> 01:04:31,780
It turns out that there are
other special methods in Python

1323
01:04:31,780 --> 01:04:32,950
when it comes to classes--

1324
01:04:32,950 --> 01:04:36,370
not just underscore underscore,
init, underscore underscore,

1325
01:04:36,370 --> 01:04:40,540
but, continuing in that same
pattern, underscore underscore, str,

1326
01:04:40,540 --> 01:04:42,040
underscore underscore.

1327
01:04:42,040 --> 01:04:47,020
So this, too, is a special method that,
if you define it inside of your class,

1328
01:04:47,020 --> 01:04:50,560
Python will just automatically
call this function

1329
01:04:50,560 --> 01:04:56,530
for you any time some other function
wants to see your object as a string.

1330
01:04:56,530 --> 01:04:59,770
Print wants to see your
object as a string.

1331
01:04:59,770 --> 01:05:02,950
But by default, if you don't have
this method defined in your class,

1332
01:05:02,950 --> 01:05:06,400
it's going to print out that very
ugly esoteric incarnation thereof,

1333
01:05:06,400 --> 01:05:10,420
where it says main__.Student
object at 0x, dot, dot, dot.

1334
01:05:10,420 --> 01:05:13,250
Well, how can I then
define my own str function?

1335
01:05:13,250 --> 01:05:17,050
Well, here, back in VS Code,
let me propose that I go in

1336
01:05:17,050 --> 01:05:23,410
and define not just __ init, but let me
define a second function in this class

1337
01:05:23,410 --> 01:05:25,030
here, as follows--

1338
01:05:25,030 --> 01:05:28,420
def __ str __.

1339
01:05:28,420 --> 01:05:29,320
There are two.

1340
01:05:29,320 --> 01:05:32,530
Even though the font in VS Code is
putting the two underscore so close,

1341
01:05:32,530 --> 01:05:34,360
it just looks like a longer underscore.

1342
01:05:34,360 --> 01:05:37,570
There are indeed two there, on the
left and the right just like for init.

1343
01:05:37,570 --> 01:05:42,790
This one only takes one argument that,
by convention, is always called self

1344
01:05:42,790 --> 01:05:44,500
so that you have access to it.

1345
01:05:44,500 --> 01:05:47,690
And then, indented below
that after a colon,

1346
01:05:47,690 --> 01:05:51,140
I'm going to go ahead and create
a format string and return it.

1347
01:05:51,140 --> 01:05:53,510
So let me go ahead and return--

1348
01:05:53,510 --> 01:05:56,390
how about something generic
first like "a student."

1349
01:05:56,390 --> 01:05:58,900
So I'm not going to bother
even trying to figure out

1350
01:05:58,900 --> 01:06:00,610
what this student's name or house is.

1351
01:06:00,610 --> 01:06:02,890
I'm just going to always
return "a student."

1352
01:06:02,890 --> 01:06:08,650
Let me go back now to my earlier code,
which has print (student) on line 16.

1353
01:06:08,650 --> 01:06:13,030
Let me clear my terminal window and
rerun Python of student.py, Enter.

1354
01:06:13,030 --> 01:06:14,950
Type in Harry, type in Gryffindor.

1355
01:06:14,950 --> 01:06:17,320
Last time, I saw that
very cryptic output.

1356
01:06:17,320 --> 01:06:20,940
This time, I see, more
generically, "a student."

1357
01:06:20,940 --> 01:06:23,390
More readable but not very enlightening.

1358
01:06:23,390 --> 01:06:24,560
Which student is this?

1359
01:06:24,560 --> 01:06:31,790
Well, notice that the double underscore
str method takes in this self argument

1360
01:06:31,790 --> 01:06:36,710
by default. It's just the way the
Python authors designed this method.

1361
01:06:36,710 --> 01:06:41,840
It will always be passed a reference
to the current student object.

1362
01:06:41,840 --> 01:06:43,020
What do I mean by that?

1363
01:06:43,020 --> 01:06:45,920
When this line of code
on line 6 is called,

1364
01:06:45,920 --> 01:06:48,680
print, because it's hoping
it's going to get a string,

1365
01:06:48,680 --> 01:06:52,730
is going to trigger the underscore
underscore, str, underscore

1366
01:06:52,730 --> 01:06:54,470
underscore method to be called.

1367
01:06:54,470 --> 01:06:58,430
And Python, for you, automatically
is going to pass into that method

1368
01:06:58,430 --> 01:07:01,220
a reference to the object
that's trying to be

1369
01:07:01,220 --> 01:07:05,280
printed so that you, the programmer,
can do something like this.

1370
01:07:05,280 --> 01:07:08,000
Here's an f string with
double quotes as usual.

1371
01:07:08,000 --> 01:07:10,460
I'm going to use some curly
braces and say print out

1372
01:07:10,460 --> 01:07:14,240
self.name from self.house.

1373
01:07:14,240 --> 01:07:17,450
So there's nothing new
in what I've just done.

1374
01:07:17,450 --> 01:07:19,940
It's just an f string--
an f on the beginning,

1375
01:07:19,940 --> 01:07:22,700
two double quotes, a couple
of pairs of curly braces.

1376
01:07:22,700 --> 01:07:28,760
But because, automatically, this str
method gets passed self, so to speak,

1377
01:07:28,760 --> 01:07:32,330
a reference to the current object,
I can go inside of that object

1378
01:07:32,330 --> 01:07:33,080
and grab the name.

1379
01:07:33,080 --> 01:07:36,020
I can go inside that object
again and grab the house.

1380
01:07:36,020 --> 01:07:38,780
So now, when I go back
to my terminal window--

1381
01:07:38,780 --> 01:07:41,030
previously it just
printed out a student.

1382
01:07:41,030 --> 01:07:44,420
But now, if I run Python
of student.py, Enter--

1383
01:07:44,420 --> 01:07:48,080
type in Harry, type in Gryffindor,
and one more time hit Enter,

1384
01:07:48,080 --> 01:07:50,750
Harry is again from Gryffindor.

1385
01:07:50,750 --> 01:07:52,490
But if I run this yet again--

1386
01:07:52,490 --> 01:07:57,110
let's, for instance, do Draco
is from Slytherin, Enter.

1387
01:07:57,110 --> 01:07:58,610
Draco's from Slytherin.

1388
01:07:58,610 --> 01:08:04,280
Now it's customized to the specific
object that we're trying to print.

1389
01:08:04,280 --> 01:08:08,270
Questions on this function here--

1390
01:08:08,270 --> 01:08:11,675
this Dunder str method.

1391
01:08:11,675 --> 01:08:14,540
AUDIENCE: Is there anything else
that the underscore underscore,

1392
01:08:14,540 --> 01:08:16,649
str method can do?

1393
01:08:16,649 --> 01:08:19,399
The other question is, what's the
difference between str and repr.

1394
01:08:19,399 --> 01:08:20,732
DAVID J. MALAN: A good question.

1395
01:08:20,732 --> 01:08:24,439
So there are many other methods
that come with Python classes

1396
01:08:24,439 --> 01:08:26,060
that start with underscore underscore.

1397
01:08:26,060 --> 01:08:27,950
We're just scratching the
surface, and we'll pretty much

1398
01:08:27,950 --> 01:08:29,090
focus primarily on these.

1399
01:08:29,090 --> 01:08:30,830
But yes, there are
many others, and we'll

1400
01:08:30,830 --> 01:08:33,649
see at least one other
in just a little bit.

1401
01:08:33,649 --> 01:08:37,370
Among the others is one
called repr, which is

1402
01:08:37,370 --> 01:08:39,590
a representation of the Python object.

1403
01:08:39,590 --> 01:08:43,010
Generally speaking, the
underscore underscore, repr,

1404
01:08:43,010 --> 01:08:45,800
underscore underscore method
is meant for developers' eyes.

1405
01:08:45,800 --> 01:08:49,160
It typically has more information
than "Harry from Gryffindor."

1406
01:08:49,160 --> 01:08:53,090
It would also say what type of
object it is, like a student, capital

1407
01:08:53,090 --> 01:08:56,600
S, whereas underscore underscore, str,
underscore underscore is generally

1408
01:08:56,600 --> 01:08:58,130
meant for users--

1409
01:08:58,130 --> 01:09:01,500
the users of the program, and it's
meant to be even more user-friendly.

1410
01:09:01,500 --> 01:09:04,220
But both of those can be
overridden as you see fit.

1411
01:09:04,220 --> 01:09:08,060
Well, let me propose now that we pick
up where we've left off on student

1412
01:09:08,060 --> 01:09:11,960
and just add even more functionality,
but not just these special methods

1413
01:09:11,960 --> 01:09:15,170
like double underscore init
and double underscore str.

1414
01:09:15,170 --> 01:09:18,770
Let's create our own methods
because therein lies the real power

1415
01:09:18,770 --> 01:09:21,859
and flexibility of classes if
you and I as the programmers

1416
01:09:21,859 --> 01:09:25,290
can invent new functionality
that's specific to students.

1417
01:09:25,290 --> 01:09:29,120
For instance, students at
Hogwarts, over the time in school,

1418
01:09:29,120 --> 01:09:31,520
learn how to cast a
certain type of spell.

1419
01:09:31,520 --> 01:09:34,080
So when they say, Expecto
Patronum, something

1420
01:09:34,080 --> 01:09:36,080
comes out of their wand
that typically resembles

1421
01:09:36,080 --> 01:09:37,455
an animal or something like that.

1422
01:09:37,455 --> 01:09:40,020
It's a special spell that they
have to practice and practice.

1423
01:09:40,020 --> 01:09:44,060
So let's see if we can't store, not
just the student's name and their house,

1424
01:09:44,060 --> 01:09:47,029
but also their "patronus,"
what, actually, they

1425
01:09:47,029 --> 01:09:48,625
conjure when using this spell.

1426
01:09:48,625 --> 01:09:50,750
Well, let me go ahead and
clear my terminal window.

1427
01:09:50,750 --> 01:09:56,600
And in the top of my code here, in the
init method of Student, let me go ahead

1428
01:09:56,600 --> 01:10:00,860
and start expecting a third argument,
in addition to self, which automatically

1429
01:10:00,860 --> 01:10:02,840
gets passed in, called patronus.

1430
01:10:02,840 --> 01:10:06,140
And I'm not going to worry,
for now, on validating

1431
01:10:06,140 --> 01:10:10,040
the patronus from an official list
of valid patronuses, or patroni.

1432
01:10:10,040 --> 01:10:13,040
I'm instead going to go
ahead and just blindly assign

1433
01:10:13,040 --> 01:10:16,460
it to self.patronus
= patronus, and we're

1434
01:10:16,460 --> 01:10:19,070
going to let the user type
whatever they want for now.

1435
01:10:19,070 --> 01:10:21,350
But I could certainly
add more error checking

1436
01:10:21,350 --> 01:10:25,580
if I wanted to limit the patronus
to a specific list of them here.

1437
01:10:25,580 --> 01:10:29,000
Let me go ahead now and prompt
the user for this patronus,

1438
01:10:29,000 --> 01:10:33,650
as by-- in my get_student
function-- defining a variable

1439
01:10:33,650 --> 01:10:36,380
called patronus or anything
else, prompting the user

1440
01:10:36,380 --> 01:10:38,330
for input for their patronus.

1441
01:10:38,330 --> 01:10:42,720
And now I'm going to go ahead and
pass in that third variable here.

1442
01:10:42,720 --> 01:10:46,037
So again, similar in spirit to just
adding more and more attributes

1443
01:10:46,037 --> 01:10:47,870
to the class, I'm going
to pass in all three

1444
01:10:47,870 --> 01:10:49,798
of these values instead of just two.

1445
01:10:49,798 --> 01:10:52,340
I'm not going to do anything
interesting with that value yet.

1446
01:10:52,340 --> 01:10:55,580
But just to make sure I haven't made
things worse by breaking my code,

1447
01:10:55,580 --> 01:10:57,860
let me run Python of student.py.

1448
01:10:57,860 --> 01:10:59,090
I'll type in Harry.

1449
01:10:59,090 --> 01:11:00,410
I'll type in Gryffindor.

1450
01:11:00,410 --> 01:11:02,510
And it turns out his
patronus was a stag, .

1451
01:11:02,510 --> 01:11:06,110
And hit Enter I haven't seen
what his patronus is in my output

1452
01:11:06,110 --> 01:11:08,690
because I didn't change
my str method yet.

1453
01:11:08,690 --> 01:11:10,620
But at least I don't
have any syntax errors.

1454
01:11:10,620 --> 01:11:12,950
So at least I've not
made anything worse.

1455
01:11:12,950 --> 01:11:16,400
But suppose, now, I want to
have functionality, not just

1456
01:11:16,400 --> 01:11:19,700
for initializing a student
and printing out a student.

1457
01:11:19,700 --> 01:11:23,680
If my class is really meant
to be a student, what I can do

1458
01:11:23,680 --> 01:11:27,430
is not just remember information
about data about students.

1459
01:11:27,430 --> 01:11:31,300
What's powerful about classes,
unlike dictionaries alone,

1460
01:11:31,300 --> 01:11:36,700
is that classes can have, not just
variables or instance variables--

1461
01:11:36,700 --> 01:11:38,620
those attributes we keep creating.

1462
01:11:38,620 --> 01:11:42,460
They can also have
functions built in, a.k.a.

1463
01:11:42,460 --> 01:11:43,100
methods.

1464
01:11:43,100 --> 01:11:45,940
When a function is inside of a
class, it's called a "method,"

1465
01:11:45,940 --> 01:11:47,680
but it's still just a function.

1466
01:11:47,680 --> 01:11:51,010
At this point, we've seen two
functions already-- two methods--

1467
01:11:51,010 --> 01:11:54,940
called a double underscore
init and double underscore str,

1468
01:11:54,940 --> 01:11:57,940
but those are special methods
in that they just work.

1469
01:11:57,940 --> 01:12:01,400
If you define them, Python calls
them automatically for you.

1470
01:12:01,400 --> 01:12:04,940
But what if you wanted to create
more functionality for a student

1471
01:12:04,940 --> 01:12:08,980
so that your class really represents
this real world, or maybe "fantasy"

1472
01:12:08,980 --> 01:12:13,360
world notion of a student, where
students not only have names and houses

1473
01:12:13,360 --> 01:12:16,390
and patronuses; they
also have functionality.

1474
01:12:16,390 --> 01:12:22,540
They have actions they can perform like
casting a charm, a spell, magically.

1475
01:12:22,540 --> 01:12:26,320
Could we implement, therefore,
a function called charm, that

1476
01:12:26,320 --> 01:12:30,280
actually uses their magical knowledge?

1477
01:12:30,280 --> 01:12:33,800
Well, let's go ahead and define
our very own function as follows.

1478
01:12:33,800 --> 01:12:37,570
Let me clear my terminal window,
scroll back up to my student class.

1479
01:12:37,570 --> 01:12:40,930
And instead of creating yet
another function that's special,

1480
01:12:40,930 --> 01:12:45,430
with double underscores, I'm going
to invent my own function, or method,

1481
01:12:45,430 --> 01:12:46,900
inside of this class.

1482
01:12:46,900 --> 01:12:51,520
I want to give Harry and Hermione
and all of the other students

1483
01:12:51,520 --> 01:12:55,000
the ability to cast charms, so I'm
going to define a function that I

1484
01:12:55,000 --> 01:12:57,290
can completely, on my own, call charm.

1485
01:12:57,290 --> 01:12:59,110
I could call this
function anything I want.

1486
01:12:59,110 --> 01:13:01,720
But because it's a
method inside of a class,

1487
01:13:01,720 --> 01:13:06,070
the convention is that it's always going
to take at least one argument, called

1488
01:13:06,070 --> 01:13:11,000
self, by convention so that you
have access to the current object,

1489
01:13:11,000 --> 01:13:13,090
even if you don't plan
to use it, per se.

1490
01:13:13,090 --> 01:13:16,690
All right, let me go ahead and propose
that we implement charm in such a way

1491
01:13:16,690 --> 01:13:21,730
that the method returns an emoji
that's appropriate for each student's

1492
01:13:21,730 --> 01:13:23,140
patronus.

1493
01:13:23,140 --> 01:13:25,750
How to implement this-- well,
inside of the charm method,

1494
01:13:25,750 --> 01:13:29,050
let's go ahead and
match on self.patronus,

1495
01:13:29,050 --> 01:13:31,420
which is the instance variable
containing a string that

1496
01:13:31,420 --> 01:13:33,460
represents each student's patronus.

1497
01:13:33,460 --> 01:13:38,200
And in the case that it matches a stag,
for instance, for Harry, let's go ahead

1498
01:13:38,200 --> 01:13:40,330
and return maybe the closest emoji--

1499
01:13:40,330 --> 01:13:41,740
this horse here.

1500
01:13:41,740 --> 01:13:44,620
How about in the case of an otter?

1501
01:13:44,620 --> 01:13:49,690
Well, in that case, let's go ahead and
return, oh, maybe the closest match

1502
01:13:49,690 --> 01:13:52,570
to the otter, which
might be this emoji here.

1503
01:13:52,570 --> 01:13:57,020
And let's see, in the case of a--
for Ron, rather than Hermione--

1504
01:13:57,020 --> 01:14:02,800
a Jack Russell terrier,
let's go ahead and return--

1505
01:14:02,800 --> 01:14:04,630
don't have as many options here.

1506
01:14:04,630 --> 01:14:08,740
Why don't we go ahead and return the
cutest available dog in that case.

1507
01:14:08,740 --> 01:14:14,260
And in the case of no
patronus recognized,

1508
01:14:14,260 --> 01:14:16,360
as might cover someone
like Draco, let's go ahead

1509
01:14:16,360 --> 01:14:19,750
and use a default case using
the underscore as in the past,

1510
01:14:19,750 --> 01:14:22,792
and let's go ahead and return
for this-- oh, what should happen

1511
01:14:22,792 --> 01:14:24,250
if someone doesn't have a patronus?

1512
01:14:24,250 --> 01:14:26,560
Why don't we just see
a magical wand that

1513
01:14:26,560 --> 01:14:28,955
seems to fizzle out, as in this case?

1514
01:14:28,955 --> 01:14:31,330
All right, well, now, rather
than just print the student,

1515
01:14:31,330 --> 01:14:33,370
let's go about printing
their actual patronus.

1516
01:14:33,370 --> 01:14:36,010
So I'm going to go down
to my main function here.

1517
01:14:36,010 --> 01:14:39,250
I'm going to still get a student,
using the get_student function.

1518
01:14:39,250 --> 01:14:44,200
But rather than print student, let's go
ahead and declare "Expecto Patronum!"

1519
01:14:44,200 --> 01:14:46,810
printing out just that as pure text.

1520
01:14:46,810 --> 01:14:50,770
And now let's go ahead and print
out, not the student but, rather,

1521
01:14:50,770 --> 01:14:54,400
the return value of
their own charm method.

1522
01:14:54,400 --> 01:14:58,600
So let me go back down to my terminal
window and run Python of student.py

1523
01:14:58,600 --> 01:14:59,710
and Enter.

1524
01:14:59,710 --> 01:15:01,270
Name-- let's start with Harry.

1525
01:15:01,270 --> 01:15:03,520
He lives in Gryffindor.

1526
01:15:03,520 --> 01:15:05,080
Patronus is a stag.

1527
01:15:05,080 --> 01:15:06,310
And let's see--

1528
01:15:06,310 --> 01:15:08,110
Expecto Patronum!

1529
01:15:08,110 --> 01:15:10,710
And of course, we'd see the stag emoji.

1530
01:15:10,710 --> 01:15:13,330
What about someone like Draco,
who, at least in the books,

1531
01:15:13,330 --> 01:15:15,327
doesn't have a known patronus?

1532
01:15:15,327 --> 01:15:17,410
Well, let's go ahead and
clear my terminal window,

1533
01:15:17,410 --> 01:15:22,630
rerun Python of student.py, and this
time, let's type in Draco for name,

1534
01:15:22,630 --> 01:15:25,747
Slytherin for house,
and Patronus is unknown.

1535
01:15:25,747 --> 01:15:27,580
So I'm just going to
go ahead and hit Enter.

1536
01:15:27,580 --> 01:15:29,650
And now, Expecto Patronum!

1537
01:15:29,650 --> 01:15:33,400
And it just of sizzles instead.

1538
01:15:33,400 --> 01:15:39,960
Questions now on what I've done
by implementing this charm method.

1539
01:15:39,960 --> 01:15:43,275
AUDIENCE: Can we call a
method outside the function?

1540
01:15:43,275 --> 01:15:44,400
DAVID J. MALAN: Absolutely.

1541
01:15:44,400 --> 01:15:45,660
And we're seeing that already.

1542
01:15:45,660 --> 01:15:48,150
If I scroll back down
to my main function

1543
01:15:48,150 --> 01:15:49,980
which is outside of the class--

1544
01:15:49,980 --> 01:15:51,730
because it's all the
way down in the file;

1545
01:15:51,730 --> 01:15:55,110
it's all left aligned, just like
the class, notice on line 28,

1546
01:15:55,110 --> 01:15:57,600
I'm calling student.charm.

1547
01:15:57,600 --> 01:16:02,010
And I'm accessing a method that's
inside of the student object,

1548
01:16:02,010 --> 01:16:05,950
even though my main function
is outside of the class.

1549
01:16:05,950 --> 01:16:12,370
And what's different between our init
function, or method, and our str method

1550
01:16:12,370 --> 01:16:13,480
that we've seen before--

1551
01:16:13,480 --> 01:16:17,260
those are called automatically
when you try to create a student

1552
01:16:17,260 --> 01:16:18,790
or when you try to print a student.

1553
01:16:18,790 --> 01:16:21,130
For the first time,
we're now seeing a method

1554
01:16:21,130 --> 01:16:26,080
that I invented inside of the student
class that I can call anywhere I want.

1555
01:16:26,080 --> 01:16:28,690
And if I'm calling it outside
of the class like I am here,

1556
01:16:28,690 --> 01:16:31,090
I just use the name of
the variable containing

1557
01:16:31,090 --> 01:16:33,760
that student object,
and I just do dot charm,

1558
01:16:33,760 --> 01:16:38,800
just like I could access the individual
attributes or instance variables

1559
01:16:38,800 --> 01:16:41,300
inside of that object as well.

1560
01:16:41,300 --> 01:16:46,015
Other questions on classes
and this new method, charm?

1561
01:16:46,015 --> 01:16:49,960
AUDIENCE: In the
parentheses, you put self.

1562
01:16:49,960 --> 01:16:51,550
It's supposed to be an initializer.

1563
01:16:51,550 --> 01:16:56,740
But in the top part, you
didn't define it the same way.

1564
01:16:56,740 --> 01:17:00,482
Would you have to put the class on-- why
you didn't put the class right there?

1565
01:17:00,482 --> 01:17:02,440
DAVID J. MALAN: So notice
the indentation here.

1566
01:17:02,440 --> 01:17:06,490
So on line 1, I've of course said class
Student colon, and then everything

1567
01:17:06,490 --> 01:17:08,260
below that is indented at the moment.

1568
01:17:08,260 --> 01:17:12,550
That means that my init method, my
str, method and this new charm method

1569
01:17:12,550 --> 01:17:15,760
are all inside of part of that class.

1570
01:17:15,760 --> 01:17:19,390
By convention then, each of
these methods inside of a class

1571
01:17:19,390 --> 01:17:22,930
should expect that
Python will automatically

1572
01:17:22,930 --> 01:17:26,740
pass in at least one argument
to every method in a class,

1573
01:17:26,740 --> 01:17:31,240
and that argument will always be
a reference to the current object,

1574
01:17:31,240 --> 01:17:34,990
the Harry object, or the
Draco object that is currently

1575
01:17:34,990 --> 01:17:37,640
trying to cast a charm or be printed.

1576
01:17:37,640 --> 01:17:40,900
So whenever you create a
method inside of a class

1577
01:17:40,900 --> 01:17:44,380
you should always have it take
at least one argument called self

1578
01:17:44,380 --> 01:17:48,700
and then zero or more other arguments
that are entirely up to you. init,

1579
01:17:48,700 --> 01:17:51,970
for instance takes three more.
name, house, patronus, str

1580
01:17:51,970 --> 01:17:54,820
takes zero more charm, takes zero more.

1581
01:17:54,820 --> 01:17:58,420
But the convention is to always
call that default argument "self,"

1582
01:17:58,420 --> 01:18:04,230
and Python just automatically gives
you access to the current object.

1583
01:18:04,230 --> 01:18:05,400
Other questions?

1584
01:18:05,400 --> 01:18:08,610
How about one more,
on classes and charms?

1585
01:18:08,610 --> 01:18:13,140
AUDIENCE: Sir, I just wanted to ask that
you have put them all in double quotes.

1586
01:18:13,140 --> 01:18:17,820
So a does it take the emojis as a
form of strings or something else?

1587
01:18:17,820 --> 01:18:21,570
DAVID J. MALAN: Yes, if unfamiliar,
an emoji is just a character.

1588
01:18:21,570 --> 01:18:25,830
It's part of a mapping of numbers
to letters known as Unicode.

1589
01:18:25,830 --> 01:18:29,310
And so whenever you see
these emoji on the screen,

1590
01:18:29,310 --> 01:18:32,100
like the horse or the
otter or the dog here,

1591
01:18:32,100 --> 01:18:35,280
specifically, that's really
just a key from your keyboard.

1592
01:18:35,280 --> 01:18:37,200
You and I on Macs and
PCs can't typically

1593
01:18:37,200 --> 01:18:39,060
type it because you
see English characters

1594
01:18:39,060 --> 01:18:40,530
or some other human language.

1595
01:18:40,530 --> 01:18:46,470
But emoji are increasingly available
via menus and dropdown and, in my case,

1596
01:18:46,470 --> 01:18:47,220
Copy Paste.

1597
01:18:47,220 --> 01:18:50,037
On Macs and PCs and Android
devices and iPhones,

1598
01:18:50,037 --> 01:18:52,620
they are just characters, even
though they look like pictures.

1599
01:18:52,620 --> 01:18:55,050
You can think of it like
a graphical font almost.

1600
01:18:55,050 --> 01:18:55,990
So they're just text.

1601
01:18:55,990 --> 01:18:58,740
And indeed, if you put them between
double quotes or single quotes

1602
01:18:58,740 --> 01:19:04,140
you can print emoji just like you can
any other human character as well.

1603
01:19:04,140 --> 01:19:09,420
Well, let me propose, now, that
we remove this patronus code just

1604
01:19:09,420 --> 01:19:13,050
to simplify our world and
focus on some of the other core

1605
01:19:13,050 --> 01:19:14,420
capabilities of classes.

1606
01:19:14,420 --> 01:19:16,170
So at the risk of
disappointing, I'm going

1607
01:19:16,170 --> 01:19:19,110
to get rid of all of these
beautiful emoji and charms,

1608
01:19:19,110 --> 01:19:23,070
and I'm going to go ahead and stop
asking the user now for their patronus.

1609
01:19:23,070 --> 01:19:25,920
And I'm going to stop
passing it into init here.

1610
01:19:25,920 --> 01:19:28,770
And I'm going to stop doing this here.

1611
01:19:28,770 --> 01:19:34,530
And I'm going to instead just go ahead
and restore our use of print student

1612
01:19:34,530 --> 01:19:37,770
here, and I'm going to go ahead
and get rid of patronus down here.

1613
01:19:37,770 --> 01:19:41,740
So just essentially undo all of
the fun charms we just created.

1614
01:19:41,740 --> 01:19:47,520
So we're now back at the point in the
story where we have a student class,

1615
01:19:47,520 --> 01:19:49,230
with only two methods--

1616
01:19:49,230 --> 01:19:50,640
init and str.

1617
01:19:50,640 --> 01:19:52,590
The first of those
takes, of course, self

1618
01:19:52,590 --> 01:19:56,340
as the first argument as it always will,
plus two more now-- name and house,

1619
01:19:56,340 --> 01:19:57,420
no more patronus.

1620
01:19:57,420 --> 01:19:59,250
We're validating name up here.

1621
01:19:59,250 --> 01:20:01,050
We're validating house down here.

1622
01:20:01,050 --> 01:20:03,570
And then we're assigning
name and house, respectively,

1623
01:20:03,570 --> 01:20:06,840
to two instance variables
called name and house also.

1624
01:20:06,840 --> 01:20:10,080
But we use self to get
access to the current object,

1625
01:20:10,080 --> 01:20:11,970
to store those values therein.

1626
01:20:11,970 --> 01:20:15,810
We then still have our str method
here, which takes one argument--

1627
01:20:15,810 --> 01:20:17,430
by default, self, and that's it.

1628
01:20:17,430 --> 01:20:20,940
And that function is going to
be called automatically any time

1629
01:20:20,940 --> 01:20:23,820
you want to convert a
student object to a string,

1630
01:20:23,820 --> 01:20:26,313
just like print might want to do here.

1631
01:20:26,313 --> 01:20:28,980
So let me go ahead and just make
sure I haven't broken anything.

1632
01:20:28,980 --> 01:20:30,960
Let me run Python of student.py.

1633
01:20:30,960 --> 01:20:32,130
I'll type in Harry.

1634
01:20:32,130 --> 01:20:34,260
I'll type in Gryffindor, Enter.

1635
01:20:34,260 --> 01:20:35,640
OK, we're back in business.

1636
01:20:35,640 --> 01:20:39,390
Gone are the charms and patronus,
but at least I'm back to a situation

1637
01:20:39,390 --> 01:20:41,440
where I have names and houses.

1638
01:20:41,440 --> 01:20:45,630
But it turns out, at the
moment, our use of classes

1639
01:20:45,630 --> 01:20:51,300
is not very robust, even though we
have this mechanism, very cleverly,

1640
01:20:51,300 --> 01:20:54,240
if I may, in our init
method of making sure

1641
01:20:54,240 --> 01:20:58,320
that we're validating name and house,
making sure that name is not blank,

1642
01:20:58,320 --> 01:21:03,840
and making sure that house is a valid
house among those four Hogwarts houses.

1643
01:21:03,840 --> 01:21:06,420
It turns out that
classes will still let me

1644
01:21:06,420 --> 01:21:09,750
get at those attributes, those
so-called instance variables,

1645
01:21:09,750 --> 01:21:11,940
using dot notation anyway.

1646
01:21:11,940 --> 01:21:15,720
Let me scroll down then and try
to do this a little adversarially.

1647
01:21:15,720 --> 01:21:19,720
Suppose that online 16 I go
ahead and call get_student,

1648
01:21:19,720 --> 01:21:23,760
which exists as before, and then I
store the return value in a student

1649
01:21:23,760 --> 01:21:26,010
variable-- again, on line 16.

1650
01:21:26,010 --> 01:21:31,500
That will ensure that get_student gets
called, which calls input and input.

1651
01:21:31,500 --> 01:21:34,140
And then it calls the
student constructor,

1652
01:21:34,140 --> 01:21:36,730
which invokes, automatically,
this init method.

1653
01:21:36,730 --> 01:21:39,660
So by way of how we've
laid out my code, we're

1654
01:21:39,660 --> 01:21:42,960
going to ensure that name is not
blank and house is definitely

1655
01:21:42,960 --> 01:21:44,130
one of those four values.

1656
01:21:44,130 --> 01:21:47,770
My error correction-- or
error checking is in place.

1657
01:21:47,770 --> 01:21:51,910
But if I'm a little adversarial,
I can still circumvent it.

1658
01:21:51,910 --> 01:21:56,760
Suppose that-- fine, going to require
me to type in Harry and Gryffindor?

1659
01:21:56,760 --> 01:21:59,310
I'm going to go ahead
and type in student.house

1660
01:21:59,310 --> 01:22:02,768
equals, quote, unquote,
"Number Four, Privet Drive,"

1661
01:22:02,768 --> 01:22:04,560
and you're not going
to be able to stop me.

1662
01:22:04,560 --> 01:22:05,310
Why?

1663
01:22:05,310 --> 01:22:07,920
Well, it turns out,
with classes and objects

1664
01:22:07,920 --> 01:22:11,580
thereof, you and I can still
access those instance variables

1665
01:22:11,580 --> 01:22:13,290
using this familiar dot notation.

1666
01:22:13,290 --> 01:22:16,320
That's how we began the story of
classes-- just setting these attributes

1667
01:22:16,320 --> 01:22:17,070
ourselves.

1668
01:22:17,070 --> 01:22:19,770
But you can also read
these attributes themselves

1669
01:22:19,770 --> 01:22:21,960
and change them later if you want.

1670
01:22:21,960 --> 01:22:27,060
And this will effectively circumvent the
if condition and the other if condition

1671
01:22:27,060 --> 01:22:31,200
in our init method because that
is only called when you first

1672
01:22:31,200 --> 01:22:33,330
create the student object.

1673
01:22:33,330 --> 01:22:35,760
There's nothing stopping
me, at the moment,

1674
01:22:35,760 --> 01:22:39,520
from just changing the
house or the name after.

1675
01:22:39,520 --> 01:22:43,770
So if I now clear my terminal
window and run Python of student.py,

1676
01:22:43,770 --> 01:22:47,430
I'll still type in Harry and
Gryffindor to meet my requirements

1677
01:22:47,430 --> 01:22:49,110
that the house be one of those four.

1678
01:22:49,110 --> 01:22:52,600
But when it's printed, notice,
I've still overridden it.

1679
01:22:52,600 --> 01:22:57,300
So it seems that, while classes do allow
us a little more control over the data

1680
01:22:57,300 --> 01:23:01,440
we're storing, it doesn't
necessarily prevent the user--

1681
01:23:01,440 --> 01:23:04,820
or rather the programmer-- be
it myself or maybe a colleague,

1682
01:23:04,820 --> 01:23:07,010
from still messing things up.

1683
01:23:07,010 --> 01:23:10,310
So here, too, in the spirit
of programming a little more

1684
01:23:10,310 --> 01:23:15,140
defensively, allow me to introduce
another feature of Python as well--

1685
01:23:15,140 --> 01:23:17,400
namely properties.

1686
01:23:17,400 --> 01:23:20,570
So a property is really
just an attribute

1687
01:23:20,570 --> 01:23:23,960
that has even more defense
mechanisms put into place,

1688
01:23:23,960 --> 01:23:29,420
a little more functionality implemented
by you to prevent programmers, like me

1689
01:23:29,420 --> 01:23:32,280
and you, from messing things
up like these attributes.

1690
01:23:32,280 --> 01:23:35,570
So again, a property is going to
be an attribute that you and I just

1691
01:23:35,570 --> 01:23:37,280
have more control over.

1692
01:23:37,280 --> 01:23:37,940
How?

1693
01:23:37,940 --> 01:23:41,000
We just write a little more code,
using some Python conventions.

1694
01:23:41,000 --> 01:23:45,560
And how we're going to do that is going
to use, in just a moment, a feature--

1695
01:23:45,560 --> 01:23:49,310
a keyword known as @property,
which is technically a function.

1696
01:23:49,310 --> 01:23:51,110
Property is a function in Python.

1697
01:23:51,110 --> 01:23:55,987
But we're about to see some new @ syntax
that allows you to decorate functions.

1698
01:23:55,987 --> 01:23:57,320
And this, too, is a term of art.

1699
01:23:57,320 --> 01:24:00,110
In the world of Python,
you can have decorators,

1700
01:24:00,110 --> 01:24:04,380
which are functions that modify
the behavior of other functions,

1701
01:24:04,380 --> 01:24:07,910
if you will, and we'll leave it at that
without going too much into the weeds.

1702
01:24:07,910 --> 01:24:10,490
And we'll see, by, example how
you can use these decorators,

1703
01:24:10,490 --> 01:24:12,750
specifically to define properties.

1704
01:24:12,750 --> 01:24:14,930
So let me go back to VS Code here.

1705
01:24:14,930 --> 01:24:18,020
And let me propose that I do this.

1706
01:24:18,020 --> 01:24:20,600
I'm going to go ahead and create--

1707
01:24:20,600 --> 01:24:25,520
how about a property
called house as follows.

1708
01:24:25,520 --> 01:24:32,030
Inside of my student class, I'm going
to go ahead-- and below my init method

1709
01:24:32,030 --> 01:24:35,180
and below my str method, I'm
going to go ahead and define

1710
01:24:35,180 --> 01:24:40,220
a function called house that takes, as
it always must, one argument at least,

1711
01:24:40,220 --> 01:24:41,270
called self.

1712
01:24:41,270 --> 01:24:46,680
And what I'm going to do
now is return self.house.

1713
01:24:46,680 --> 01:24:48,830
So I'm just going to
define a method called

1714
01:24:48,830 --> 01:24:54,590
house, whose sole purpose in life
is to return the value of house.

1715
01:24:54,590 --> 01:24:58,580
But I'm going to define one other
method, curiously also called house,

1716
01:24:58,580 --> 01:25:02,600
but that's going to take into,
as arguments, two values--

1717
01:25:02,600 --> 01:25:06,830
self as always and also
a value called house.

1718
01:25:06,830 --> 01:25:08,495
And I'm going to now do this.

1719
01:25:08,495 --> 01:25:11,600


1720
01:25:11,600 --> 01:25:15,170
I'm going to do self.house = house.

1721
01:25:15,170 --> 01:25:16,460
Now, what have I done?

1722
01:25:16,460 --> 01:25:18,830
Well, let me just temporarily
add some comments here.

1723
01:25:18,830 --> 01:25:21,380
In a moment, we're going to
start referring to this generally

1724
01:25:21,380 --> 01:25:22,310
as a getter.

1725
01:25:22,310 --> 01:25:25,310
And down here, I'm going to
refer to this as a setter.

1726
01:25:25,310 --> 01:25:28,070
And this is terminology frequently
see in the world of Java.

1727
01:25:28,070 --> 01:25:29,990
Some of you have
programmed in Java before.

1728
01:25:29,990 --> 01:25:33,080
But as the names imply,
a getter is a function

1729
01:25:33,080 --> 01:25:36,530
for a class that gets some attributes.

1730
01:25:36,530 --> 01:25:41,480
A setter is a function in some
class that sets some value.

1731
01:25:41,480 --> 01:25:45,350
And now, even though we're not done, and
there's a bit of a mistake in the code

1732
01:25:45,350 --> 01:25:49,110
I've already written, intuitively,
what we're going to do is this.

1733
01:25:49,110 --> 01:25:52,190
We're trying to prevent
programmers, myself included,

1734
01:25:52,190 --> 01:25:54,770
from circumventing my
error checking that I

1735
01:25:54,770 --> 01:25:56,870
put into place for name and house.

1736
01:25:56,870 --> 01:25:58,168
How can I do that?

1737
01:25:58,168 --> 01:26:00,710
Well, we don't have that many
building blocks in programming.

1738
01:26:00,710 --> 01:26:04,760
We have things like variables for data,
and we have functions for actions.

1739
01:26:04,760 --> 01:26:06,210
Well, why don't we do this?

1740
01:26:06,210 --> 01:26:11,150
Why don't we somehow require that,
in order to access an attribute,

1741
01:26:11,150 --> 01:26:12,590
you go through some function.

1742
01:26:12,590 --> 01:26:15,800
And let's require that, in
order to set some attribute,

1743
01:26:15,800 --> 01:26:17,510
you go through some function.

1744
01:26:17,510 --> 01:26:23,150
And conventionally, those functions are
called a getter function and a setter

1745
01:26:23,150 --> 01:26:23,900
function.

1746
01:26:23,900 --> 01:26:27,740
And why are we using functions or, in
this case, methods inside of a class?

1747
01:26:27,740 --> 01:26:31,220
Well, once you have functions,
those are just actions or verbs

1748
01:26:31,220 --> 01:26:32,780
that you and I can create ourselves.

1749
01:26:32,780 --> 01:26:36,410
We can put any error correction
I want in these functions

1750
01:26:36,410 --> 01:26:39,620
because it's code that's going
to get executed top to bottom.

1751
01:26:39,620 --> 01:26:46,760
So how can I now prevent the user from
setting the house to an invalid value?

1752
01:26:46,760 --> 01:26:51,710
Let me borrow some logic from before
rather than blindly do this-- just set

1753
01:26:51,710 --> 01:26:56,510
self.house equal to the house value
that's passed in-- let's add our error

1754
01:26:56,510 --> 01:26:57,390
checking there.

1755
01:26:57,390 --> 01:27:05,990
So if house is not in the following
list of Gryffindor or Hufflepuff

1756
01:27:05,990 --> 01:27:11,900
or Ravenclaw or
Slytherin, just as before,

1757
01:27:11,900 --> 01:27:15,770
let's go ahead and raise a value error,
just to signify that, uh-uh, something

1758
01:27:15,770 --> 01:27:16,520
has gone wrong.

1759
01:27:16,520 --> 01:27:17,540
I'll be more explicit.

1760
01:27:17,540 --> 01:27:21,740
I'll include a message like,
"invalid house," quote, unquote.

1761
01:27:21,740 --> 01:27:27,380
Otherwise, I'm going to proceed on,
now, line 21 to set self.house to house.

1762
01:27:27,380 --> 01:27:31,640
So I've just copied, if you will,
or retyped my error checking inside

1763
01:27:31,640 --> 01:27:33,530
of this so-called setter function.

1764
01:27:33,530 --> 01:27:34,880
Now, why have I done that?

1765
01:27:34,880 --> 01:27:38,660
Well, to be clear, whenever
the user or the programmer

1766
01:27:38,660 --> 01:27:43,580
writes code like this,
student.house equals, what's

1767
01:27:43,580 --> 01:27:47,390
about to happen magically
is Python will not just

1768
01:27:47,390 --> 01:27:51,140
let the programmer access student
house directly-- that attribute,

1769
01:27:51,140 --> 01:27:52,940
that instance variable, a.k.a.

1770
01:27:52,940 --> 01:27:54,080
self house.

1771
01:27:54,080 --> 01:27:58,040
It's instead going to
magically automatically call

1772
01:27:58,040 --> 01:28:00,020
this setter function for me.

1773
01:28:00,020 --> 01:28:01,920
How does Python know to do that?

1774
01:28:01,920 --> 01:28:06,860
Well, if it's see that, on the
left-hand side, there is self.house,

1775
01:28:06,860 --> 01:28:13,340
where house is the name of the getter or
setter, and then it sees an equal sign,

1776
01:28:13,340 --> 01:28:16,817
indicating assignment, that's just
enough of a visual clue to say,

1777
01:28:16,817 --> 01:28:17,400
wait a minute.

1778
01:28:17,400 --> 01:28:20,450
I'm not going to let you
access that attribute directly.

1779
01:28:20,450 --> 01:28:23,010
I'm going to use the setter instead.

1780
01:28:23,010 --> 01:28:23,510
Why?

1781
01:28:23,510 --> 01:28:25,490
Because the equal sign
means I'm trying to set.

1782
01:28:25,490 --> 01:28:29,460
I'm trying to assign a value from
right to left into that attribute.

1783
01:28:29,460 --> 01:28:31,700
So what Python's is
going to do automatically

1784
01:28:31,700 --> 01:28:33,290
is call this function for me.

1785
01:28:33,290 --> 01:28:37,910
And that's amazing because now I can
execute code-- an algorithm to check,

1786
01:28:37,910 --> 01:28:39,830
do I want to let the user--

1787
01:28:39,830 --> 01:28:43,250
the programmer set that
attribute to that value?

1788
01:28:43,250 --> 01:28:45,143
If not, I'm going to
raise a value error,

1789
01:28:45,143 --> 01:28:47,060
and you're just not going
to be able to do it.

1790
01:28:47,060 --> 01:28:48,690
If so fine.

1791
01:28:48,690 --> 01:28:50,610
I'll go ahead and set it for you.

1792
01:28:50,610 --> 01:28:53,180
But in order to do this, we
need a little more syntax.

1793
01:28:53,180 --> 01:28:56,600
And I'm going to get rid of my comment,
and I'm going to use that decorator.

1794
01:28:56,600 --> 01:29:00,800
I need to tell Python to
treat this method as a getter.

1795
01:29:00,800 --> 01:29:03,290
And then the syntax for the
setter is a little different.

1796
01:29:03,290 --> 01:29:05,690
You now say house.setter.

1797
01:29:05,690 --> 01:29:08,720
I wish one was getter
and the other was setter.

1798
01:29:08,720 --> 01:29:10,670
That's not the way they designed it.

1799
01:29:10,670 --> 01:29:15,500
When you want to define a getter, you
just say @property above the function.

1800
01:29:15,500 --> 01:29:20,060
And you name the function exactly
like you would like the property

1801
01:29:20,060 --> 01:29:22,220
to be called-- quote, unquote, "house."

1802
01:29:22,220 --> 01:29:25,640
Once you do that, you can
now use a new decorator

1803
01:29:25,640 --> 01:29:28,820
that's automatically created
for you called @house,

1804
01:29:28,820 --> 01:29:29,960
because I called it house.

1805
01:29:29,960 --> 01:29:32,630
And then you literally
say, @house.setter.

1806
01:29:32,630 --> 01:29:36,530
And this whole line, on
line 17, is a clue to Python

1807
01:29:36,530 --> 01:29:39,950
that here comes a function,
whose name is identical--

1808
01:29:39,950 --> 01:29:43,730
but notice that it takes two arguments--
both self, so you have access

1809
01:29:43,730 --> 01:29:46,430
to the contents of the object,
and house, which is just

1810
01:29:46,430 --> 01:29:51,230
going to be a str that comes from the
programmer from the human input return

1811
01:29:51,230 --> 01:29:55,160
value so that you can
set that value as well.

1812
01:29:55,160 --> 01:29:58,580
But there's one fix I
need to make now, here.

1813
01:29:58,580 --> 01:30:00,840
Everything else, I think, is still good.

1814
01:30:00,840 --> 01:30:02,450
However watch this.

1815
01:30:02,450 --> 01:30:05,700
I no longer need this error check here.

1816
01:30:05,700 --> 01:30:06,530
Why?

1817
01:30:06,530 --> 01:30:10,580
Because, if I scroll back
down to my code here,

1818
01:30:10,580 --> 01:30:17,450
I claimed a moment ago that code
like this, with student.house equals,

1819
01:30:17,450 --> 01:30:20,870
is going to automatically get
Python to call my setter for me.

1820
01:30:20,870 --> 01:30:21,860
Guess what?

1821
01:30:21,860 --> 01:30:27,080
Even up here, in my init method,
calling self.house equals

1822
01:30:27,080 --> 01:30:31,430
is also going to call my
setter method, which is amazing

1823
01:30:31,430 --> 01:30:37,310
because now I can keep all of my error
checking in one place in the setter,

1824
01:30:37,310 --> 01:30:42,050
and it will now get called either when
I create the object for the first time,

1825
01:30:42,050 --> 01:30:45,770
because of init, or
even if the programmer

1826
01:30:45,770 --> 01:30:50,570
tries to circumvent that init method
and change the value of this attribute,

1827
01:30:50,570 --> 01:30:52,250
my setter will also get called.

1828
01:30:52,250 --> 01:30:57,200
My setter will get called
any time I access .house.

1829
01:30:57,200 --> 01:30:59,660
But there's one fix I need to make.

1830
01:30:59,660 --> 01:31:04,160
Unfortunately, I have collided names.

1831
01:31:04,160 --> 01:31:09,680
Right now, if we go up here, on line
5, this is an instance variable.

1832
01:31:09,680 --> 01:31:13,550
It's a string inside of my self,
inside of the current student object,

1833
01:31:13,550 --> 01:31:14,300
called name.

1834
01:31:14,300 --> 01:31:18,170
And this is another instance
variable called house.

1835
01:31:18,170 --> 01:31:22,520
Unfortunately, if I have an instance
variable called name and house,

1836
01:31:22,520 --> 01:31:25,970
I cannot also have
functions called house.

1837
01:31:25,970 --> 01:31:27,140
They're going to collide.

1838
01:31:27,140 --> 01:31:28,260
You've got to decide.

1839
01:31:28,260 --> 01:31:30,470
Do you want the variable
to be called house?

1840
01:31:30,470 --> 01:31:32,930
Or do you want the function
to be called house?

1841
01:31:32,930 --> 01:31:35,420
Unfortunately, you can't
have both because now Python

1842
01:31:35,420 --> 01:31:37,250
is going to confuse one for the other.

1843
01:31:37,250 --> 01:31:40,490
So the conventional fix
for this is to do this--

1844
01:31:40,490 --> 01:31:46,460
to have the setter not store the
value that's passed in self.house,

1845
01:31:46,460 --> 01:31:50,330
but to use an almost identical name,
but to use a little indicator that

1846
01:31:50,330 --> 01:31:52,430
means you know doing this correctly.

1847
01:31:52,430 --> 01:31:54,890
You typically, by
convention, put an underscore

1848
01:31:54,890 --> 01:31:58,250
in front of the instance
variable's name.

1849
01:31:58,250 --> 01:32:02,400
And when you return it up here,
you similarly put an underscore.

1850
01:32:02,400 --> 01:32:07,730
So now, technically, my instance
variable is called _house,

1851
01:32:07,730 --> 01:32:12,990
but my property, which is a
fancier attribute, if you will,

1852
01:32:12,990 --> 01:32:16,130
is called house alone.

1853
01:32:16,130 --> 01:32:19,860
Huge amount of syntax, I know,
but it's a very powerful feature.

1854
01:32:19,860 --> 01:32:23,930
And again, this is why you can graduate
from dictionaries alone and have

1855
01:32:23,930 --> 01:32:26,720
so much more functionality
at your disposal.

1856
01:32:26,720 --> 01:32:30,110
Let me go ahead and clear my terminal
window and run Python of student.py,

1857
01:32:30,110 --> 01:32:31,670
Enter, name.

1858
01:32:31,670 --> 01:32:33,920
All right, let's go
ahead and type in Harry.

1859
01:32:33,920 --> 01:32:35,840
Let's go ahead and type in Gryffindor.

1860
01:32:35,840 --> 01:32:37,610
Crossing my fingers as always.

1861
01:32:37,610 --> 01:32:40,280
And now, look, "Invalid house."

1862
01:32:40,280 --> 01:32:41,460
This is a good thing.

1863
01:32:41,460 --> 01:32:41,960
Why?

1864
01:32:41,960 --> 01:32:45,170
Because, notice, in
my main function, I'm

1865
01:32:45,170 --> 01:32:50,330
still trying, maliciously, if
you will, to change Harry's house

1866
01:32:50,330 --> 01:32:52,190
to not be one of the four valid ones.

1867
01:32:52,190 --> 01:32:56,030
I'm trying to change it to his childhood
home of Number Four, Privet Drive.

1868
01:32:56,030 --> 01:33:00,410
But because Python knows that, wait
a minute, you're trying to assign--

1869
01:33:00,410 --> 01:33:01,910
that is, set a value--

1870
01:33:01,910 --> 01:33:05,420
and that value, a.k.a.
house, is now defined

1871
01:33:05,420 --> 01:33:09,560
as a property you're going to have to
go through the setter function instead

1872
01:33:09,560 --> 01:33:12,170
to even let you change that value.

1873
01:33:12,170 --> 01:33:15,410
And because I have
this raise ValueError.

1874
01:33:15,410 --> 01:33:18,110
If the house is not as
intended, you're not

1875
01:33:18,110 --> 01:33:20,670
going to be allowed to change
it to an invalid value.

1876
01:33:20,670 --> 01:33:23,660
So I'm protecting the data on the
way in, through the init method,

1877
01:33:23,660 --> 01:33:27,900
and I'm even defending the data
if you try to override it there.

1878
01:33:27,900 --> 01:33:30,410
So I think the only solution
for me, the programmer,

1879
01:33:30,410 --> 01:33:32,450
is, don't try to break my own code.

1880
01:33:32,450 --> 01:33:35,280
Let me remove that line because
it's just not going to work.

1881
01:33:35,280 --> 01:33:38,450
Let me run Python of student.py
and, again, type in Harry;

1882
01:33:38,450 --> 01:33:42,110
type in Gryffindor, Enter, and
Harry's indeed from Gryffindor.

1883
01:33:42,110 --> 01:33:46,910
If I did something incorrect,
like Harry from Number Four,

1884
01:33:46,910 --> 01:33:51,740
Privet Drive, Enter, we're again
going to see the value error

1885
01:33:51,740 --> 01:33:56,300
because my code just doesn't let
that value in via manual input now

1886
01:33:56,300 --> 01:33:59,740
or via that adversarial change.

1887
01:33:59,740 --> 01:34:01,160
All right, that was a lot.

1888
01:34:01,160 --> 01:34:06,413
But any question on properties?

1889
01:34:06,413 --> 01:34:08,330
AUDIENCE: Why we are
using getter then setter?

1890
01:34:08,330 --> 01:34:12,770
It's just for the purpose
so that we can find

1891
01:34:12,770 --> 01:34:15,008
that method, that function in our code.

1892
01:34:15,008 --> 01:34:18,050
DAVID J. MALAN: The reason that I'm
going through the trouble of defining

1893
01:34:18,050 --> 01:34:23,600
this getter or setter is because I want
to make sure that programmers cannot do

1894
01:34:23,600 --> 01:34:24,440
things like this.

1895
01:34:24,440 --> 01:34:26,720
If I'm going through the
trouble of validating

1896
01:34:26,720 --> 01:34:29,930
the attributes for
these student objects,

1897
01:34:29,930 --> 01:34:33,230
I don't want you to be able to go in
there and just change them at will.

1898
01:34:33,230 --> 01:34:35,820
I want to have some
control over that object

1899
01:34:35,820 --> 01:34:38,910
so that you can just trust that it's
going to be correct as designed.

1900
01:34:38,910 --> 01:34:42,230
So using a getter and
setter really just enables

1901
01:34:42,230 --> 01:34:46,640
Python to automatically detect when
you're trying to manually set a value.

1902
01:34:46,640 --> 01:34:49,527
The equal sign and the dot,
as I've highlighted here,

1903
01:34:49,527 --> 01:34:51,860
is enough of a clue to Python
to realize, wait a minute,

1904
01:34:51,860 --> 01:34:53,120
you're trying to set a value.

1905
01:34:53,120 --> 01:34:55,945
Let me see if this class
has a setter defined.

1906
01:34:55,945 --> 01:34:58,070
And if so, I'm going to
call that, and I'm not just

1907
01:34:58,070 --> 01:35:01,350
going to blindly assign the
value from right to left.

1908
01:35:01,350 --> 01:35:03,770
So it's just giving me more control.

1909
01:35:03,770 --> 01:35:06,245
Other questions on properties.

1910
01:35:06,245 --> 01:35:10,670
AUDIENCE: When we use getters,
we just have just one argument.

1911
01:35:10,670 --> 01:35:14,510
And if we use setters, it's
always going to be two arguments?

1912
01:35:14,510 --> 01:35:15,520
Is that normal?

1913
01:35:15,520 --> 01:35:16,520
DAVID J. MALAN: Correct.

1914
01:35:16,520 --> 01:35:19,040
It's always going to
be one argument-- self

1915
01:35:19,040 --> 01:35:23,840
for the getter, two arguments for
the setter-- self and something else.

1916
01:35:23,840 --> 01:35:26,600
And the intuition for that
is, if you're getting a value,

1917
01:35:26,600 --> 01:35:30,080
you don't need to pass anything else
in because you already know the object.

1918
01:35:30,080 --> 01:35:31,520
It's called student in this case.

1919
01:35:31,520 --> 01:35:33,990
So you're just going to get
the value of that property.

1920
01:35:33,990 --> 01:35:36,680
But if you want to set the
property to something else,

1921
01:35:36,680 --> 01:35:38,320
you've got to pass in that argument.

1922
01:35:38,320 --> 01:35:40,820
You've got to pass in the value
to which you want to set it.

1923
01:35:40,820 --> 01:35:42,500
So it's always 0 or 1.

1924
01:35:42,500 --> 01:35:48,740
However, you see it as 1 or 2 because,
again, any function inside of a class,

1925
01:35:48,740 --> 01:35:49,250
a.k.a.

1926
01:35:49,250 --> 01:35:53,480
a method, is going to be automatically
passed self so that you have access

1927
01:35:53,480 --> 01:35:56,400
to that current object in memory.

1928
01:35:56,400 --> 01:35:58,925
How about one other
question on properties?

1929
01:35:58,925 --> 01:36:02,987
AUDIENCE: Why didn't we use the
same underscore house init method?

1930
01:36:02,987 --> 01:36:04,320
DAVID J. MALAN: A good question.

1931
01:36:04,320 --> 01:36:07,970
So even though I'm using the
underscore house here, in my setter,

1932
01:36:07,970 --> 01:36:10,340
and the underscore house
here, in my getter,

1933
01:36:10,340 --> 01:36:13,170
I deliberately did not use it up here.

1934
01:36:13,170 --> 01:36:18,560
The reason for that is that, by
using self.house and this equal sign,

1935
01:36:18,560 --> 01:36:21,590
that's the same pattern that
I want Python to recognize.

1936
01:36:21,590 --> 01:36:24,410
I want Python to
automatically call the setter,

1937
01:36:24,410 --> 01:36:28,010
even when I'm passing in the
house via the init method.

1938
01:36:28,010 --> 01:36:32,660
If I were to change this to do this,
that would circumvent the setter,

1939
01:36:32,660 --> 01:36:36,270
and now there's no error
checking in init whatsoever.

1940
01:36:36,270 --> 01:36:37,550
So it's such a fine line.

1941
01:36:37,550 --> 01:36:41,270
The only thing standing between us and
error checking or no error checking

1942
01:36:41,270 --> 01:36:43,970
is the presence or absence
of this underscore.

1943
01:36:43,970 --> 01:36:45,830
But that's typically the convention.

1944
01:36:45,830 --> 01:36:48,590
By not using the
underscore there, make sure

1945
01:36:48,590 --> 01:36:50,900
that even that assignment
goes through the setter

1946
01:36:50,900 --> 01:36:53,630
so that, honestly, I, don't have
to copy paste the same error

1947
01:36:53,630 --> 01:36:54,800
checking in two places.

1948
01:36:54,800 --> 01:36:56,600
I can put it just in the setter.

1949
01:36:56,600 --> 01:37:00,020
So it's a better design, and that's
why I manually retyped it at first,

1950
01:37:00,020 --> 01:37:02,390
but then I deleted it from init.

1951
01:37:02,390 --> 01:37:05,840
Well, allow me to propose that we
make one other change to this file.

1952
01:37:05,840 --> 01:37:09,900
Might as well go ahead and define
a property for name as well.

1953
01:37:09,900 --> 01:37:12,650
And let me go ahead and do this--
maybe above the house property

1954
01:37:12,650 --> 01:37:16,250
just to keep things in the same
order as I defined them earlier.

1955
01:37:16,250 --> 01:37:18,570
Let me give myself another property.

1956
01:37:18,570 --> 01:37:20,330
This one is going to be called name.

1957
01:37:20,330 --> 01:37:22,790
It's going to take one argument
called self, as always.

1958
01:37:22,790 --> 01:37:26,842
And this one, very similarly, is
just going to return self._name.

1959
01:37:26,842 --> 01:37:28,550
So I'm going to
anticipate that I'm going

1960
01:37:28,550 --> 01:37:32,360
to have to rename name also so that
I don't have that same collision as

1961
01:37:32,360 --> 01:37:33,080
before.

1962
01:37:33,080 --> 01:37:36,740
But now let me go ahead
and define another setter--

1963
01:37:36,740 --> 01:37:37,940
this one for name.

1964
01:37:37,940 --> 01:37:40,640
So the convention is @name.setter.

1965
01:37:40,640 --> 01:37:41,600
Why name?

1966
01:37:41,600 --> 01:37:45,140
Because the property I just
created is called name.

1967
01:37:45,140 --> 01:37:50,030
So the getter and setter work in
conjunction in this way, if you will.

1968
01:37:50,030 --> 01:37:53,480
Let me go down under that name
setter and define another function,

1969
01:37:53,480 --> 01:37:54,590
also called name.

1970
01:37:54,590 --> 01:37:57,000
But the key thing here is
that it's not identical.

1971
01:37:57,000 --> 01:38:01,190
It's not the exact same function name
and the exact same number of arguments.

1972
01:38:01,190 --> 01:38:03,700
The setter, again,
takes a second argument.

1973
01:38:03,700 --> 01:38:05,450
And I can call it
anything I want, but I'm

1974
01:38:05,450 --> 01:38:07,950
going to call it name because
that's what's being passed in.

1975
01:38:07,950 --> 01:38:10,250
And I'm going to put
my error checking here.

1976
01:38:10,250 --> 01:38:14,750
If not name, just like we used to do,
let's go ahead and raise a value error,

1977
01:38:14,750 --> 01:38:19,970
and let's put an explanatory message
like "Missing name," quote, unquote.

1978
01:38:19,970 --> 01:38:26,450
Otherwise, let's go ahead and
update self._name to equal name.

1979
01:38:26,450 --> 01:38:29,690
And I don't have to change
init except to get rid

1980
01:38:29,690 --> 01:38:33,530
of this duplicate error
checking now because, again,

1981
01:38:33,530 --> 01:38:38,360
if I use self.name equals here
and self.house equals here

1982
01:38:38,360 --> 01:38:41,120
with no underscore, both
of those assignments

1983
01:38:41,120 --> 01:38:44,600
are going to go through my
two setter functions now.

1984
01:38:44,600 --> 01:38:46,640
Before we run this, let
me go ahead and remove

1985
01:38:46,640 --> 01:38:50,000
this adversarial code, which we know
won't work because we're catching it.

1986
01:38:50,000 --> 01:38:53,600
Let me go back down to my terminal
window and run Python of student.py,

1987
01:38:53,600 --> 01:38:54,140
Enter.

1988
01:38:54,140 --> 01:38:55,160
Let's type in Harry.

1989
01:38:55,160 --> 01:38:56,330
Let's type in Gryffindor.

1990
01:38:56,330 --> 01:38:57,900
And that seems to work.

1991
01:38:57,900 --> 01:39:00,650
Let's try though, again,
to run Python of student.py

1992
01:39:00,650 --> 01:39:03,920
with Harry from Number
Four, Privet Drive.

1993
01:39:03,920 --> 01:39:05,640
This will not work.

1994
01:39:05,640 --> 01:39:08,520
A value error with invalid
house, because that's not

1995
01:39:08,520 --> 01:39:09,990
one of the four Hogwarts houses.

1996
01:39:09,990 --> 01:39:12,240
And now, for good measure,
let's run it one more time.

1997
01:39:12,240 --> 01:39:13,780
And let's not even give it a name.

1998
01:39:13,780 --> 01:39:15,570
Let's just hit Enter when prompted.

1999
01:39:15,570 --> 01:39:17,072
I can type anything for the house.

2000
01:39:17,072 --> 01:39:19,155
I'll go ahead and still
give it Gryffindor, Enter.

2001
01:39:19,155 --> 01:39:24,150
And now we get another value error,
but this one is for missing name.

2002
01:39:24,150 --> 01:39:27,720
So we seem, now, to have all the
more of a defense mechanism in place

2003
01:39:27,720 --> 01:39:30,030
to ensure that name is as we expect.

2004
01:39:30,030 --> 01:39:32,220
It's got to have some
value that's not blank.

2005
01:39:32,220 --> 01:39:33,720
And house is as we expect.

2006
01:39:33,720 --> 01:39:36,210
It's got to have one
of those four values.

2007
01:39:36,210 --> 01:39:39,210
But at the risk of
bursting everyone's bubble

2008
01:39:39,210 --> 01:39:43,170
and making you wonder, why did
we just go through all of that,

2009
01:39:43,170 --> 01:39:50,080
unfortunately Python really focuses
on conventions, not hard constraints.

2010
01:39:50,080 --> 01:39:51,510
And by that, I mean this.

2011
01:39:51,510 --> 01:39:56,430
If I go back into my main function
after I've gotten a student on line 30

2012
01:39:56,430 --> 01:40:01,590
and I try to adversarially do something
like this-- student.house equals

2013
01:40:01,590 --> 01:40:04,830
"Number Four, Privet
Drive," we know this

2014
01:40:04,830 --> 01:40:08,610
won't work because my setter for
house is going to catch this.

2015
01:40:08,610 --> 01:40:09,540
Watch again.

2016
01:40:09,540 --> 01:40:12,060
Python of student.py.

2017
01:40:12,060 --> 01:40:13,230
Let's type in Harry.

2018
01:40:13,230 --> 01:40:15,750
Let's type in Gryffindor,
which will at least pass

2019
01:40:15,750 --> 01:40:18,180
our check that's induced by init.

2020
01:40:18,180 --> 01:40:23,250
But line 31 is going to trigger
the same setter to be called,

2021
01:40:23,250 --> 01:40:26,790
and we're going to raise a value
error saying "Invalid house."

2022
01:40:26,790 --> 01:40:29,460
Unfortunately, and if
some of you are already

2023
01:40:29,460 --> 01:40:33,570
thinking a little adversarially,
tragically, look what you can do.

2024
01:40:33,570 --> 01:40:36,690
You can change .house to be ._house.

2025
01:40:36,690 --> 01:40:37,230
Why?

2026
01:40:37,230 --> 01:40:41,640
Well, the instance variable
is now called _house.

2027
01:40:41,640 --> 01:40:44,340
The property is called
house, no underscore.

2028
01:40:44,340 --> 01:40:50,265
But the underlying attribute implemented
as an instance variable is still called

2029
01:40:50,265 --> 01:40:51,000
_house.

2030
01:40:51,000 --> 01:40:54,750
And tragically, Python of student.py.

2031
01:40:54,750 --> 01:40:56,190
Let's type in Harry.

2032
01:40:56,190 --> 01:40:58,570
Let's type in Gryffindor,
which is correct.

2033
01:40:58,570 --> 01:41:00,180
But watch what happens now.

2034
01:41:00,180 --> 01:41:01,530
Oh, my God.

2035
01:41:01,530 --> 01:41:03,210
We slip through.

2036
01:41:03,210 --> 01:41:06,900
So what was the point of
all of this emphasis from me

2037
01:41:06,900 --> 01:41:10,770
on doing things the "right way," the
Python quick way by having this getter

2038
01:41:10,770 --> 01:41:11,520
and setter?

2039
01:41:11,520 --> 01:41:14,430
Well, unlike languages
like Java, that just

2040
01:41:14,430 --> 01:41:17,430
prevent you from doing
things like this, Python

2041
01:41:17,430 --> 01:41:20,250
itself allows you to specify that
certain instance variables can

2042
01:41:20,250 --> 01:41:23,880
be public and accessible to
anyone's code, or protected,

2043
01:41:23,880 --> 01:41:27,990
or private, which means that no one else
should be able to change these values.

2044
01:41:27,990 --> 01:41:31,320
In the world of Python,
it's just the honor system.

2045
01:41:31,320 --> 01:41:33,630
It's not baked into the
language itself that there's

2046
01:41:33,630 --> 01:41:36,720
a notion of visibility, public or
private or even somewhere in between

2047
01:41:36,720 --> 01:41:37,440
protected.

2048
01:41:37,440 --> 01:41:39,430
Instead, you're on the honor system.

2049
01:41:39,430 --> 01:41:42,870
And the convention
generally is, if an instance

2050
01:41:42,870 --> 01:41:46,950
variable starts with an
underscore, please don't touch it.

2051
01:41:46,950 --> 01:41:47,910
Just don't.

2052
01:41:47,910 --> 01:41:50,970
That's on you if you touch
that variable and break things.

2053
01:41:50,970 --> 01:41:53,190
The underscore is meant
to signify a convention

2054
01:41:53,190 --> 01:41:55,798
that this is meant to be
"private," but it really just

2055
01:41:55,798 --> 01:41:57,090
means, please don't touch this.

2056
01:41:57,090 --> 01:41:59,160
Sometimes, if there's two
underscores, which you can use,

2057
01:41:59,160 --> 01:42:01,740
too, that's an even greater
effort by programmers to say,

2058
01:42:01,740 --> 01:42:03,190
really don't touch this.

2059
01:42:03,190 --> 01:42:06,390
But technically speaking, there's
nothing stopping you or me

2060
01:42:06,390 --> 01:42:10,080
from circumventing all of these
mechanisms, these properties,

2061
01:42:10,080 --> 01:42:11,340
these getters and setters.

2062
01:42:11,340 --> 01:42:13,470
We're ultimately just
on the honor system

2063
01:42:13,470 --> 01:42:17,490
not to do so when we see instance
variables prefixed with one,

2064
01:42:17,490 --> 01:42:19,260
or perhaps even two underscores.

2065
01:42:19,260 --> 01:42:21,790
All right, so this is
a lot all at once--

2066
01:42:21,790 --> 01:42:24,090
this Introduction to
object-oriented programming.

2067
01:42:24,090 --> 01:42:27,360
But it might come as quite a
surprise that, even though we

2068
01:42:27,360 --> 01:42:31,650
might have identified OOP
by name in weeks past,

2069
01:42:31,650 --> 01:42:36,687
we've all been using classes and
objects for weeks now in this class.

2070
01:42:36,687 --> 01:42:40,020
In fact, if you think back on one of the
very first things we did in this class,

2071
01:42:40,020 --> 01:42:43,300
we used integers and just
got integers from the user.

2072
01:42:43,300 --> 01:42:44,980
But if you haven't already--

2073
01:42:44,980 --> 01:42:48,720
if you go and dig into the
documentation for integers,

2074
01:42:48,720 --> 01:42:51,120
which, again, lives
at this URL here, you

2075
01:42:51,120 --> 01:42:57,390
would actually find that int itself
is and has been for weeks a class.

2076
01:42:57,390 --> 01:43:01,740
And in fact, this is the signature
of the constructor call for an int,

2077
01:43:01,740 --> 01:43:06,330
whereby you pass in x, like a number,
quote, unquote, "50" or, quote,

2078
01:43:06,330 --> 01:43:09,660
unquote, something else-- you
pass in optionally the base--

2079
01:43:09,660 --> 01:43:12,960
10 for decimal, 2 for
binary or anything else.

2080
01:43:12,960 --> 01:43:17,400
And that int function will actually
return to you, all this time,

2081
01:43:17,400 --> 01:43:20,820
an object of type int.

2082
01:43:20,820 --> 01:43:23,280
That is to say int is a class.

2083
01:43:23,280 --> 01:43:26,460
It is a template, a blueprint
for creating integers in memory.

2084
01:43:26,460 --> 01:43:30,330
And any time you and I have converted
a string, for, instance to an int,

2085
01:43:30,330 --> 01:43:35,160
you and I have been creating an
object of type int that was calling,

2086
01:43:35,160 --> 01:43:39,098
apparently, the underscore underscore,
init, underscore underscore method,

2087
01:43:39,098 --> 01:43:40,890
that someone else--
the authors of Python--

2088
01:43:40,890 --> 01:43:43,710
wrote to give us back
that proper integer.

2089
01:43:43,710 --> 01:43:47,730
Besides that, if you can believe
it, strs, strings in Python

2090
01:43:47,730 --> 01:43:51,190
have been classes since the
first week of this class as well.

2091
01:43:51,190 --> 01:43:53,190
If you look up the
documentation for a str,

2092
01:43:53,190 --> 01:43:57,750
which lives at a similar URL there, you
will find that, when you instantiate--

2093
01:43:57,750 --> 01:43:59,310
that is, create a str--

2094
01:43:59,310 --> 01:44:03,390
it takes, optionally, a
parameter called object here,

2095
01:44:03,390 --> 01:44:05,880
the default value of which
is just, quote, unquote,

2096
01:44:05,880 --> 01:44:09,190
which allows you to create, in effect,
an empty string, a blank string,

2097
01:44:09,190 --> 01:44:09,690
if you will.

2098
01:44:09,690 --> 01:44:13,740
But any time you and I have created
strs or even used explicitly

2099
01:44:13,740 --> 01:44:18,540
the str function, you are getting
back an object of type str.

2100
01:44:18,540 --> 01:44:23,580
Any time you and I have forced a string
to lowercase per the documentation,

2101
01:44:23,580 --> 01:44:29,250
using syntax like this, you and I
have been taking an object of type str

2102
01:44:29,250 --> 01:44:34,350
and forcing it all to lowercase
by calling a method called lower,

2103
01:44:34,350 --> 01:44:39,180
a method that the authors of
Python built into the str class,

2104
01:44:39,180 --> 01:44:42,270
but it's been there from the get-go,
so this notion of methods is not

2105
01:44:42,270 --> 01:44:43,023
even new today.

2106
01:44:43,023 --> 01:44:44,940
You wouldn't have been
doing it for this long.

2107
01:44:44,940 --> 01:44:48,630
If you've ever called strip to remove
the leading and the trailing whitespace

2108
01:44:48,630 --> 01:44:53,370
from a string in Python, you are calling
another method that came with Python--

2109
01:44:53,370 --> 01:44:54,960
written by the authors of Python.

2110
01:44:54,960 --> 01:44:57,210
And even though we didn't
call it a class at the time,

2111
01:44:57,210 --> 01:45:00,900
a str, all this time, has been a class.

2112
01:45:00,900 --> 01:45:04,770
And instances of strings
are, themselves, objects.

2113
01:45:04,770 --> 01:45:07,500
And those objects come
therefore with these functions

2114
01:45:07,500 --> 01:45:10,680
built in-- a.k.a. methods that
allow us to do things like force

2115
01:45:10,680 --> 01:45:14,010
to lowercase and strip whitespace
from the beginning and end.

2116
01:45:14,010 --> 01:45:15,180
Let's do another.

2117
01:45:15,180 --> 01:45:20,730
list-- any time you've created a
list, either syntactically with square

2118
01:45:20,730 --> 01:45:24,760
brackets or literally with L-I-S-T,
open parentheses, closed parentheses,

2119
01:45:24,760 --> 01:45:27,570
which is also possible, you
have been using a class.

2120
01:45:27,570 --> 01:45:31,050
If you go to the documentation
for list, at this similar URL

2121
01:45:31,050 --> 01:45:35,310
here, or more specifically, the
tutorial on lists here in Python,

2122
01:45:35,310 --> 01:45:38,400
you will see that a
list is and has been,

2123
01:45:38,400 --> 01:45:42,150
since the early weeks of
this class, a class itself.

2124
01:45:42,150 --> 01:45:47,370
And that list class takes, as
part of its initialization,

2125
01:45:47,370 --> 01:45:52,200
an optional iterable, something that
can be iterated over-- like 1, 2, 3,

2126
01:45:52,200 --> 01:45:55,350
or some list of values,
and you can then get back

2127
01:45:55,350 --> 01:45:58,620
a list containing those
same iterable values.

2128
01:45:58,620 --> 01:46:01,860
If you've ever appended something
to a list in this class,

2129
01:46:01,860 --> 01:46:03,780
as I have myself in
the past, you've been

2130
01:46:03,780 --> 01:46:08,610
using a method called append that comes
with the list class that, per the x

2131
01:46:08,610 --> 01:46:11,760
here, takes an argument that
allows you to append something

2132
01:46:11,760 --> 01:46:14,040
to the current list, a.k.a.

2133
01:46:14,040 --> 01:46:16,350
Self in the context of that method.

2134
01:46:16,350 --> 01:46:17,610
We can do this all day long.

2135
01:46:17,610 --> 01:46:20,820
If you've used a dictionary
or a dict in Python--

2136
01:46:20,820 --> 01:46:24,330
I've actually, all this time,
been calling them dict objects,

2137
01:46:24,330 --> 01:46:25,710
and that's for a reason.

2138
01:46:25,710 --> 01:46:28,470
dict itself is a class
in Python, if you pull up

2139
01:46:28,470 --> 01:46:30,390
its official documentation here.

2140
01:46:30,390 --> 01:46:34,590
And you'll see that it is defined,
indeed, as itself a class.

2141
01:46:34,590 --> 01:46:36,532
And that class comes
with methods as well.

2142
01:46:36,532 --> 01:46:38,490
And so any time we've
manipulated dictionaries,

2143
01:46:38,490 --> 01:46:43,120
we've been underneath the hood,
using all of those same methods.

2144
01:46:43,120 --> 01:46:45,420
And in fact, we can see this
if we're really curious.

2145
01:46:45,420 --> 01:46:48,580
Let me go back over here to VS Code.

2146
01:46:48,580 --> 01:46:51,450
And let me go ahead and create a
new file that, very simply, does

2147
01:46:51,450 --> 01:46:53,717
something play around with data types.

2148
01:46:53,717 --> 01:46:56,050
And let me go ahead and create
a new file, for instance,

2149
01:46:56,050 --> 01:47:01,860
called, say, type.py, just so that I
can poke around inside of some values.

2150
01:47:01,860 --> 01:47:05,560
And in type.py, I'm just
going to go ahead and do this.

2151
01:47:05,560 --> 01:47:09,570
I'm going to print out whatever
the type is of, say, the number 50.

2152
01:47:09,570 --> 01:47:12,720
And This is a function you've not
necessarily seen me use already,

2153
01:47:12,720 --> 01:47:15,690
and it's not one you would
frequently use in your own code.

2154
01:47:15,690 --> 01:47:18,150
There are other ways to
detect, if you need to,

2155
01:47:18,150 --> 01:47:19,840
what the type is of a variable.

2156
01:47:19,840 --> 01:47:24,990
But in this case, type of 50 is just
going to tell me and then print out

2157
01:47:24,990 --> 01:47:27,040
what the data type is of that value.

2158
01:47:27,040 --> 01:47:29,640
Now, hopefully, all of us
could guess that 50 is indeed

2159
01:47:29,640 --> 01:47:30,660
going to be an integer--

2160
01:47:30,660 --> 01:47:32,885
that is, an int, but we
can see it in this way.

2161
01:47:32,885 --> 01:47:35,760
And this, too, is what's powerful
about knowing a bit of programming.

2162
01:47:35,760 --> 01:47:37,635
If you want to know the
answer to a question,

2163
01:47:37,635 --> 01:47:39,430
just try it out, like I am here.

2164
01:47:39,430 --> 01:47:42,330
So let me go ahead and run
Python of type.py, Enter.

2165
01:47:42,330 --> 01:47:43,410
And there it is.

2166
01:47:43,410 --> 01:47:48,670
When you print out the type of the
number 50, you'll see on the screen,

2167
01:47:48,670 --> 01:47:51,840
in this cryptic syntax, class 'int.'

2168
01:47:51,840 --> 01:47:54,730
This is not something that you
probably want to show to the user.

2169
01:47:54,730 --> 01:47:57,840
But if you yourself just want to
poke around and see what's going on

2170
01:47:57,840 --> 01:48:00,390
or maybe use that
information somehow, it's

2171
01:48:00,390 --> 01:48:04,030
certainly at your disposal to
use this type function for that.

2172
01:48:04,030 --> 01:48:05,790
Let's change it around a little bit.

2173
01:48:05,790 --> 01:48:09,570
Instead of passing as the
argument to type 50, as an int,

2174
01:48:09,570 --> 01:48:12,510
let's type something also
familiar, like "hello, world,"

2175
01:48:12,510 --> 01:48:14,370
in double or single quotes.

2176
01:48:14,370 --> 01:48:16,740
Let me go back to my terminal
window, clear the screen,

2177
01:48:16,740 --> 01:48:18,420
and run Python of type.py again.

2178
01:48:18,420 --> 01:48:20,550
And now, voila, there it is.

2179
01:48:20,550 --> 01:48:23,940
All this time, a str is also a class.

2180
01:48:23,940 --> 01:48:25,550
We can do this a few more times, For.

2181
01:48:25,550 --> 01:48:26,050
Instance.

2182
01:48:26,050 --> 01:48:30,090
Let's go ahead and change "hello,
world" to just an empty list--

2183
01:48:30,090 --> 01:48:32,520
open square bracket,
closed square bracket.

2184
01:48:32,520 --> 01:48:34,583
And this is starting to
look a little cryptic,

2185
01:48:34,583 --> 01:48:36,000
but, again, notice what I'm doing.

2186
01:48:36,000 --> 01:48:37,920
In square brackets is an empty list.

2187
01:48:37,920 --> 01:48:39,310
We've done that before.

2188
01:48:39,310 --> 01:48:42,810
That is the sole argument
to this new type function.

2189
01:48:42,810 --> 01:48:45,880
And that's just being
passed to the print function

2190
01:48:45,880 --> 01:48:49,680
so that the return value of
type is the argument to print.

2191
01:48:49,680 --> 01:48:53,760
So if I now run this code,
Python of type.py, there it is.

2192
01:48:53,760 --> 01:48:55,650
A list is a class, too.

2193
01:48:55,650 --> 01:48:59,190
You might recall that I said that
you can also create an empty list

2194
01:48:59,190 --> 01:49:02,770
by literally doing list ().

2195
01:49:02,770 --> 01:49:05,580
This is a bit of an
inconsistency, as we can now

2196
01:49:05,580 --> 01:49:11,160
identify that int and str and now list--
they're technically all lowercase.

2197
01:49:11,160 --> 01:49:15,930
And I went to great lengths of creating
my student class to have that capital

2198
01:49:15,930 --> 01:49:17,790
S. That's a convention.

2199
01:49:17,790 --> 01:49:22,440
Because int and stir and list
and others come with Python,

2200
01:49:22,440 --> 01:49:26,640
they decided to make their built-in data
types-- even though they're classes--

2201
01:49:26,640 --> 01:49:27,600
all lowercase.

2202
01:49:27,600 --> 01:49:30,960
But the convention, the recommendation
in the Python community when creating

2203
01:49:30,960 --> 01:49:34,740
your classes is to capitalize
the first letter, as I did,

2204
01:49:34,740 --> 01:49:41,730
in something like Student, capital S.
But list () is identical to really just

2205
01:49:41,730 --> 01:49:43,230
two empty square brackets.

2206
01:49:43,230 --> 01:49:47,640
If I clear my screen and run type.py
again, you see the exact same thing.

2207
01:49:47,640 --> 01:49:48,960
The class is called list.

2208
01:49:48,960 --> 01:49:50,250
Let's do one more.

2209
01:49:50,250 --> 01:49:54,240
Let me change the list to be not
square brackets but curly braces.

2210
01:49:54,240 --> 01:49:55,320
We've done this before.

2211
01:49:55,320 --> 01:49:59,140
Any time I've done two curly braces with
nothing in between, this, of course,

2212
01:49:59,140 --> 01:50:02,670
is an empty dictionary, or
a dict object in Python.

2213
01:50:02,670 --> 01:50:03,960
Well, we can see that now.

2214
01:50:03,960 --> 01:50:06,720
Let me clear my screen, run
Python of type.py, Enter,

2215
01:50:06,720 --> 01:50:08,880
and there it is-- class 'dict."

2216
01:50:08,880 --> 01:50:10,650
It's been there this whole time.

2217
01:50:10,650 --> 01:50:13,560
We just didn't call it
a class until today.

2218
01:50:13,560 --> 01:50:15,840
I can similarly do this one explicitly.

2219
01:50:15,840 --> 01:50:19,710
Instead of two curly braces, let's
write out dict with two parentheses.

2220
01:50:19,710 --> 01:50:22,770
Now we have a lot of parentheses
again, like with list.

2221
01:50:22,770 --> 01:50:26,460
But this is just making even more
clear that the type of a dict object

2222
01:50:26,460 --> 01:50:29,560
is indeed the class, dict, itself.

2223
01:50:29,560 --> 01:50:33,570
So this is to say that, as new as
a lot of today's idea and syntax,

2224
01:50:33,570 --> 01:50:36,900
might be you've actually been using
it, perhaps unbeknownst to you,

2225
01:50:36,900 --> 01:50:37,950
for weeks now.

2226
01:50:37,950 --> 01:50:40,608
We now just have
terminology to describe what

2227
01:50:40,608 --> 01:50:42,150
it is we've been doing all this time.

2228
01:50:42,150 --> 01:50:45,390
And you now have the
expressiveness, with some practice,

2229
01:50:45,390 --> 01:50:49,980
to create your own classes, inside of
which are your own instance variables,

2230
01:50:49,980 --> 01:50:54,900
perhaps wrapped with those properties
and your own instance methods.

2231
01:50:54,900 --> 01:50:58,350
But it turns out there's other
types of methods in the world.

2232
01:50:58,350 --> 01:51:00,600
Thus far, I've been
deliberate in calling

2233
01:51:00,600 --> 01:51:05,580
all of our variables instance variables
and all of our methods instance

2234
01:51:05,580 --> 01:51:06,330
methods.

2235
01:51:06,330 --> 01:51:11,550
It turns out there's other types
of variables and methods out there,

2236
01:51:11,550 --> 01:51:14,100
and one of those is
called class methods.

2237
01:51:14,100 --> 01:51:19,530
It turns out that sometimes it's
not really necessary or sensible

2238
01:51:19,530 --> 01:51:23,530
to associate a function
with objects of a class,

2239
01:51:23,530 --> 01:51:26,190
but rather with the class itself.

2240
01:51:26,190 --> 01:51:31,050
An instance, or an object of a class,
is a very specific incarnation thereof.

2241
01:51:31,050 --> 01:51:34,525
Again, on that neighborhood that has
a lot of identical looking buildings,

2242
01:51:34,525 --> 01:51:37,650
but they're all a little bit different
because of different paint and such,

2243
01:51:37,650 --> 01:51:40,890
sometimes you might have
functionality related

2244
01:51:40,890 --> 01:51:44,760
to each of those houses that
isn't distinct or unique for any

2245
01:51:44,760 --> 01:51:45,540
of the houses.

2246
01:51:45,540 --> 01:51:48,570
It's functionality that's
going to be exactly the same no

2247
01:51:48,570 --> 01:51:50,430
matter the house in question.

2248
01:51:50,430 --> 01:51:52,770
Same in the world of
object-oriented programming.

2249
01:51:52,770 --> 01:51:55,590
Sometimes you want some
functionality, some action

2250
01:51:55,590 --> 01:52:00,720
to be associated with the class itself,
no matter what the specific object's

2251
01:52:00,720 --> 01:52:03,540
own values or instance variables are.

2252
01:52:03,540 --> 01:52:07,320
And for that, we have a
keyword called @classmethod.

2253
01:52:07,320 --> 01:52:09,660
This is another
decorator-- really, another

2254
01:52:09,660 --> 01:52:14,610
function-- that you can use to
specify that this method is not,

2255
01:52:14,610 --> 01:52:17,430
by default, implicitly
an instance method that

2256
01:52:17,430 --> 01:52:20,020
has access to self, the object itself.

2257
01:52:20,020 --> 01:52:22,950
This is a class method that's
not going to have access to self,

2258
01:52:22,950 --> 01:52:25,380
but it does know what class it's inside.

2259
01:52:25,380 --> 01:52:26,830
So what do I mean by this?

2260
01:52:26,830 --> 01:52:28,620
Well, let me go back to VS Code here.

2261
01:52:28,620 --> 01:52:32,520
And let me propose that we create
a new file this time implementing

2262
01:52:32,520 --> 01:52:36,180
the notion of a-- the sorting hat,
from the world of Harry Potter as well,

2263
01:52:36,180 --> 01:52:37,260
to stay on theme.

2264
01:52:37,260 --> 01:52:39,870
I'm going to go ahead
and run code of hat.py.

2265
01:52:39,870 --> 01:52:43,230
And in hat.py, let's implement
the notion of the sorting hat.

2266
01:52:43,230 --> 01:52:45,810
If unfamiliar in the
books and in the films

2267
01:52:45,810 --> 01:52:48,540
there is literally a
pointy hat that, when

2268
01:52:48,540 --> 01:52:52,140
a student put it's on their head,
that sorting hat, so to speak,

2269
01:52:52,140 --> 01:52:54,930
decides what house the
student is in-- whether it's

2270
01:52:54,930 --> 01:52:56,620
Gryffindor or something else.

2271
01:52:56,620 --> 01:53:00,690
So let's implement, in code, this
notion of a sorting hat such that,

2272
01:53:00,690 --> 01:53:04,470
when we pass to the sorting hat the
name of a student, like, quote, unquote,

2273
01:53:04,470 --> 01:53:07,290
"Harry" this sorting
hat, implemented in code,

2274
01:53:07,290 --> 01:53:11,250
will tell us what house
that student should be in.

2275
01:53:11,250 --> 01:53:12,960
Well, let's go ahead and do this.

2276
01:53:12,960 --> 01:53:17,910
In hat.py, first, let's go ahead
and define a class called hat,

2277
01:53:17,910 --> 01:53:20,542
and then let's get back
to implementing it itself.

2278
01:53:20,542 --> 01:53:23,250
And I find this to be a helpful
technique, not just with teaching

2279
01:53:23,250 --> 01:53:24,600
but when writing code.

2280
01:53:24,600 --> 01:53:26,520
I know I want a hat class.

2281
01:53:26,520 --> 01:53:28,770
I don't necessarily know
what I want it to do yet,

2282
01:53:28,770 --> 01:53:31,290
so I'm going to create this
placeholder, dot, dot, dot,

2283
01:53:31,290 --> 01:53:32,980
so I'll come back to that.

2284
01:53:32,980 --> 01:53:36,210
Let's now try to use this
class as though it existed.

2285
01:53:36,210 --> 01:53:39,450
And from there, I perhaps
can realize exactly what

2286
01:53:39,450 --> 01:53:42,820
functionality that class needs
to have to support my use case.

2287
01:53:42,820 --> 01:53:45,930
Let me go ahead and create a
variable called hat in all lowercase

2288
01:53:45,930 --> 01:53:48,720
and instantiate a hat object.

2289
01:53:48,720 --> 01:53:52,260
So no matter what the hat
class ends up looking like,

2290
01:53:52,260 --> 01:53:55,350
this is the common
syntax for instantiating

2291
01:53:55,350 --> 01:53:57,120
an object of a certain class.

2292
01:53:57,120 --> 01:54:00,150
In the past, we saw
student, all lowercase,

2293
01:54:00,150 --> 01:54:03,930
equals capital Student, open
parenthesis, close parentheses,

2294
01:54:03,930 --> 01:54:06,600
and then eventually, we added
in things like name and house.

2295
01:54:06,600 --> 01:54:10,590
For now, let's assume that the hat
is much simpler than a student,

2296
01:54:10,590 --> 01:54:12,700
and it only has sorting capabilities.

2297
01:54:12,700 --> 01:54:15,990
So I'm not going to even pass
any arguments there, too.

2298
01:54:15,990 --> 01:54:21,900
Let me assume that the sorting hat has
one function-- one method inside of it

2299
01:54:21,900 --> 01:54:22,810
called, sort.

2300
01:54:22,810 --> 01:54:30,870
And so if I do hat.sort ("Harry"), let's
propose that that prints out what house

2301
01:54:30,870 --> 01:54:32,650
that student should be in.

2302
01:54:32,650 --> 01:54:33,750
So that's it.

2303
01:54:33,750 --> 01:54:35,760
I'm going to encapsulate--

2304
01:54:35,760 --> 01:54:38,130
that is tuck away
inside of a hat class--

2305
01:54:38,130 --> 01:54:42,450
all of this requisite functionality, and
I'm going to print out onto the screen

2306
01:54:42,450 --> 01:54:43,680
what hat--

2307
01:54:43,680 --> 01:54:46,410
what house Harry belongs in.

2308
01:54:46,410 --> 01:54:51,390
Now I think I need to get into the weeds
of actually initializing this class.

2309
01:54:51,390 --> 01:54:53,250
Well, let me go ahead and do this.

2310
01:54:53,250 --> 01:54:56,010
If I don't care to parameterize hat--

2311
01:54:56,010 --> 01:55:00,280
I just want to, for
instance sort values,

2312
01:55:00,280 --> 01:55:03,120
let's go ahead and define
this function, sort, first.

2313
01:55:03,120 --> 01:55:06,480
So let's define sort, as
taking a first argument, self,

2314
01:55:06,480 --> 01:55:10,320
which is always going to be the case
when defining an instance method as

2315
01:55:10,320 --> 01:55:10,950
before.

2316
01:55:10,950 --> 01:55:14,970
But the sort method clearly takes one
argument from the programmer, me--

2317
01:55:14,970 --> 01:55:16,800
namely the student's name.

2318
01:55:16,800 --> 01:55:18,930
And again, we've seen
this dichotomy before.

2319
01:55:18,930 --> 01:55:23,310
Even though I'm trying to pass in one
argument, when I define the method,

2320
01:55:23,310 --> 01:55:26,370
it's got to take that many
arguments, plus one more--

2321
01:55:26,370 --> 01:55:29,430
self which is always going to be
automatically passed in by Python

2322
01:55:29,430 --> 01:55:30,810
first.

2323
01:55:30,810 --> 01:55:32,500
What do I want to do?

2324
01:55:32,500 --> 01:55:34,515
Well, let's go ahead and
do something like this.

2325
01:55:34,515 --> 01:55:37,380


2326
01:55:37,380 --> 01:55:43,563
Print, this name-- how
about "is in," "some house."

2327
01:55:43,563 --> 01:55:45,480
I'm going to, again, use
some placeholder code

2328
01:55:45,480 --> 01:55:49,200
for myself because I'm not quite sure
how to finish implementing this sorting

2329
01:55:49,200 --> 01:55:49,780
hat.

2330
01:55:49,780 --> 01:55:52,920
But I think that's enough to just
test where my code is at now.

2331
01:55:52,920 --> 01:55:56,850
Let me go ahead and run Python
of hat.py and hit Enter.

2332
01:55:56,850 --> 01:55:59,460
And it looks like, indeed,
Harry is in some house.

2333
01:55:59,460 --> 01:56:03,150
We're not done yet because it's
clearly not doing anything interesting,

2334
01:56:03,150 --> 01:56:06,990
but it at least is running
correctly with no errors.

2335
01:56:06,990 --> 01:56:11,340
Well, let's go ahead
now and decide where--

2336
01:56:11,340 --> 01:56:14,730
what house Harry should actually be
in by introducing a bit of randomness

2337
01:56:14,730 --> 01:56:16,830
and choosing a house randomly.

2338
01:56:16,830 --> 01:56:18,720
While I can do this in a few ways, Let.

2339
01:56:18,720 --> 01:56:20,070
Me go ahead and do this.

2340
01:56:20,070 --> 01:56:22,770
I need to have a list
of houses somewhere.

2341
01:56:22,770 --> 01:56:24,055
So where can I put that?

2342
01:56:24,055 --> 01:56:25,930
I could solve this
problem in different ways.

2343
01:56:25,930 --> 01:56:27,220
Let me propose that I do this.

2344
01:56:27,220 --> 01:56:30,030
Let me define a method called
init, as I've done before,

2345
01:56:30,030 --> 01:56:32,460
that takes in self,
but no other arguments.

2346
01:56:32,460 --> 01:56:35,800
And whenever the sorting hat
is instantiated, let's do this.

2347
01:56:35,800 --> 01:56:41,160
Let's create a houses instance variable,
plural, that equals this list--

2348
01:56:41,160 --> 01:56:48,180
Gryffindor, Hufflepuff,
Ravenclaw, Slytherin,

2349
01:56:48,180 --> 01:56:50,640
so the exact same list
that we've used before,

2350
01:56:50,640 --> 01:56:54,540
and I'm storing it in an instance
variable inside of this class.

2351
01:56:54,540 --> 01:56:57,900
I'm not taking any arguments
beyond self to init,

2352
01:56:57,900 --> 01:57:01,840
but I just need this list of
values somewhere, for instance.

2353
01:57:01,840 --> 01:57:03,460
So what can I do here?

2354
01:57:03,460 --> 01:57:07,645
Well, let me go ahead and replace
some house with the actual house.

2355
01:57:07,645 --> 01:57:08,770
Well, what could I do here?

2356
01:57:08,770 --> 01:57:10,800
Well, I want to put a house there.

2357
01:57:10,800 --> 01:57:13,290
Well, let's go ahead and
create a variable called house.

2358
01:57:13,290 --> 01:57:17,490
And if you think back to our discussion
of libraries, in the random module,

2359
01:57:17,490 --> 01:57:23,010
there is a function called choice
that, if you pass in a list of choices,

2360
01:57:23,010 --> 01:57:27,540
like self.houses, that will pick
a random house out of those four.

2361
01:57:27,540 --> 01:57:29,950
And then on line 7, I can pass it in.

2362
01:57:29,950 --> 01:57:33,120
If I want to tighten this up, let me
just go ahead and highlight that code,

2363
01:57:33,120 --> 01:57:34,320
get rid of the variable.

2364
01:57:34,320 --> 01:57:35,765
It's technically unnecessary.

2365
01:57:35,765 --> 01:57:37,890
And because the line of
code is still pretty short,

2366
01:57:37,890 --> 01:57:40,650
I'm OK with just putting
it all in one line.

2367
01:57:40,650 --> 01:57:44,200
But I could certainly use the
variable like I did a moment ago.

2368
01:57:44,200 --> 01:57:45,240
So what have I done?

2369
01:57:45,240 --> 01:57:51,930
In my init function, I have defined
a initialization of the object

2370
01:57:51,930 --> 01:57:55,080
that stores in self.houses
the list of four houses.

2371
01:57:55,080 --> 01:57:57,780
And then, in sort, I'm
accessing that same list,

2372
01:57:57,780 --> 01:58:01,230
but I'm randomly choosing
the set of houses there.

2373
01:58:01,230 --> 01:58:03,000
Now, why have I done it in this way?

2374
01:58:03,000 --> 01:58:04,973
This, too, is general convention.

2375
01:58:04,973 --> 01:58:07,140
Any time you have a list
of things that-- who knows?

2376
01:58:07,140 --> 01:58:09,210
Maybe will change over time.

2377
01:58:09,210 --> 01:58:12,750
Places like Harvard have constructed
new houses over the years,

2378
01:58:12,750 --> 01:58:15,180
so you might have to change
the list of available houses.

2379
01:58:15,180 --> 01:58:18,300
It didn't happen in seven books
or eight films of Harry Potter.

2380
01:58:18,300 --> 01:58:20,400
But you could imagine
maybe Hogwarts eventually

2381
01:58:20,400 --> 01:58:25,500
has a fifth house, so there's generally
some value in putting list of constants

2382
01:58:25,500 --> 01:58:28,530
toward the top of your file, toward
the top of the class so it's just

2383
01:58:28,530 --> 01:58:31,080
obvious what the list of values is.

2384
01:58:31,080 --> 01:58:33,960
You don't want to necessarily
tuck it away in some function,

2385
01:58:33,960 --> 01:58:37,590
like sort, especially if you
might want to use that function--

2386
01:58:37,590 --> 01:58:41,370
sorry, especially if you want to use
that list in multiple functions, not

2387
01:58:41,370 --> 01:58:41,920
just sort.

2388
01:58:41,920 --> 01:58:43,795
But if I kept adding to
this class, you might

2389
01:58:43,795 --> 01:58:46,300
want to use that same list of
houses in multiple functions.

2390
01:58:46,300 --> 01:58:51,757
So let's keep it in the object
itself by storing it in self.houses.

2391
01:58:51,757 --> 01:58:54,840
All right, well, we're about to change
the course of history here perhaps.

2392
01:58:54,840 --> 01:58:58,860
Let me do Python of hat.py, and I
think we're about to assign Harry

2393
01:58:58,860 --> 01:59:02,050
to one of those four houses randomly.

2394
01:59:02,050 --> 01:59:04,260
Huh, NameError.

2395
01:59:04,260 --> 01:59:06,240
Name 'random' is not defined.

2396
01:59:06,240 --> 01:59:09,630
Well, wait a minute,
where did I go wrong here?

2397
01:59:09,630 --> 01:59:14,730
Thinking back to our class on libraries,
why did my code break and not tell me

2398
01:59:14,730 --> 01:59:16,830
where Harry is to be?

2399
01:59:16,830 --> 01:59:19,910
AUDIENCE: You did not
import the random library.

2400
01:59:19,910 --> 01:59:20,910
DAVID J. MALAN: Exactly.

2401
01:59:20,910 --> 01:59:23,760
If the random library or module
is something I want to use,

2402
01:59:23,760 --> 01:59:26,800
I need to tell Python that
at the top of my file.

2403
01:59:26,800 --> 01:59:30,150
So let me go up here
and do import random.

2404
01:59:30,150 --> 01:59:32,910
And then, below that, let me go
ahead and clear my terminal window

2405
01:59:32,910 --> 01:59:33,630
and try again.

2406
01:59:33,630 --> 01:59:39,240
Python of hat.py, crossing my fingers,
seeing where Harry is going to end up.

2407
01:59:39,240 --> 01:59:43,230
And, OK, Harry as of now is
officially in Hufflepuff,

2408
01:59:43,230 --> 01:59:45,720
despite everything you've read or seen.

2409
01:59:45,720 --> 01:59:47,080
Well, let's run this again.

2410
01:59:47,080 --> 01:59:51,030
Let me clear my window and run Python
of hat.py, and now he's in Ravenclaw.

2411
01:59:51,030 --> 01:59:52,770
That's consistent with using random.

2412
01:59:52,770 --> 01:59:54,570
Let's clear that and run it again.

2413
01:59:54,570 --> 01:59:56,670
He's still in Ravenclaw,
but that could happen,

2414
01:59:56,670 --> 01:59:58,045
even though there's four choices.

2415
01:59:58,045 --> 01:59:58,830
Let's do it again.

2416
01:59:58,830 --> 02:00:00,450
Hufflepuff-- back in Hufflepuff.

2417
02:00:00,450 --> 02:00:02,860
We can't seem to get the right answer.

2418
02:00:02,860 --> 02:00:05,580
Now he's in Gryffindor, albeit randomly.

2419
02:00:05,580 --> 02:00:08,430
So we seem to have a program that,
based on these limited tests,

2420
02:00:08,430 --> 02:00:12,370
seems to be assigning
Harry to a house randomly.

2421
02:00:12,370 --> 02:00:16,620
Now I'm somewhat lazily just
letting sort print out this value.

2422
02:00:16,620 --> 02:00:21,600
I could do something else, like return
a string, and then let me, on line 13,

2423
02:00:21,600 --> 02:00:23,140
do the printing for me.

2424
02:00:23,140 --> 02:00:28,200
But for now, I think we have an
example of a class called hat that,

2425
02:00:28,200 --> 02:00:31,320
nonetheless, applies some of our
lessons learned thus far today,

2426
02:00:31,320 --> 02:00:34,530
where I've created a class--
because a sorting hat is, frankly--

2427
02:00:34,530 --> 02:00:37,440
well, I was about to say
real world entity, but really

2428
02:00:37,440 --> 02:00:39,090
a fantasy world entity.

2429
02:00:39,090 --> 02:00:42,990
And indeed, that's a, perhaps, common
heuristic or mental model to have.

2430
02:00:42,990 --> 02:00:47,250
When should you use a class to
represent something in your code?

2431
02:00:47,250 --> 02:00:51,840
Very often, when you're trying to
represent some real world entity

2432
02:00:51,840 --> 02:00:57,000
or fantasy world entity, like a student,
which is something in the real world,

2433
02:00:57,000 --> 02:00:59,820
like a sorting hat,
which, OK, doesn't exist,

2434
02:00:59,820 --> 02:01:03,390
but hat's certainly do, so quite
reasonable to have a class for hat.

2435
02:01:03,390 --> 02:01:07,710
And that's not always the case that
classes represent real world entities.

2436
02:01:07,710 --> 02:01:13,495
But we've seen thus far that int
and stir and list and dict-- these

2437
02:01:13,495 --> 02:01:15,870
are all structures that you
might have in the real world.

2438
02:01:15,870 --> 02:01:18,610
We have integers and strings
of text and other things.

2439
02:01:18,610 --> 02:01:22,050
So it rather makes sense to represent
even those things, more technically,

2440
02:01:22,050 --> 02:01:23,830
using a class as well.

2441
02:01:23,830 --> 02:01:27,480
You could use just a dictionary
to represent a student or a hat.

2442
02:01:27,480 --> 02:01:32,100
But again, with classes come all
this and even more functionality.

2443
02:01:32,100 --> 02:01:37,980
But I honestly am not using classes
in, really, the "right way" here.

2444
02:01:37,980 --> 02:01:38,640
Why?

2445
02:01:38,640 --> 02:01:41,850
Well, in the world of Harry
Potter there really is only,

2446
02:01:41,850 --> 02:01:43,980
to my knowledge, one sorting hat.

2447
02:01:43,980 --> 02:01:48,190
And yet, here I have gone and
implemented a class called hat.

2448
02:01:48,190 --> 02:01:51,540
And again, a class is like
a blueprint, a template,

2449
02:01:51,540 --> 02:01:55,813
a mold that allows you to create
one or more objects thereof.

2450
02:01:55,813 --> 02:01:58,230
Now, most of my programs Thus
far have been pretty simple,

2451
02:01:58,230 --> 02:01:59,940
and I've just created one student.

2452
02:01:59,940 --> 02:02:02,400
But certainly, if I spent
more time and wrote more code,

2453
02:02:02,400 --> 02:02:04,800
you could imagine
writing one program that

2454
02:02:04,800 --> 02:02:07,410
has a list of students--
many more students

2455
02:02:07,410 --> 02:02:09,900
than just the one we keep demonstrating.

2456
02:02:09,900 --> 02:02:11,830
Yet it would be a little weird--

2457
02:02:11,830 --> 02:02:14,490
it's a little inconsistent
with the real or the fantasy

2458
02:02:14,490 --> 02:02:19,230
world of Harry Potter to instantiate
one, two, three or more sorting hats.

2459
02:02:19,230 --> 02:02:20,910
There really is just one.

2460
02:02:20,910 --> 02:02:23,070
Really one singleton,
if you will, which is

2461
02:02:23,070 --> 02:02:25,660
a term of art in a lot of
contexts of programming.

2462
02:02:25,660 --> 02:02:29,340
So let me propose that we actually
improve the design of the sorting hat

2463
02:02:29,340 --> 02:02:34,290
so that we don't have to instantiate
a sorting hat because right now this

2464
02:02:34,290 --> 02:02:39,990
is kind of allowing me to do something
like hat 1 = hat, hat 2 = hat, hat 3 =,

2465
02:02:39,990 --> 02:02:40,680
and so forth.

2466
02:02:40,680 --> 02:02:42,510
I don't really need that capability.

2467
02:02:42,510 --> 02:02:46,440
I really just need to represent
the sorting hat with a class,

2468
02:02:46,440 --> 02:02:48,340
but I don't really
need to instantiate it.

2469
02:02:48,340 --> 02:02:48,840
Why?

2470
02:02:48,840 --> 02:02:49,923
Because it already exists.

2471
02:02:49,923 --> 02:02:50,850
I need just one.

2472
02:02:50,850 --> 02:02:54,250
So it turns out, in
Python, that, up until now,

2473
02:02:54,250 --> 02:02:57,060
we've been using, as I keep
calling them, instance methods--

2474
02:02:57,060 --> 02:03:01,620
writing functions inside of classes that
are automatically passed a reference

2475
02:03:01,620 --> 02:03:03,570
to self, the current object.

2476
02:03:03,570 --> 02:03:05,590
But sometimes you just don't need that.

2477
02:03:05,590 --> 02:03:08,280
Sometimes it suffices to
just know what the class is

2478
02:03:08,280 --> 02:03:12,100
and assume that there might not
even be any objects of that class.

2479
02:03:12,100 --> 02:03:16,860
So in this sense, you can use a
class really as a container for data

2480
02:03:16,860 --> 02:03:21,480
and/or functionality that is just
somehow conceptually related--

2481
02:03:21,480 --> 02:03:24,000
things related to a sorting hat.

2482
02:03:24,000 --> 02:03:27,300
And there's this other decorator
or function called @classmethod

2483
02:03:27,300 --> 02:03:28,960
that allows us to do just this.

2484
02:03:28,960 --> 02:03:30,600
So let me go back to my code here.

2485
02:03:30,600 --> 02:03:36,240
And let me propose that, if I'm not
going to instantiate multiple houses,

2486
02:03:36,240 --> 02:03:39,120
I don't really need this init
method because that's really

2487
02:03:39,120 --> 02:03:43,470
meant to initialize specific objects
from that blueprint, that template,

2488
02:03:43,470 --> 02:03:44,280
that mold.

2489
02:03:44,280 --> 02:03:45,930
So let me get rid of this.

2490
02:03:45,930 --> 02:03:49,020
But if I get rid of this, I
no longer have access to self.

2491
02:03:49,020 --> 02:03:53,970
But that's OK because it turns out,
in addition to their existing class

2492
02:03:53,970 --> 02:03:57,630
methods, there are also what
we might call class variables.

2493
02:03:57,630 --> 02:04:01,990
And class variables exist
within the class itself.

2494
02:04:01,990 --> 02:04:05,030
And there's just one
copy of that variable

2495
02:04:05,030 --> 02:04:07,160
for all of the objects thereof.

2496
02:04:07,160 --> 02:04:11,480
They all share, if you will, the
same variable-- be it an int or str

2497
02:04:11,480 --> 02:04:12,960
or, in this case, a list.

2498
02:04:12,960 --> 02:04:20,240
So what I've done here is define, inside
of my hat class, in a class variable

2499
02:04:20,240 --> 02:04:21,410
called houses--

2500
02:04:21,410 --> 02:04:24,290
I don't say self because
self is no longer relevant.

2501
02:04:24,290 --> 02:04:26,000
Self refers to specific objects.

2502
02:04:26,000 --> 02:04:29,360
I want a variable inside
of this class, a.k.a.

2503
02:04:29,360 --> 02:04:32,000
A class variable that equals that list.

2504
02:04:32,000 --> 02:04:34,910
Because it's inside of
this hat, now, class,

2505
02:04:34,910 --> 02:04:38,420
I can use that list in
any of my functions.

2506
02:04:38,420 --> 02:04:40,160
I've only got one now, called sort.

2507
02:04:40,160 --> 02:04:43,010
But if I had more, it would be
accessible to all of those methods

2508
02:04:43,010 --> 02:04:43,890
as well.

2509
02:04:43,890 --> 02:04:47,000
And with sort, it also
doesn't really make sense

2510
02:04:47,000 --> 02:04:50,450
to sort within a specific
sorting hat because, again, I

2511
02:04:50,450 --> 02:04:51,710
only want there to be one.

2512
02:04:51,710 --> 02:04:57,080
So I can actually specify that this is
class method by saying @classmethod.

2513
02:04:57,080 --> 02:04:59,300
And I don't pass in self anymore.

2514
02:04:59,300 --> 02:05:04,440
I actually, by convention, pass in
a reference to the class itself.

2515
02:05:04,440 --> 02:05:06,440
It's typically written as cls.

2516
02:05:06,440 --> 02:05:06,980
Why?

2517
02:05:06,980 --> 02:05:12,140
Well, if you wrote C-L-A-S-S, that
would actually conflict with the keyword

2518
02:05:12,140 --> 02:05:14,010
"class" that we keep using up here.

2519
02:05:14,010 --> 02:05:18,330
So the world realized that, oops, we
can't reuse that same phrase here.

2520
02:05:18,330 --> 02:05:20,060
So let's just call this class.

2521
02:05:20,060 --> 02:05:22,770
This is useful in some
contexts including this one.

2522
02:05:22,770 --> 02:05:23,270
Why?

2523
02:05:23,270 --> 02:05:25,340
Well, notice what I can now do.

2524
02:05:25,340 --> 02:05:28,130
I can now change self to be just class.

2525
02:05:28,130 --> 02:05:28,730
Why?

2526
02:05:28,730 --> 02:05:33,920
Because houses now-- not an instance
variable, accessible via self.houses.

2527
02:05:33,920 --> 02:05:38,270
It is now a class variable,
accessible via class.houses,

2528
02:05:38,270 --> 02:05:41,600
or technically cls.houses in this case.

2529
02:05:41,600 --> 02:05:43,880
But now the final flourish is this.

2530
02:05:43,880 --> 02:05:50,420
Now, I don't have to instantiate any hat
objects as I used to on here, line 13.

2531
02:05:50,420 --> 02:05:54,030
I can just use functionality
that comes with this class.

2532
02:05:54,030 --> 02:05:56,000
So I'm going to delete
that line altogether.

2533
02:05:56,000 --> 02:06:03,620
I'm going to capitalize the hat on
this new line 13 and just say hat.sort,

2534
02:06:03,620 --> 02:06:04,550
("Harry").

2535
02:06:04,550 --> 02:06:05,970
So what have I done?

2536
02:06:05,970 --> 02:06:09,740
I've not bothered instantiating
an object of type, hat.

2537
02:06:09,740 --> 02:06:13,995
I am just accessing a class
method inside of the hat class

2538
02:06:13,995 --> 02:06:14,870
that-- you know what?

2539
02:06:14,870 --> 02:06:16,410
Is just going to work.

2540
02:06:16,410 --> 02:06:17,900
This is how class methods work.

2541
02:06:17,900 --> 02:06:22,250
You use the name of the class, capital
letter and all, dot method name,

2542
02:06:22,250 --> 02:06:24,260
passing in any arguments you want.

2543
02:06:24,260 --> 02:06:28,220
Python is going to automatically
pass in some variable via which

2544
02:06:28,220 --> 02:06:31,820
you can refer to that
class in that function

2545
02:06:31,820 --> 02:06:33,680
that you've implemented
inside of that class

2546
02:06:33,680 --> 02:06:35,330
so that I can do something like this.

2547
02:06:35,330 --> 02:06:39,030
It's not that I want a variable called
houses locally in this function,

2548
02:06:39,030 --> 02:06:43,730
I want the variable called houses that's
associated with this current class

2549
02:06:43,730 --> 02:06:48,380
so I can still access this same
list that I defined on line 6.

2550
02:06:48,380 --> 02:06:52,700
And now, if I go back down here to
my terminal and run Python of hat.py,

2551
02:06:52,700 --> 02:06:56,090
Enter, Harry is still
in Hufflepuff once more.

2552
02:06:56,090 --> 02:06:58,250
Harry is still in Hufflepuff once more.

2553
02:06:58,250 --> 02:07:02,440
Harry is back in Gryffindor,
at least randomly.

2554
02:07:02,440 --> 02:07:07,540
Questions, now, on these class
variables or these class methods,

2555
02:07:07,540 --> 02:07:12,640
which are in contrast with instance
variables and instance methods.

2556
02:07:12,640 --> 02:07:15,070
And the one thing, at least,
that's a little strange

2557
02:07:15,070 --> 02:07:18,880
here is that, even though there's
a decorator called @classmethod,

2558
02:07:18,880 --> 02:07:22,480
there is not one called @instancemethod.

2559
02:07:22,480 --> 02:07:26,860
A method is just automatically a
so-called "instant method" when

2560
02:07:26,860 --> 02:07:28,750
you define it without any decorator.

2561
02:07:28,750 --> 02:07:31,507
AUDIENCE: Can you have a
class inside another class?

2562
02:07:31,507 --> 02:07:32,507
DAVID J. MALAN: You can.

2563
02:07:32,507 --> 02:07:34,870
You can define one
class inside of another.

2564
02:07:34,870 --> 02:07:37,270
Generally speaking, this
isn't done, but there

2565
02:07:37,270 --> 02:07:39,610
are cases where it can
be helpful, especially

2566
02:07:39,610 --> 02:07:41,830
for larger, more sophisticated programs.

2567
02:07:41,830 --> 02:07:44,770
So yes, it is possible.

2568
02:07:44,770 --> 02:07:45,970
Other questions.

2569
02:07:45,970 --> 02:07:49,180
AUDIENCE: The question
was about the self.houses.

2570
02:07:49,180 --> 02:07:56,275
When we remove it and we pass
data, variable is created itself,

2571
02:07:56,275 --> 02:07:58,660
s why we remove the self?

2572
02:07:58,660 --> 02:08:00,850
DAVID J. MALAN: So in
the previous examples--

2573
02:08:00,850 --> 02:08:03,820
both of the hat demonstration
and also all of the student

2574
02:08:03,820 --> 02:08:07,930
demonstrations-- we
were creating a student

2575
02:08:07,930 --> 02:08:11,830
object by calling Student, capital S,
open parenthesis, close parenthesis,

2576
02:08:11,830 --> 02:08:14,320
with, eventually, name
and a house passed in.

2577
02:08:14,320 --> 02:08:18,040
And then we were using the
double underscore init method

2578
02:08:18,040 --> 02:08:23,920
to initialize the self.name and
the self.house instance variables

2579
02:08:23,920 --> 02:08:26,560
therein to those respective values.

2580
02:08:26,560 --> 02:08:28,960
In this latest version
of the sorting hat,

2581
02:08:28,960 --> 02:08:33,370
I haven't bothered with self anywhere,
only because, conceptually, I

2582
02:08:33,370 --> 02:08:36,910
don't need or want there to
be multiple hats in the world.

2583
02:08:36,910 --> 02:08:42,250
I'm just using the class as a container
to bundle up this list of houses,

2584
02:08:42,250 --> 02:08:43,690
this sorting functionality.

2585
02:08:43,690 --> 02:08:46,090
Maybe eventually all add
more functionality to it.

2586
02:08:46,090 --> 02:08:47,080
But that's it.

2587
02:08:47,080 --> 02:08:50,050
And so sometimes you can use
object-oriented programming

2588
02:08:50,050 --> 02:08:53,650
in this somewhat different way when
you want there to be functionality

2589
02:08:53,650 --> 02:08:56,530
but it's not specific
to any one specific hat.

2590
02:08:56,530 --> 02:09:00,640
It's specific to the sorting hat itself.

2591
02:09:00,640 --> 02:09:05,170
How about one other question now, on
these class variables or methods-- just

2592
02:09:05,170 --> 02:09:08,210
another way of using object-oriented
programming but to solve

2593
02:09:08,210 --> 02:09:09,730
a somewhat different problem?

2594
02:09:09,730 --> 02:09:12,130
AUDIENCE: Well, what's the
difference between the class

2595
02:09:12,130 --> 02:09:16,027
hat and a function of hat?

2596
02:09:16,027 --> 02:09:17,360
DAVID J. MALAN: A good question.

2597
02:09:17,360 --> 02:09:19,690
So why are we using a
class at all and not just

2598
02:09:19,690 --> 02:09:23,140
having a file called hat.py
with a variable called

2599
02:09:23,140 --> 02:09:25,690
houses and a function called sort?

2600
02:09:25,690 --> 02:09:27,370
Why are we adding this complexity?

2601
02:09:27,370 --> 02:09:30,160
In this particular case, we
don't necessarily need to.

2602
02:09:30,160 --> 02:09:32,380
I could absolutely go in here.

2603
02:09:32,380 --> 02:09:34,060
I could get rid of the class.

2604
02:09:34,060 --> 02:09:36,850
I could undo this indentation.

2605
02:09:36,850 --> 02:09:38,890
I could get rid of this decorator.

2606
02:09:38,890 --> 02:09:40,750
And I could get rid of hat dot.

2607
02:09:40,750 --> 02:09:43,480
And I could just do
this and additionally

2608
02:09:43,480 --> 02:09:45,400
let's say, let's get rid of class here.

2609
02:09:45,400 --> 02:09:47,050
Let's get rid of class here.

2610
02:09:47,050 --> 02:09:51,058
And now run Python of hat.py,
Enter, and it still works.

2611
02:09:51,058 --> 02:09:53,350
Put Harry in the wrong house,
but that's what we have--

2612
02:09:53,350 --> 02:09:54,430
what happens randomly.

2613
02:09:54,430 --> 02:09:55,690
That's fine, too.

2614
02:09:55,690 --> 02:09:58,960
What we're introducing today, by
way of object-oriented programming,

2615
02:09:58,960 --> 02:10:01,420
is just a different way
of modeling the world.

2616
02:10:01,420 --> 02:10:04,120
It's not really compelling
with an example like this,

2617
02:10:04,120 --> 02:10:06,350
frankly, that's relatively simple.

2618
02:10:06,350 --> 02:10:07,328
It's not very complex.

2619
02:10:07,328 --> 02:10:08,620
There's not much functionality.

2620
02:10:08,620 --> 02:10:12,070
Honestly, the version that we just typed
up-- these 10 lines-- this is fine.

2621
02:10:12,070 --> 02:10:13,400
This solves this problem.

2622
02:10:13,400 --> 02:10:16,912
But as our code gets longer, as we
start collaborating with other people,

2623
02:10:16,912 --> 02:10:19,870
as the problems we're trying to solve
with code get more sophisticated,

2624
02:10:19,870 --> 02:10:23,317
you're going to find that
your code gets messy quickly.

2625
02:10:23,317 --> 02:10:26,650
And you're going to find that you have a
huge number of functions, for instance,

2626
02:10:26,650 --> 02:10:27,700
in one file.

2627
02:10:27,700 --> 02:10:31,180
And some of them are related to each
other, but some of them are not.

2628
02:10:31,180 --> 02:10:33,815
Well, at that point, wouldn't
it be nice to just organize them

2629
02:10:33,815 --> 02:10:34,690
a little differently?

2630
02:10:34,690 --> 02:10:37,690
And in the world of Harry Potter,
let's have a class for student;

2631
02:10:37,690 --> 02:10:41,140
let's have a class for Professor;
let's have a class for the sorting hat;

2632
02:10:41,140 --> 02:10:42,920
let's have a class for something else.

2633
02:10:42,920 --> 02:10:45,820
And so once your world gets
much more complicated than some

2634
02:10:45,820 --> 02:10:49,000
of the demonstrations we do here
in class when we want to focus

2635
02:10:49,000 --> 02:10:52,690
on individual ideas, object-oriented
programming is just a way

2636
02:10:52,690 --> 02:10:55,300
of encapsulating related data--

2637
02:10:55,300 --> 02:10:58,510
that is, variables-- related
functionality-- that is, methods--

2638
02:10:58,510 --> 02:11:00,790
inside of things that have names.

2639
02:11:00,790 --> 02:11:02,840
These things are called classes.

2640
02:11:02,840 --> 02:11:04,940
So it's just another
way to solve problems.

2641
02:11:04,940 --> 02:11:07,330
And when we focused on libraries
a couple of weeks back,

2642
02:11:07,330 --> 02:11:10,000
that, too, was another
solution to the same problem.

2643
02:11:10,000 --> 02:11:13,480
You could define your own modules
or packages, put some of your data

2644
02:11:13,480 --> 02:11:15,910
and/or functionality in
there, and that's fine, too.

2645
02:11:15,910 --> 02:11:19,210
And sometimes which one
you should use overlaps.

2646
02:11:19,210 --> 02:11:22,540
If you're familiar with Venn
diagrams, the overlapping region

2647
02:11:22,540 --> 02:11:25,990
might mean that you could use a class;
you could use a module or a package;

2648
02:11:25,990 --> 02:11:28,720
you could just use a single local file.

2649
02:11:28,720 --> 02:11:31,120
Over time, you'll develop
an instinct and maybe even

2650
02:11:31,120 --> 02:11:35,480
a personal preference
for which tool to use.

2651
02:11:35,480 --> 02:11:39,620
All right, let me propose, now, that we
apply this same idea of a class method

2652
02:11:39,620 --> 02:11:41,810
to clean up one other thing as well.

2653
02:11:41,810 --> 02:11:47,240
Let me close that hat.py and reopen
student.py as we left it earlier,

2654
02:11:47,240 --> 02:11:50,700
and let me go ahead and
simplify it just a little bit.

2655
02:11:50,700 --> 02:11:53,963
I'm going to go ahead and
get rid of the properties,

2656
02:11:53,963 --> 02:11:55,880
not because there's
anything, wrong with them,

2657
02:11:55,880 --> 02:11:58,610
but just because I want us to
focus on some of the key ideas

2658
02:11:58,610 --> 02:12:00,540
when we began with this program.

2659
02:12:00,540 --> 02:12:02,940
So I'm going to go ahead
and keep main as well.

2660
02:12:02,940 --> 02:12:06,800
I'm not going to adversarially try
to change Henry's address there.

2661
02:12:06,800 --> 02:12:09,870
I'm going to instead go ahead,
though, and just print the student.

2662
02:12:09,870 --> 02:12:12,950
But this is the thing I
want to focus on here.

2663
02:12:12,950 --> 02:12:17,750
This, in our previous student
examples, was a missed opportunity

2664
02:12:17,750 --> 02:12:19,340
to clean up my code.

2665
02:12:19,340 --> 02:12:20,910
Well, what do I mean by that?

2666
02:12:20,910 --> 02:12:22,970
Well, up here at the
top of this file-- even

2667
02:12:22,970 --> 02:12:25,160
though I've simplified it, but
getting rid of the properties

2668
02:12:25,160 --> 02:12:26,910
and all of that error
checking-- because I

2669
02:12:26,910 --> 02:12:29,930
want to focus on the essence of this
class now-- just the student's name

2670
02:12:29,930 --> 02:12:32,070
and the house and the printing thereof.

2671
02:12:32,070 --> 02:12:36,200
This is, by nature of classes
in object-oriented programming,

2672
02:12:36,200 --> 02:12:40,880
theoretically, all of my
student-specific functionality.

2673
02:12:40,880 --> 02:12:45,300
That is to say, if I have functionality
and data related to a student, you,

2674
02:12:45,300 --> 02:12:47,780
the programmer, my
colleague, would assume

2675
02:12:47,780 --> 02:12:50,090
that it's all bundled
up, encapsulated, so

2676
02:12:50,090 --> 02:12:52,010
to speak, inside of the student class.

2677
02:12:52,010 --> 02:12:55,400
And yet, if you scroll
down further, what is this?

2678
02:12:55,400 --> 02:12:58,670
There's a function called get_student
that just exists elsewhere

2679
02:12:58,670 --> 02:13:02,390
in this file that prompts the user for
a name, prompts the user for a house,

2680
02:13:02,390 --> 02:13:05,300
creates the student
object, and then returns.

2681
02:13:05,300 --> 02:13:06,710
That's not wrong.

2682
02:13:06,710 --> 02:13:07,400
It works.

2683
02:13:07,400 --> 02:13:10,250
And we saw many, many
times it kept working.

2684
02:13:10,250 --> 02:13:13,400
But this is a little
weird because, if this

2685
02:13:13,400 --> 02:13:16,430
is a function that
helps you get a student,

2686
02:13:16,430 --> 02:13:20,120
helps you get the name of a student
and the house of a student, why isn't

2687
02:13:20,120 --> 02:13:22,350
that functionality in the class itself?

2688
02:13:22,350 --> 02:13:25,487
After all, as my code gets more and
more complicated and does more things,

2689
02:13:25,487 --> 02:13:27,320
I'm going to be looking
at the student class

2690
02:13:27,320 --> 02:13:28,975
for all student-related functionality.

2691
02:13:28,975 --> 02:13:31,850
I'm not going to be scrolling down,
expecting that, oh, maybe there's

2692
02:13:31,850 --> 02:13:35,900
some other student functionality
just randomly later in this file.

2693
02:13:35,900 --> 02:13:37,160
So it's not wrong.

2694
02:13:37,160 --> 02:13:40,820
But this is, again, evidence
of maybe bad design--

2695
02:13:40,820 --> 02:13:42,770
not so much with this small program.

2696
02:13:42,770 --> 02:13:45,680
But this is an example,
again, of code smell.

2697
02:13:45,680 --> 02:13:47,218
Something smells a little off here.

2698
02:13:47,218 --> 02:13:49,010
This is probably going
to get us in trouble

2699
02:13:49,010 --> 02:13:52,020
by separating related functionality.

2700
02:13:52,020 --> 02:13:55,730
So again it's a design principle,
not a correctness concern.

2701
02:13:55,730 --> 02:13:59,180
But class methods allow
us to address this, too.

2702
02:13:59,180 --> 02:14:01,020
Let me go ahead and do this.

2703
02:14:01,020 --> 02:14:03,860
I'm going to delete get_student
all together, leaving

2704
02:14:03,860 --> 02:14:06,680
only main as my other function here.

2705
02:14:06,680 --> 02:14:09,740
And inside of my student
class, I'm going to do this.

2706
02:14:09,740 --> 02:14:13,580
I'm going to define a function,
even more simply called, get.

2707
02:14:13,580 --> 02:14:16,490
And by nature of how
class methods work, it's

2708
02:14:16,490 --> 02:14:18,830
going to take in the
name of the class itself

2709
02:14:18,830 --> 02:14:21,050
or a reference thereto as an argument.

2710
02:14:21,050 --> 02:14:24,300
And I'm going to move the functionality
from get_student into the student

2711
02:14:24,300 --> 02:14:24,800
class.

2712
02:14:24,800 --> 02:14:29,960
And I'm going to do this-- name equals
input, quote, unquote, name, house

2713
02:14:29,960 --> 02:14:32,900
equals input, quote, unquote, house.

2714
02:14:32,900 --> 02:14:35,510
And then what this
function is going to do

2715
02:14:35,510 --> 02:14:42,530
is return a new student object by
calling class, which, again, is just

2716
02:14:42,530 --> 02:14:45,470
an automatically passed-in
reference to the class

2717
02:14:45,470 --> 02:14:48,890
itself, passing in name and house.

2718
02:14:48,890 --> 02:14:54,122
And I will admit this syntax seems a
little strange that now I'm calling cls

2719
02:14:54,122 --> 02:14:55,580
and I'm passing in these arguments.

2720
02:14:55,580 --> 02:14:57,320
But let me do one final fix here.

2721
02:14:57,320 --> 02:14:59,270
Let me go to the top of
this function and more

2722
02:14:59,270 --> 02:15:02,330
explicitly say this is a class method.

2723
02:15:02,330 --> 02:15:05,760
This solves a potential chicken
and the egg problem, so to speak,

2724
02:15:05,760 --> 02:15:08,480
whereby one needs to come
before the other, potentially.

2725
02:15:08,480 --> 02:15:10,460
So what am I doing here?

2726
02:15:10,460 --> 02:15:15,110
Inside of my student class, I
now have a function called get.

2727
02:15:15,110 --> 02:15:18,540
It is, I shall claim, a class
method what does that mean.

2728
02:15:18,540 --> 02:15:24,200
It just means I can call this method
without instantiating a student

2729
02:15:24,200 --> 02:15:25,340
object first.

2730
02:15:25,340 --> 02:15:28,538
Therein lies the potential
chicken and the egg problem.

2731
02:15:28,538 --> 02:15:31,580
And if unfamiliar, that's an expression,
meaning, well, and did the world

2732
02:15:31,580 --> 02:15:34,520
have chickens first that laid
eggs, or was there an egg

2733
02:15:34,520 --> 02:15:38,180
that then yielded the chickens,
but how did the egg get there?

2734
02:15:38,180 --> 02:15:40,003
It's this weird, circular problem.

2735
02:15:40,003 --> 02:15:41,420
And that's what we're facing here.

2736
02:15:41,420 --> 02:15:47,600
It would be weird if you had to create
a student object in order to call get,

2737
02:15:47,600 --> 02:15:51,020
in order to get another student object.

2738
02:15:51,020 --> 02:15:52,070
That sounds messy.

2739
02:15:52,070 --> 02:15:56,060
Let's just get a student
via a class method

2740
02:15:56,060 --> 02:16:00,350
that, by definition, does not require
you to create a student object first.

2741
02:16:00,350 --> 02:16:04,370
Just like the hat, in its final
form, we use the hat class

2742
02:16:04,370 --> 02:16:07,040
to just say Hat, capital H, dot sort.

2743
02:16:07,040 --> 02:16:08,660
We didn't need to create a hat first.

2744
02:16:08,660 --> 02:16:10,920
We just used the class itself.

2745
02:16:10,920 --> 02:16:12,980
So what am I going to do here now?

2746
02:16:12,980 --> 02:16:14,240
Let me go down to main.

2747
02:16:14,240 --> 02:16:18,020
And instead of saying get_student,
notice what I can now do.

2748
02:16:18,020 --> 02:16:22,850
Student.get, and everything
else can stay the same.

2749
02:16:22,850 --> 02:16:26,630
All I've done now is I've
migrated all of my logic

2750
02:16:26,630 --> 02:16:29,750
from get_student, which was
this own standalone function,

2751
02:16:29,750 --> 02:16:32,510
but clearly related to students by name.

2752
02:16:32,510 --> 02:16:36,670
I've moved the same
code, really, to inside

2753
02:16:36,670 --> 02:16:40,660
of the student class in a more
simply named function called get.

2754
02:16:40,660 --> 02:16:42,730
But I could still call
it get_student if I want.

2755
02:16:42,730 --> 02:16:46,000
It just seems a little redundant to
call it get_student in a student class,

2756
02:16:46,000 --> 02:16:47,480
so I'm simplifying.

2757
02:16:47,480 --> 02:16:51,400
So I have a method called get,
but I'm calling it a class method

2758
02:16:51,400 --> 02:16:53,540
to avoid that chicken
and the egg problem.

2759
02:16:53,540 --> 02:16:59,170
I want to be able to call a get without
having a student object in my universe

2760
02:16:59,170 --> 02:17:00,010
already.

2761
02:17:00,010 --> 02:17:03,250
And the syntax for that is @classmethod.

2762
02:17:03,250 --> 02:17:06,549
The convention is to give this
method at least one argument,

2763
02:17:06,549 --> 02:17:09,520
by convention called cls for
class, which is just going

2764
02:17:09,520 --> 02:17:11,320
to be a reference to the class itself.

2765
02:17:11,320 --> 02:17:14,709
Lines 11 and 12 are identical
to what they've always been.

2766
02:17:14,709 --> 02:17:17,889
And get_student-- the only
new syntax here is this,

2767
02:17:17,889 --> 02:17:21,700
but this, again, is one of the features
of object-oriented programming.

2768
02:17:21,700 --> 02:17:29,020
You can now instantiate a student object
by just using cls that's passed in.

2769
02:17:29,020 --> 02:17:31,780
I technically could
use Student, capital S,

2770
02:17:31,780 --> 02:17:34,540
but it turns out I'm doing what's
more conventional because this

2771
02:17:34,540 --> 02:17:38,680
will both solve and avoid problems down
the line with more complicated code.

2772
02:17:38,680 --> 02:17:43,138
This line here, on line 13, just means
create an object of the current class.

2773
02:17:43,138 --> 02:17:43,930
What class is that?

2774
02:17:43,930 --> 02:17:45,010
Well, whatever cls is.

2775
02:17:45,010 --> 02:17:48,670
Well, that, by definition of how it
all works, is going to be student.

2776
02:17:48,670 --> 02:17:53,440
And I want you to initialize it,
as always, with name and house.

2777
02:17:53,440 --> 02:17:56,860
So now, scrolling down, my code is this.

2778
02:17:56,860 --> 02:17:59,080
And this is just nice to read.

2779
02:17:59,080 --> 02:18:02,980
You perhaps have to acquire a taste for
this-- and I sound a little odd saying,

2780
02:18:02,980 --> 02:18:03,969
this is nice to read.

2781
02:18:03,969 --> 02:18:07,330
But indeed, student.get just
tells me what's going on.

2782
02:18:07,330 --> 02:18:08,590
I'm going to get a student.

2783
02:18:08,590 --> 02:18:12,160
I don't need a separate function written
by me called get_student in the file

2784
02:18:12,160 --> 02:18:12,950
itself.

2785
02:18:12,950 --> 02:18:16,090
The get functionality
is built into the class.

2786
02:18:16,090 --> 02:18:18,620
All my student-related
code now is together.

2787
02:18:18,620 --> 02:18:22,240
So let me go down to my terminal window
and run Python of student.py, Enter.

2788
02:18:22,240 --> 02:18:23,290
Let's type in Harry.

2789
02:18:23,290 --> 02:18:24,610
Let's type in Gryffindor.

2790
02:18:24,610 --> 02:18:26,170
And we're back to where we began.

2791
02:18:26,170 --> 02:18:31,750
But, but, but everything related to
students, now, is in this here class.

2792
02:18:31,750 --> 02:18:35,709
The only other thing in the file
is main and this conditional

2793
02:18:35,709 --> 02:18:39,670
that we always use to avoid accidentally
executing main when we're making

2794
02:18:39,670 --> 02:18:42,049
a module or a package or the like.

2795
02:18:42,049 --> 02:18:44,770
So again, a solution to a problem--

2796
02:18:44,770 --> 02:18:48,070
not a big one in the case of a
relatively small program, but one

2797
02:18:48,070 --> 02:18:50,260
that you will eventually
encounter as your programs

2798
02:18:50,260 --> 02:18:55,299
get longer and longer, with more
and more entities to represent.

2799
02:18:55,299 --> 02:19:00,220
Questions now on this
use of a class method.

2800
02:19:00,220 --> 02:19:03,520
MICHAEL: Does the class have to be
defined before the main function,

2801
02:19:03,520 --> 02:19:05,684
in terms of the order of the program?

2802
02:19:05,684 --> 02:19:07,309
DAVID J. MALAN: A really good question.

2803
02:19:07,309 --> 02:19:08,480
So when in doubt, let's try this.

2804
02:19:08,480 --> 02:19:09,855
So let's try to change the order.

2805
02:19:09,855 --> 02:19:12,400
Let's move main to the top,
which I've often encouraged.

2806
02:19:12,400 --> 02:19:15,400
So let's go ahead and,
above the class, do this.

2807
02:19:15,400 --> 02:19:18,190
And notice now that,
technically, line two

2808
02:19:18,190 --> 02:19:22,660
is mentioning student, which does
not exist until line 6 and below.

2809
02:19:22,660 --> 02:19:25,870
Let me go ahead and clear my terminal
and run Python of student.py.

2810
02:19:25,870 --> 02:19:27,070
So far, so good.

2811
02:19:27,070 --> 02:19:29,950
Harry-- Gryffindor, OK.

2812
02:19:29,950 --> 02:19:31,660
Indeed, Harry's from Gryffindor.

2813
02:19:31,660 --> 02:19:34,750
The reason, Michael, it
does not matter in this case

2814
02:19:34,750 --> 02:19:38,020
is because we're not actually
calling main until the very end.

2815
02:19:38,020 --> 02:19:41,590
And just as in the past, that means that
Python has a chance to read everything,

2816
02:19:41,590 --> 02:19:42,830
top to bottom, left to right.

2817
02:19:42,830 --> 02:19:44,290
So everything exists.

2818
02:19:44,290 --> 02:19:48,670
I would say, generally classes are
defined at the top of the file.

2819
02:19:48,670 --> 02:19:53,110
However, it would be even maybe
cleaner to move the Classes definition

2820
02:19:53,110 --> 02:19:56,290
to its own file and then
import it, so essentially

2821
02:19:56,290 --> 02:19:59,950
to make reusable code by putting
it into your own module or package

2822
02:19:59,950 --> 02:20:02,290
so that not just this
program but many others

2823
02:20:02,290 --> 02:20:04,760
can use that definition
of student as well.

2824
02:20:04,760 --> 02:20:08,950
Other questions now on classes,
class methods, or the like.

2825
02:20:08,950 --> 02:20:16,060
AUDIENCE: I wanted to ask, is there
a way to declare all the possible--

2826
02:20:16,060 --> 02:20:18,790
all the possible
attributes of the class?

2827
02:20:18,790 --> 02:20:22,200
Because it looks so inconsistent.

2828
02:20:22,200 --> 02:20:23,950
DAVID J. MALAN: Well,
so my takeaway there

2829
02:20:23,950 --> 02:20:26,407
is this is Python's approach
to these principles.

2830
02:20:26,407 --> 02:20:28,990
Different languages, like Java,
just take a different approach

2831
02:20:28,990 --> 02:20:30,890
but have very similar features.

2832
02:20:30,890 --> 02:20:32,690
The syntax just tends to vary.

2833
02:20:32,690 --> 02:20:36,430
And this is how the Python community
chose to implement this idea.

2834
02:20:36,430 --> 02:20:39,970
The right mental model, ultimately,
is that these instance variables,

2835
02:20:39,970 --> 02:20:46,150
instant methods belong to or
operate on specific objects--

2836
02:20:46,150 --> 02:20:48,970
a specific student, a specific hat.

2837
02:20:48,970 --> 02:20:53,710
Class variables and class methods
operate on the entire class

2838
02:20:53,710 --> 02:20:57,340
itself or, in turn, all
objects of that class, which

2839
02:20:57,340 --> 02:21:01,210
we've not seen a demonstration of,
but it's a higher level concept.

2840
02:21:01,210 --> 02:21:03,790
So it turns out, besides
these class methods,

2841
02:21:03,790 --> 02:21:06,850
which are distinct from those
instance methods, which, to be fair,

2842
02:21:06,850 --> 02:21:10,600
do not have their own decorator-- they
just are, by default, instance method,

2843
02:21:10,600 --> 02:21:13,660
there's yet other types of Methods
You can have in classes in Python.

2844
02:21:13,660 --> 02:21:16,090
They tend to be called static
methods, and they, too,

2845
02:21:16,090 --> 02:21:19,240
come with another decorator
called @static method, which

2846
02:21:19,240 --> 02:21:20,860
is a rabbit hole we won't go down.

2847
02:21:20,860 --> 02:21:23,350
But realize that there is
yet other functionality

2848
02:21:23,350 --> 02:21:25,960
that you can leverage within
object-oriented programming.

2849
02:21:25,960 --> 02:21:30,250
But what we thought we'd do is focus
really on some final core features

2850
02:21:30,250 --> 02:21:33,380
that you see not just in Python
but other languages as well.

2851
02:21:33,380 --> 02:21:36,940
And perhaps one of the most compelling
features of object-oriented programming

2852
02:21:36,940 --> 02:21:40,570
that we haven't yet used explicitly--
though it turns out we've seen

2853
02:21:40,570 --> 02:21:42,670
implicitly over the past weeks--

2854
02:21:42,670 --> 02:21:44,830
is this notion of inheritance.

2855
02:21:44,830 --> 02:21:47,470
It turns out, via
object-oriented programming,

2856
02:21:47,470 --> 02:21:50,860
there's actually an opportunity
to design your classes

2857
02:21:50,860 --> 02:21:56,350
in a hierarchical fashion, whereby
you can have one class inherit from

2858
02:21:56,350 --> 02:22:02,050
or borrow attributes-- that is,
methods or variables from another class

2859
02:22:02,050 --> 02:22:04,520
if they all have those in common.

2860
02:22:04,520 --> 02:22:06,310
So what do I mean by this here?

2861
02:22:06,310 --> 02:22:10,900
Well, let me propose that we
implement, over in VS Code here,

2862
02:22:10,900 --> 02:22:13,450
a brand new file called wizard.py.

2863
02:22:13,450 --> 02:22:16,780
Let me go ahead and
run code of wizard.py.

2864
02:22:16,780 --> 02:22:21,550
And then let's start as before,
defining a class called student.

2865
02:22:21,550 --> 02:22:25,605
And let's go ahead and first define
the underscore underscore, init method,

2866
02:22:25,605 --> 02:22:28,480
which of course, is minimally going
to take an argument traditionally

2867
02:22:28,480 --> 02:22:29,200
called self.

2868
02:22:29,200 --> 02:22:32,590
And in this case, let's also have it
take as before a name and a house.

2869
02:22:32,590 --> 02:22:35,080
And then in this init
method, let's go ahead

2870
02:22:35,080 --> 02:22:39,430
and assign the instance
variables-- self.name = name,

2871
02:22:39,430 --> 02:22:42,400
and self.house = house.

2872
02:22:42,400 --> 02:22:44,590
Let's assume that there's
some other functionality

2873
02:22:44,590 --> 02:22:46,300
in this class as well-- dot, dot, dot.

2874
02:22:46,300 --> 02:22:49,630
But let's move on now to implementing
the notion of a professor

2875
02:22:49,630 --> 02:22:51,410
in the wizarding world as well.

2876
02:22:51,410 --> 02:22:55,840
So for this class,
let's call it Professor.

2877
02:22:55,840 --> 02:22:58,180
And a professor, let's
say, is also going

2878
02:22:58,180 --> 02:23:00,620
to have its own initialization method.

2879
02:23:00,620 --> 02:23:01,900
So __ init.

2880
02:23:01,900 --> 02:23:03,190
It's going to take self--

2881
02:23:03,190 --> 02:23:04,990
always as the first argument.

2882
02:23:04,990 --> 02:23:06,710
A professor also has a name.

2883
02:23:06,710 --> 02:23:08,380
So we'll pass that in second, too.

2884
02:23:08,380 --> 02:23:11,170
And even though some
professors are heads of houses,

2885
02:23:11,170 --> 02:23:13,270
let's assume that a professor
is really identified

2886
02:23:13,270 --> 02:23:16,720
by their name and their subject
area-- the class that they teach.

2887
02:23:16,720 --> 02:23:19,240
So we'll call this
third argument, subject.

2888
02:23:19,240 --> 02:23:23,020
Now, as before, let's go ahead
and assign self.name = name,

2889
02:23:23,020 --> 02:23:27,310
and let's assign
self.subject = subject here.

2890
02:23:27,310 --> 02:23:30,730
And as before, let's assume that there's
some more functionality associated

2891
02:23:30,730 --> 02:23:32,290
with professors as well.

2892
02:23:32,290 --> 02:23:36,820
Well, what do you notice already
here in my definitions of students

2893
02:23:36,820 --> 02:23:38,530
and professors?

2894
02:23:38,530 --> 02:23:42,940
Typically, we're a bit reluctant to
allow for any redundancy in our code.

2895
02:23:42,940 --> 02:23:47,230
And here, I feel like my init method
is taking a name for students;

2896
02:23:47,230 --> 02:23:49,840
my init method is also taking
a name for a professor;

2897
02:23:49,840 --> 02:23:53,680
and I have these identical lines
of code, like self.name = name.

2898
02:23:53,680 --> 02:23:56,410
And this is only going to get
exacerbated if I now go and add

2899
02:23:56,410 --> 02:23:57,280
some error checking.

2900
02:23:57,280 --> 02:24:01,143
So for instance, how
about if not name, we

2901
02:24:01,143 --> 02:24:03,310
should probably be in the
habit of raising something

2902
02:24:03,310 --> 02:24:07,420
like a value error in an explanatory
message, like "Missing name."

2903
02:24:07,420 --> 02:24:08,380
And you know what?

2904
02:24:08,380 --> 02:24:10,960
If a professor is missing
their name, I should probably

2905
02:24:10,960 --> 02:24:12,500
copy, paste that code down here.

2906
02:24:12,500 --> 02:24:14,860
And that's where red
flags should be going off,

2907
02:24:14,860 --> 02:24:17,140
whereby, as soon as you
start copy pasting code,

2908
02:24:17,140 --> 02:24:21,430
there's probably a better way so that
we can write the code once and perhaps

2909
02:24:21,430 --> 02:24:22,690
reuse it in some way.

2910
02:24:22,690 --> 02:24:26,120
And here, too, object-oriented
programming offers a solution.

2911
02:24:26,120 --> 02:24:29,230
It turns out that object-oriented
programming in Python

2912
02:24:29,230 --> 02:24:34,660
also supports inheritance, whereby
you can define multiple classes that

2913
02:24:34,660 --> 02:24:36,350
somehow relate to one another.

2914
02:24:36,350 --> 02:24:39,040
They don't need to exist
in parallel in this way.

2915
02:24:39,040 --> 02:24:41,570
There could actually be
some hierarchy between them.

2916
02:24:41,570 --> 02:24:43,540
So for instance, in
the wizarding world, we

2917
02:24:43,540 --> 02:24:46,810
could argue that both a student and a
professor are, at the end of the day,

2918
02:24:46,810 --> 02:24:47,500
Wizards.

2919
02:24:47,500 --> 02:24:50,890
So maybe what we should really
define is a third class,

2920
02:24:50,890 --> 02:24:53,170
for instance, called
wizard, that has any

2921
02:24:53,170 --> 02:24:57,125
of the common attributes for
students and professors alike.

2922
02:24:57,125 --> 02:24:59,000
And for now, we've kept
it relatively simple.

2923
02:24:59,000 --> 02:25:01,870
The only thing they have in
common is a name and a name,

2924
02:25:01,870 --> 02:25:03,680
in student and professor, respectively.

2925
02:25:03,680 --> 02:25:06,610
So why don't we minimally
factor that out first?

2926
02:25:06,610 --> 02:25:08,275
All right, so let me go ahead here.

2927
02:25:08,275 --> 02:25:10,900
And just to keep things organized,
at the top of my file, let's

2928
02:25:10,900 --> 02:25:13,060
define a third class called Wizard.

2929
02:25:13,060 --> 02:25:16,400
And a wizard will have its
own initialization method.

2930
02:25:16,400 --> 02:25:20,770
So def __init__(self), as always.

2931
02:25:20,770 --> 02:25:23,530
And a wizard, let's say
for now, is only going

2932
02:25:23,530 --> 02:25:26,830
to be initialized with
their name in this way.

2933
02:25:26,830 --> 02:25:29,990
And now, I'm going to go ahead and
do some of that error checking.

2934
02:25:29,990 --> 02:25:33,920
So if not name will raise a
value error in the wizard class.

2935
02:25:33,920 --> 02:25:37,240
Otherwise, we'll go ahead
and do self name equals name,

2936
02:25:37,240 --> 02:25:40,870
and, heck, dot, dot, dot, maybe
some other functionality as well.

2937
02:25:40,870 --> 02:25:44,240
But not a subject, which is specific
to professors, and not a house,

2938
02:25:44,240 --> 02:25:46,390
which I've claimed is
specific to students.

2939
02:25:46,390 --> 02:25:49,570
Now, I think we can
begin to maybe remove

2940
02:25:49,570 --> 02:25:52,040
some of the redundancies
in our other classes here.

2941
02:25:52,040 --> 02:25:55,630
So for instance, down
with student, why don't I

2942
02:25:55,630 --> 02:25:59,950
go ahead and remove this error
checking here and remove this error--

2943
02:25:59,950 --> 02:26:03,370
this assignment of self.name
= name because I'm already

2944
02:26:03,370 --> 02:26:04,513
doing that in Wizard.

2945
02:26:04,513 --> 02:26:07,180
And similarly, down here, in
Professor, why don't I do the same?

2946
02:26:07,180 --> 02:26:08,810
Let's get rid of the error checking.

2947
02:26:08,810 --> 02:26:12,280
Let's get rid of self.name = name
because, again, I'm doing that already

2948
02:26:12,280 --> 02:26:14,270
up there for Wizard as well.

2949
02:26:14,270 --> 02:26:17,140
But at the moment, even though
they're all in the same file,

2950
02:26:17,140 --> 02:26:21,880
I haven't told Python that a student is
a wizard and a professor is a wizard.

2951
02:26:21,880 --> 02:26:24,190
So I really need to
link these two together.

2952
02:26:24,190 --> 02:26:28,690
And the way you can prescribe
inheritance, whereby one class should

2953
02:26:28,690 --> 02:26:31,270
inherit from another,
or conversely, one class

2954
02:26:31,270 --> 02:26:34,750
should descend from
another-- we can do this.

2955
02:26:34,750 --> 02:26:36,340
I can say class Student.

2956
02:26:36,340 --> 02:26:39,610
But before the colon, I can
go in and say in parentheses,

2957
02:26:39,610 --> 02:26:45,130
a student inherits from, or is a
subclass of wizard, which, conversely,

2958
02:26:45,130 --> 02:26:47,890
is the superclass of the student class.

2959
02:26:47,890 --> 02:26:50,810
So this just means that, when
I define a student class,

2960
02:26:50,810 --> 02:26:55,180
go ahead and inherit all of the
characteristics of a wizard as well.

2961
02:26:55,180 --> 02:26:58,090
And I'm going to do the
same thing for Professor.

2962
02:26:58,090 --> 02:27:01,360
So (Wizard) after the
class name Professor,

2963
02:27:01,360 --> 02:27:05,030
and that's going to give me access
to some of that same functionality.

2964
02:27:05,030 --> 02:27:08,680
But because my student
class and my professor class

2965
02:27:08,680 --> 02:27:10,615
still have their same
init methods, those

2966
02:27:10,615 --> 02:27:12,490
are the methods that
are going to get called.

2967
02:27:12,490 --> 02:27:16,120
Whenever I create a student in code
or I create a professor in code,

2968
02:27:16,120 --> 02:27:18,820
I need to somehow
explicitly say that I also

2969
02:27:18,820 --> 02:27:23,110
want to use the functionality in
the Wizard class's init method.

2970
02:27:23,110 --> 02:27:26,120
And the way to do this
in Python is as follows.

2971
02:27:26,120 --> 02:27:28,150
Let me go into my init
method for Student,

2972
02:27:28,150 --> 02:27:31,180
and let me call super,
with no arguments, which

2973
02:27:31,180 --> 02:27:34,550
is a reference to the
superclass of this class.

2974
02:27:34,550 --> 02:27:37,120
So if this class is Student,
the superclass-- that is,

2975
02:27:37,120 --> 02:27:38,980
the parent class-- is Wizard.

2976
02:27:38,980 --> 02:27:45,070
So super() will have the effect
of accessing the superclass.

2977
02:27:45,070 --> 02:27:48,940
And then I'm going to go ahead and
explicitly call its init method,

2978
02:27:48,940 --> 02:27:52,630
and I'm going to pass to
the Wizard's init method

2979
02:27:52,630 --> 02:27:56,160
the name that the student's
init method was passed.

2980
02:27:56,160 --> 02:27:59,190
And I'm going to go ahead and
do the same down here in Wizard.

2981
02:27:59,190 --> 02:28:00,870
This is one line of copy, paste.

2982
02:28:00,870 --> 02:28:03,600
But I think I'm OK with
it here because it's still

2983
02:28:03,600 --> 02:28:05,490
allowing me to do all
of the name assignment

2984
02:28:05,490 --> 02:28:08,190
and the error checking up
in the Wizard class instead.

2985
02:28:08,190 --> 02:28:13,470
I think we're OK now by just
calling super.init for both student

2986
02:28:13,470 --> 02:28:14,610
and Professor alike.

2987
02:28:14,610 --> 02:28:18,420
Now, admittedly, this syntax is
definitely out there-- the fact

2988
02:28:18,420 --> 02:28:20,760
that we're calling super
in parentheses and dots

2989
02:28:20,760 --> 02:28:23,670
and underscore underscore on the
left and the right of init here,

2990
02:28:23,670 --> 02:28:26,100
but it's just a combination
of these two ideas.

2991
02:28:26,100 --> 02:28:32,130
super() is a way of programmatically
accessing a current class's parent

2992
02:28:32,130 --> 02:28:36,480
class, or superclass, and __init, of
course, is just referring to, now,

2993
02:28:36,480 --> 02:28:39,243
that class's own initialization method.

2994
02:28:39,243 --> 02:28:41,160
Now, per the dot, dot,
dot-- so there could be

2995
02:28:41,160 --> 02:28:42,702
a lot more going on in these classes.

2996
02:28:42,702 --> 02:28:46,410
But what's nice now is
that Wizard as a class

2997
02:28:46,410 --> 02:28:49,500
is taking care of all of the
assignment of a wizard's name,

2998
02:28:49,500 --> 02:28:51,652
whether that wizard is a
student or a professor.

2999
02:28:51,652 --> 02:28:53,610
And it's even doing some
error checking to make

3000
02:28:53,610 --> 02:28:56,320
sure the name was actually passed in.

3001
02:28:56,320 --> 02:29:00,390
Meanwhile, student is inheriting
all of that functionality

3002
02:29:00,390 --> 02:29:03,540
and using it by calling the
superclass's own init method.

3003
02:29:03,540 --> 02:29:06,270
But it's additionally taking
the house, that's presumably

3004
02:29:06,270 --> 02:29:08,580
passed into the student
constructor function,

3005
02:29:08,580 --> 02:29:12,060
and assigning it to its own
instance variable-- self.house,

3006
02:29:12,060 --> 02:29:15,660
and similarly, professor,
or restoring in self.subject

3007
02:29:15,660 --> 02:29:19,090
the subject that was passed
into that one as well.

3008
02:29:19,090 --> 02:29:21,120
Now, how might we use these classes?

3009
02:29:21,120 --> 02:29:24,690
Well, we'll continue to wave our hands
with a little bit of detail here.

3010
02:29:24,690 --> 02:29:27,960
But at the bottom of this file, or
any other file that imports this one,

3011
02:29:27,960 --> 02:29:30,060
I could now write code like this.

3012
02:29:30,060 --> 02:29:32,400
I could create a student
variable and assign

3013
02:29:32,400 --> 02:29:34,680
it the return value of the
student constructor call.

3014
02:29:34,680 --> 02:29:38,820
and maybe that student is named
Harry and that student's house,

3015
02:29:38,820 --> 02:29:41,250
for instance, might be Gryffindor.

3016
02:29:41,250 --> 02:29:45,970
And meanwhile, I might do something like
this. professor = Professor over here.

3017
02:29:45,970 --> 02:29:49,740
And notice, the lowercase S on
the left, capital S on the right.

3018
02:29:49,740 --> 02:29:53,070
Same for professor on the left--
lowercase and uppercase on the right

3019
02:29:53,070 --> 02:29:53,940
respectively.

3020
02:29:53,940 --> 02:29:56,820
Professor, quote, unquote,
"Severus," and how

3021
02:29:56,820 --> 02:30:01,710
about Defense Against the
Dark Arts will be his subject?

3022
02:30:01,710 --> 02:30:04,020
And meanwhile, if we
want, more generically,

3023
02:30:04,020 --> 02:30:08,490
just a wizard, who, at the moment
is neither student nor professor

3024
02:30:08,490 --> 02:30:10,590
teaching classes actively,
we could even do that.

3025
02:30:10,590 --> 02:30:14,670
We could do wizard = Wizard in
capital W on the right-hand side

3026
02:30:14,670 --> 02:30:16,920
of the equal sign, because
it's the name of the class.

3027
02:30:16,920 --> 02:30:18,390
And someone like Albus--

3028
02:30:18,390 --> 02:30:21,150
passing in only Albus's name--

3029
02:30:21,150 --> 02:30:26,910
not a house, not a subject, because, in
this case, he's known only as a wizard.

3030
02:30:26,910 --> 02:30:29,970
Meanwhile, with each of these
calls, this line of code

3031
02:30:29,970 --> 02:30:33,030
here will ensure that the init method
for the wizard class is called.

3032
02:30:33,030 --> 02:30:36,810
This line of code here will ensure
that the init method of the student

3033
02:30:36,810 --> 02:30:40,440
class and, in turn, the init method
of the superclass wizard is called.

3034
02:30:40,440 --> 02:30:42,750
And then lastly, on
this final line of code,

3035
02:30:42,750 --> 02:30:46,830
will this syntax ensure that the
init method of the professor class

3036
02:30:46,830 --> 02:30:51,580
is called, which, in turn, calls the
init method of the superclass as well.

3037
02:30:51,580 --> 02:30:55,300
Any questions now on
this idea of inheritance,

3038
02:30:55,300 --> 02:31:00,330
which is a key feature of a lot of
object-oriented programming languages?

3039
02:31:00,330 --> 02:31:04,670


3040
02:31:04,670 --> 02:31:07,920
MICHAEL: From what I've seen so far, a
lot of times, there's a lot of nesting.

3041
02:31:07,920 --> 02:31:09,600
If you do super, does it go one up?

3042
02:31:09,600 --> 02:31:15,600
Is there any situation where it's nested
in another class as well, above Wizard,

3043
02:31:15,600 --> 02:31:16,100
let's say?

3044
02:31:16,100 --> 02:31:17,725
DAVID J. MALAN: A really good question.

3045
02:31:17,725 --> 02:31:19,590
If you were to have a
super superclass-- so

3046
02:31:19,590 --> 02:31:24,060
your hierarchy is even taller
than the two levels of hierarchy

3047
02:31:24,060 --> 02:31:27,840
that we currently have, absolutely.

3048
02:31:27,840 --> 02:31:30,450
What's nice about inheritance,
as the name implies, is,

3049
02:31:30,450 --> 02:31:33,810
just as you might have inherited
certain traits as a human

3050
02:31:33,810 --> 02:31:37,200
from your grandfather and
grandmother or your great-grandfather

3051
02:31:37,200 --> 02:31:39,540
or great-grandmother,
some of those properties

3052
02:31:39,540 --> 02:31:44,290
can actually trickle down to you
in the context of code as well.

3053
02:31:44,290 --> 02:31:48,480
So when you descend from another class--

3054
02:31:48,480 --> 02:31:52,770
that is, when you subclass a
superclass or a super superclass,

3055
02:31:52,770 --> 02:31:55,170
you actually do inherit
all of the functionality,

3056
02:31:55,170 --> 02:31:57,840
not just from one level above
you but from two or three,

3057
02:31:57,840 --> 02:32:00,780
so you can indeed access some
of that functionality as well.

3058
02:32:00,780 --> 02:32:03,870
And you can even override it if
you want some of these classes

3059
02:32:03,870 --> 02:32:06,960
to behave a little bit
differently than others.

3060
02:32:06,960 --> 02:32:09,350
Other questions on inheritance.

3061
02:32:09,350 --> 02:32:11,100
AUDIENCE: So it's
similar to the last one,

3062
02:32:11,100 --> 02:32:14,315
but can you have two
parents on the same level?

3063
02:32:14,315 --> 02:32:15,940
DAVID J. MALAN: A really good question.

3064
02:32:15,940 --> 02:32:21,080
So there are ways to implement
descendants from multiple parents.

3065
02:32:21,080 --> 02:32:24,330
And there's different ways to do this,
not just in Python but other languages.

3066
02:32:24,330 --> 02:32:29,130
We've kept things simple here, though,
by having a single inheritance path.

3067
02:32:29,130 --> 02:32:29,880
A good question.

3068
02:32:29,880 --> 02:32:32,490
How about one more
question on inheritance?

3069
02:32:32,490 --> 02:32:38,400
AUDIENCE: Can we have multiple
arguments in super.__init?

3070
02:32:38,400 --> 02:32:42,210
DAVID J. MALAN: Yes, but in this case,
I'm only passing a name on line 18,

3071
02:32:42,210 --> 02:32:44,860
and I'm only passing in name on line 10.

3072
02:32:44,860 --> 02:32:45,360
Why?

3073
02:32:45,360 --> 02:32:49,410
Because, on line 2, when I define
the init method for the Wizard class,

3074
02:32:49,410 --> 02:32:51,600
I only expect a single argument.

3075
02:32:51,600 --> 02:32:54,780
But I could absolutely have
other common functionality.

3076
02:32:54,780 --> 02:32:55,950
I could add in a patronus.

3077
02:32:55,950 --> 02:32:58,350
If both students and
professors have patronuses

3078
02:32:58,350 --> 02:33:02,160
that can come out of their wands,
I could have two arguments instead.

3079
02:33:02,160 --> 02:33:04,920
We've been using this feature
of object-oriented programming

3080
02:33:04,920 --> 02:33:08,220
now for quite some time
in the form of exceptions.

3081
02:33:08,220 --> 02:33:11,820
Indeed, if you look at the official
documentation for exceptions in Python,

3082
02:33:11,820 --> 02:33:14,430
you'll see that there's not even
the ones we've seen in class,

3083
02:33:14,430 --> 02:33:15,750
like value error and others.

3084
02:33:15,750 --> 02:33:19,860
There's any number of others as
well, but they are all, themselves,

3085
02:33:19,860 --> 02:33:21,340
hierarchical in nature.

3086
02:33:21,340 --> 02:33:25,620
This is just a subset of the available
exceptions that come built into Python.

3087
02:33:25,620 --> 02:33:29,350
And you can actually, as a programmer,
create your own exceptions as well.

3088
02:33:29,350 --> 02:33:33,120
But as this chart here
captures hierarchically,

3089
02:33:33,120 --> 02:33:37,350
all exceptions we've seen
thus far actually descend from

3090
02:33:37,350 --> 02:33:40,238
or inherit from superclasses already.

3091
02:33:40,238 --> 02:33:42,030
So for instance, at
the bottom of this list

3092
02:33:42,030 --> 02:33:44,440
here is ValueError, which
we've seen quite a bit.

3093
02:33:44,440 --> 02:33:48,790
And if you follow the line straight up
on this ascii rendition of this chart,

3094
02:33:48,790 --> 02:33:53,310
you'll see that ValueError has a parent,
class, or superclass, called exception.

3095
02:33:53,310 --> 02:33:57,150
And the exception class, meanwhile, has
a parent class called base exception.

3096
02:33:57,150 --> 02:33:59,320
Why did the authors of Python do this?

3097
02:33:59,320 --> 02:34:04,170
Well, it turns out that, whether you
have a value error or a key error

3098
02:34:04,170 --> 02:34:06,610
or an assertion error
or any number of others,

3099
02:34:06,610 --> 02:34:11,460
there's a lot of functionality common
to all of those types of errors

3100
02:34:11,460 --> 02:34:13,650
that you want--

3101
02:34:13,650 --> 02:34:16,180
that you want a programmer
to be able to use.

3102
02:34:16,180 --> 02:34:19,590
And so it turns out that the authors
of Python decided, you know what?

3103
02:34:19,590 --> 02:34:22,980
Let's not have a dozen
or more different classes

3104
02:34:22,980 --> 02:34:26,370
that all just have copy,
pasted similar functionality.

3105
02:34:26,370 --> 02:34:28,470
Let's create this
hierarchy so that, even

3106
02:34:28,470 --> 02:34:32,100
though the exceptions toward the
bottom of this list are very precise,

3107
02:34:32,100 --> 02:34:33,480
they at least inherit--

3108
02:34:33,480 --> 02:34:36,790
that is, borrow some very
common functionality up above.

3109
02:34:36,790 --> 02:34:40,770
So it turns out that, when you use the
Try and the Accept keyword in Python,

3110
02:34:40,770 --> 02:34:44,490
generally speaking, we've tried
to catch very specific exceptions,

3111
02:34:44,490 --> 02:34:45,510
like ValueError.

3112
02:34:45,510 --> 02:34:48,660
But technically, you could
capture the parents or even

3113
02:34:48,660 --> 02:34:51,565
the grandparent exception
for a given exception,

3114
02:34:51,565 --> 02:34:54,690
especially if you're not necessarily
sure which one is going to get raised.

3115
02:34:54,690 --> 02:34:58,260
Or, better yet, there could be
many exceptions that get raised,

3116
02:34:58,260 --> 02:35:00,150
but you want to handle
them all the same,

3117
02:35:00,150 --> 02:35:02,190
and you don't want to
necessarily enumerate them

3118
02:35:02,190 --> 02:35:04,240
in parentheses, separated by commas.

3119
02:35:04,240 --> 02:35:07,830
You want to say you want to handle
all exceptions of a certain superclass

3120
02:35:07,830 --> 02:35:09,640
in much the same way.

3121
02:35:09,640 --> 02:35:12,060
So this has been latent this
whole time, any time we've

3122
02:35:12,060 --> 02:35:16,380
seen or used or caught or, now, raised
exceptions, and built into Python

3123
02:35:16,380 --> 02:35:17,230
is this hierarchy.

3124
02:35:17,230 --> 02:35:19,140
And if you were to invent
your own exception,

3125
02:35:19,140 --> 02:35:21,460
generally, you wouldn't
want to start from scratch.

3126
02:35:21,460 --> 02:35:25,230
You would want to descend from-- that
is, subclass, one of these existing

3127
02:35:25,230 --> 02:35:30,150
exceptions and add your own twist on
it, your own functionality as well.

3128
02:35:30,150 --> 02:35:33,420
Well, there's one final feature
of object oriented programming

3129
02:35:33,420 --> 02:35:35,970
that we'd like to share
with you today, and then it

3130
02:35:35,970 --> 02:35:39,480
will perhaps be quite the eye opener
as to what you can really do now

3131
02:35:39,480 --> 02:35:41,400
that you have classes at your disposal.

3132
02:35:41,400 --> 02:35:44,010
And this, too, surprise,
has been a feature

3133
02:35:44,010 --> 02:35:46,680
you and I have been taking
for granted for weeks now.

3134
02:35:46,680 --> 02:35:49,470
This has just worked, but
it's been implemented in a way

3135
02:35:49,470 --> 02:35:51,420
that you can now leverage yourself.

3136
02:35:51,420 --> 02:35:54,360
It turns out that Python, and
some other languages, too,

3137
02:35:54,360 --> 02:35:58,260
support this notion of
operator overloading, whereby

3138
02:35:58,260 --> 02:36:03,450
you can take very common symbols, like
plus or minus or other such syntax

3139
02:36:03,450 --> 02:36:08,640
on the keyboard, and you can implement
your own interpretation thereof.

3140
02:36:08,640 --> 02:36:12,000
Plus does not have to equal addition.

3141
02:36:12,000 --> 02:36:14,520
And minus does not have
to equal subtraction.

3142
02:36:14,520 --> 02:36:16,920
And in fact, you and I have
already seen another context

3143
02:36:16,920 --> 02:36:19,770
in which plus means something else.

3144
02:36:19,770 --> 02:36:23,940
Plus has not always, in
Python, meant addition, per se.

3145
02:36:23,940 --> 02:36:27,665
What else has Python used plus for?

3146
02:36:27,665 --> 02:36:28,665
AUDIENCE: Concatenation?

3147
02:36:28,665 --> 02:36:30,082
DAVID J. MALAN: For concatenation.

3148
02:36:30,082 --> 02:36:34,090
For joining two strings, for adding
to a list can you use plus as well.

3149
02:36:34,090 --> 02:36:38,880
So plus has actually been, funny enough,
overloaded by the authors of Python

3150
02:36:38,880 --> 02:36:39,730
for us.

3151
02:36:39,730 --> 02:36:43,200
And so we can use the same symbol
in much the same way as addition

3152
02:36:43,200 --> 02:36:46,470
but with different data types to
solve slightly different problems.

3153
02:36:46,470 --> 02:36:49,440
Well, let me propose that we
go back over to VS Code here,

3154
02:36:49,440 --> 02:36:53,460
and let me go ahead and create a
new final file called vault.py.

3155
02:36:53,460 --> 02:36:55,200
So code of vault.py.

3156
02:36:55,200 --> 02:36:58,620
And let me propose that we
implement the idea of a vault

3157
02:36:58,620 --> 02:37:01,740
at Gringotts, keeping on
theme, wherein there's

3158
02:37:01,740 --> 02:37:03,480
a bank in the world of Harry Potter.

3159
02:37:03,480 --> 02:37:06,300
And within this bank,
families and individuals

3160
02:37:06,300 --> 02:37:10,170
have vaults containing all sorts
of money in the wizarding world.

3161
02:37:10,170 --> 02:37:12,780
And the type of money that exists
in the world of Harry Potter

3162
02:37:12,780 --> 02:37:15,990
are coins called galleons
and sickles and Knuts,

3163
02:37:15,990 --> 02:37:18,310
and those are in
descending order of value.

3164
02:37:18,310 --> 02:37:20,940
And so inside of a vault might
be a whole bunch of coins--

3165
02:37:20,940 --> 02:37:24,210
gold, silver, and bronze, essentially,
each in those denominations,

3166
02:37:24,210 --> 02:37:25,050
tucked away.

3167
02:37:25,050 --> 02:37:29,280
So how can I go about implementing,
first of all, the idea of a vault

3168
02:37:29,280 --> 02:37:33,570
so that I can store, for instance,
for Harry Potter, how much coinage

3169
02:37:33,570 --> 02:37:37,110
is in his family's vault,
or for Ron Weasley the same?

3170
02:37:37,110 --> 02:37:39,510
Well, let me go ahead
and vault.py and first

3171
02:37:39,510 --> 02:37:43,500
create a class called Vault, essentially
meant to represent a bank vault.

3172
02:37:43,500 --> 02:37:46,200
Perfect, another real
world, or fantasy world,

3173
02:37:46,200 --> 02:37:48,690
entity that I want to
represent with code.

3174
02:37:48,690 --> 02:37:51,180
I could use a tuple or
a list or a dictionary.

3175
02:37:51,180 --> 02:37:54,300
But again, I'm going to get a lot
more functionality with classes,

3176
02:37:54,300 --> 02:37:57,340
and we'll see one final
flourish with operators.

3177
02:37:57,340 --> 02:38:00,080
Inside of this vault class,
let's go ahead and do this.

3178
02:38:00,080 --> 02:38:03,850
Let me define my init method,
taking its first argument of self.

3179
02:38:03,850 --> 02:38:06,850
And let me define three
arguments to this.

3180
02:38:06,850 --> 02:38:09,760
When you create a
vault, in my code here,

3181
02:38:09,760 --> 02:38:12,970
I want to be able to initialize it with
some number of galleons, some number

3182
02:38:12,970 --> 02:38:14,590
of sickles and, some number of Knuts.

3183
02:38:14,590 --> 02:38:17,980
I want the user, the programmer,
to be able to pass in one or more

3184
02:38:17,980 --> 02:38:19,060
of those values ideally.

3185
02:38:19,060 --> 02:38:21,310
But they can be optional,
so I'll give them defaults.

3186
02:38:21,310 --> 02:38:24,190
So let's go ahead and define
a parameter called galleons,

3187
02:38:24,190 --> 02:38:28,270
whose default value will be 0; sickles,
whose default value will also be 0;

3188
02:38:28,270 --> 02:38:31,310
and knuts, whose default
value will be 0 as well.

3189
02:38:31,310 --> 02:38:35,770
So the programmer can pass in one or
two or three or even none of those,

3190
02:38:35,770 --> 02:38:38,330
and they'll all have
some implied defaults.

3191
02:38:38,330 --> 02:38:41,710
How do I want to remember those
values that are passed in?

3192
02:38:41,710 --> 02:38:42,760
Well, let me do this.

3193
02:38:42,760 --> 02:38:45,790
self.galleons = galleons.

3194
02:38:45,790 --> 02:38:48,610
And self.sickles = sickles.

3195
02:38:48,610 --> 02:38:51,910
And self.knuts = knuts.

3196
02:38:51,910 --> 02:38:55,750
And so I could add some error checking,
especially if you don't pass in.

3197
02:38:55,750 --> 02:38:58,930
A number I could turn these into
properties to do even more validation.

3198
02:38:58,930 --> 02:39:01,980
But let's keep it simple and, as
always, focus only on the new ideas.

3199
02:39:01,980 --> 02:39:04,480
So I'm just going to trust that
these values were passed in,

3200
02:39:04,480 --> 02:39:07,930
and I'm going to immediately assign
them to these instance variables.

3201
02:39:07,930 --> 02:39:09,620
What, now, do I want to do?

3202
02:39:09,620 --> 02:39:12,400
Well, let's come up with
a way of printing out

3203
02:39:12,400 --> 02:39:15,220
what is in someone's vault, ultimately.

3204
02:39:15,220 --> 02:39:16,520
But first let's do this.

3205
02:39:16,520 --> 02:39:21,310
Let's create a vault for the Potters by
creating, via assignment, a new vault.

3206
02:39:21,310 --> 02:39:26,350
And let's say that the potters have
100 galleons, 50 sickles, and 24 knuts.

3207
02:39:26,350 --> 02:39:29,770
And that's in that vault. And let's
print out, for instance, potter.

3208
02:39:29,770 --> 02:39:32,140
All right, let's run this
code and see how it works now.

3209
02:39:32,140 --> 02:39:36,310
Let me go ahead and run
Python of vault.py, Enter.

3210
02:39:36,310 --> 02:39:37,300
Seems to work.

3211
02:39:37,300 --> 02:39:39,250
No syntax errors or anything else.

3212
02:39:39,250 --> 02:39:42,010
But this is not very enlightening.

3213
02:39:42,010 --> 02:39:46,480
How do I fix this, thinking
back to what we've done before?

3214
02:39:46,480 --> 02:39:49,170
AUDIENCE: You have to use the __str.

3215
02:39:49,170 --> 02:39:50,170
DAVID J. MALAN: Exactly.

3216
02:39:50,170 --> 02:39:53,500
I need to use one of those special
methods that comes with classes

3217
02:39:53,500 --> 02:39:57,828
and define for myself how I want
a vault to be printed as a string.

3218
02:39:57,828 --> 02:39:59,120
So let me go ahead and do that.

3219
02:39:59,120 --> 02:40:03,760
Let me define the str method taking
in self as its sole argument here.

3220
02:40:03,760 --> 02:40:05,710
And let's just return
a very simple string

3221
02:40:05,710 --> 02:40:08,050
that just reveals what's in the vault.

3222
02:40:08,050 --> 02:40:11,170
So I'm going to return
a formatted f string,

3223
02:40:11,170 --> 02:40:15,370
inside of which is self.galleons
and then the word galleon,

3224
02:40:15,370 --> 02:40:17,080
so I know which those are.

3225
02:40:17,080 --> 02:40:20,650
Then let's do self.sickles, and
let's output the word, sickles.

3226
02:40:20,650 --> 02:40:24,310
And then lastly let's output
self.knuts, and then knuts here.

3227
02:40:24,310 --> 02:40:29,230
So I know, in this string, just
how many of each of those coins

3228
02:40:29,230 --> 02:40:32,860
I have in this particular family's
vault. All right, let me go ahead

3229
02:40:32,860 --> 02:40:37,370
and run Python of vault.py, changing
nothing else except the str method.

3230
02:40:37,370 --> 02:40:42,823
And now, , we, see indeed that Harry has
100 galleons, 50 sickles, and 25 knuts.

3231
02:40:42,823 --> 02:40:44,740
All right, well, let's
do one thing more here.

3232
02:40:44,740 --> 02:40:48,100
Below that, let's go ahead
and define a Weasley variable.

3233
02:40:48,100 --> 02:40:51,790
And Ron never seemed to have quite as
much money in the vault as did Harry.

3234
02:40:51,790 --> 02:40:55,730
So let's say that the Weasley
vault will have 25, 50, and 100.

3235
02:40:55,730 --> 02:40:58,240
So I'll just reverse the
order of those denominations,

3236
02:40:58,240 --> 02:41:00,740
rather than Harry's 100, 50, 25.

3237
02:41:00,740 --> 02:41:04,340
And now let me go ahead and
print Weasley like this.

3238
02:41:04,340 --> 02:41:08,500
And let's go ahead and clear my
terminal window, run Python of vault.py.

3239
02:41:08,500 --> 02:41:11,770
This time, that str method
will be invoked twice, once

3240
02:41:11,770 --> 02:41:13,610
for each of those vault objects.

3241
02:41:13,610 --> 02:41:15,880
And we'll see, indeed, that
the first one for Harry

3242
02:41:15,880 --> 02:41:19,330
has got 100, 50, and 25,
respectively, versus Ron's 25, 50,

3243
02:41:19,330 --> 02:41:21,790
and 100, respectively.

3244
02:41:21,790 --> 02:41:23,680
But now let's do something interesting.

3245
02:41:23,680 --> 02:41:27,550
Suppose that you wanted to combine
the contents of two vaults,

3246
02:41:27,550 --> 02:41:30,100
be it Harry's and Ron's
or any other two people.

3247
02:41:30,100 --> 02:41:33,280
How would you go about
doing this in code?

3248
02:41:33,280 --> 02:41:37,190
Well, if I wanted to combine the
vaults for someone, I could do this.

3249
02:41:37,190 --> 02:41:39,550
Well, I could do galleons equals--

3250
02:41:39,550 --> 02:41:45,160
let's do potter.galleons
+ weasley.galleons.

3251
02:41:45,160 --> 02:41:47,470
That gives me a variable
called galleons that has

3252
02:41:47,470 --> 02:41:50,230
the sum of Harry and Ron's galleons.

3253
02:41:50,230 --> 02:41:56,560
Let's next do sickles =
potter.sickles + weasley.sickles.

3254
02:41:56,560 --> 02:42:03,130
And then lastly, let's do knuts
= potter.knuts + weasley.knuts.

3255
02:42:03,130 --> 02:42:04,180
I've got three variables.

3256
02:42:04,180 --> 02:42:05,870
What can I now do with these values?

3257
02:42:05,870 --> 02:42:09,040
Well, let's create a third--
a new vault. Total will

3258
02:42:09,040 --> 02:42:12,640
be the name of this variable equals
a new vault, Capital V, notice.

3259
02:42:12,640 --> 02:42:15,130
And now, let's pass in
those three new variables--

3260
02:42:15,130 --> 02:42:18,220
galleons, sickles, and knuts.

3261
02:42:18,220 --> 02:42:20,830
And that's it, and let's
print out this total vault.

3262
02:42:20,830 --> 02:42:23,950
So we should now see three
vaults-- one for Harry, for Ron,

3263
02:42:23,950 --> 02:42:26,410
and the combination--
the addition of the two.

3264
02:42:26,410 --> 02:42:30,100
Let me go ahead and rerun Python
of vault.py, and there we have it.

3265
02:42:30,100 --> 02:42:36,100
What was 100, 50, 25 and 25, 50, and
100, combined through addition now,

3266
02:42:36,100 --> 02:42:39,460
is 125, 100, 125.

3267
02:42:39,460 --> 02:42:41,740
So pretty straightforward,
using techniques from weeks

3268
02:42:41,740 --> 02:42:45,760
ago, where we're just declaring a few
new variables and doing some addition.

3269
02:42:45,760 --> 02:42:49,420
But wouldn't it be cool if I
could do something like this?

3270
02:42:49,420 --> 02:42:51,760
Wouldn't it be cool if
I could just somehow,

3271
02:42:51,760 --> 02:42:55,750
not manually create my own vault and
do all of this annoying math up here--

3272
02:42:55,750 --> 02:43:01,750
what if I could just do potter + weasley
and get rid of all of this logic here?

3273
02:43:01,750 --> 02:43:05,950
Wouldn't it be nice if I
overload the operator--

3274
02:43:05,950 --> 02:43:08,890
we know as plus, just
like str does, just

3275
02:43:08,890 --> 02:43:13,270
like list does-- to allow me
to add two vaults together

3276
02:43:13,270 --> 02:43:15,070
on the left and the right.

3277
02:43:15,070 --> 02:43:19,450
Well, it turns out in Python and
through operator overloading,

3278
02:43:19,450 --> 02:43:21,460
there is a way to do just this.

3279
02:43:21,460 --> 02:43:23,920
If you consult the
documentation, there's

3280
02:43:23,920 --> 02:43:27,940
this and so many other special
methods that come with classes.

3281
02:43:27,940 --> 02:43:31,120
The third one we'll see
here is this one here--

3282
02:43:31,120 --> 02:43:34,503
__add__.

3283
02:43:34,503 --> 02:43:36,670
And you'll see that it very
generically is described

3284
02:43:36,670 --> 02:43:40,540
in the documentation is working for
any object, be it a vault or str

3285
02:43:40,540 --> 02:43:41,980
or a list or something else.

3286
02:43:41,980 --> 02:43:44,680
By convention, it's going to take
a first argument called self,

3287
02:43:44,680 --> 02:43:48,280
and then it's going to take some other
argument, by convention, called other.

3288
02:43:48,280 --> 02:43:51,310
self, in effect, is going
to be referring to whatever

3289
02:43:51,310 --> 02:43:53,440
object is on the left of a plus sign.

3290
02:43:53,440 --> 02:43:55,360
other is going to be
referring to whatever

3291
02:43:55,360 --> 02:43:57,520
is on the right-hand
side of a plus sign,

3292
02:43:57,520 --> 02:44:01,540
thereby giving us a way of
describing, in code, the operand

3293
02:44:01,540 --> 02:44:06,640
on the left and the operand on the
right of the operator, plus, in between.

3294
02:44:06,640 --> 02:44:09,160
That is to say, if I go
back to VS Code here,

3295
02:44:09,160 --> 02:44:13,300
what I'm trying to do is
implement support for this.

3296
02:44:13,300 --> 02:44:16,270
Well, let me try, without
writing any other code just yet--

3297
02:44:16,270 --> 02:44:18,760
Python of vault.py, Enter--

3298
02:44:18,760 --> 02:44:24,760
TypeError: unsupported operand
type(s) for +: 'Vault' and 'vault.'

3299
02:44:24,760 --> 02:44:27,940
That is to say Python, at this
moment, does not know what

3300
02:44:27,940 --> 02:44:30,310
it means to add two vaults together.

3301
02:44:30,310 --> 02:44:31,690
You and I might have an instinct.

3302
02:44:31,690 --> 02:44:35,170
Probably want to combine the galleons
and the sickles and the knuts

3303
02:44:35,170 --> 02:44:36,010
respectively.

3304
02:44:36,010 --> 02:44:37,180
Python doesn't know that.

3305
02:44:37,180 --> 02:44:39,490
It just knows that you have
a new class called Vault.

3306
02:44:39,490 --> 02:44:41,440
But let's teach Python to do this.

3307
02:44:41,440 --> 02:44:43,360
Let me clear my terminal window.

3308
02:44:43,360 --> 02:44:46,430
Let me scroll back up to the class
itself, where, at the moment,

3309
02:44:46,430 --> 02:44:49,450
I only have two special
methods-- init and str.

3310
02:44:49,450 --> 02:44:51,670
But let's add this third.

3311
02:44:51,670 --> 02:44:57,820
Let me go into the class here and define
__add__ and then specify its first

3312
02:44:57,820 --> 02:45:02,020
parameter as self, as before, and then
a second parameter for this particular

3313
02:45:02,020 --> 02:45:03,790
method called, by convention, other.

3314
02:45:03,790 --> 02:45:06,040
Now, as always, I could name
those parameters anything

3315
02:45:06,040 --> 02:45:08,207
I want, but I'm going to
stick with convention here.

3316
02:45:08,207 --> 02:45:10,240
And now, inside of
this method, am I going

3317
02:45:10,240 --> 02:45:13,570
to have to now add together
the contents of two vaults?

3318
02:45:13,570 --> 02:45:14,530
Well, what two vaults?

3319
02:45:14,530 --> 02:45:17,510
Well, if we scroll down to our
goal at hand, the goal, of course,

3320
02:45:17,510 --> 02:45:19,810
is to add this vault plus
this other vault-- potter

3321
02:45:19,810 --> 02:45:21,430
plus weasley, respectively.

3322
02:45:21,430 --> 02:45:25,150
Well, it turns out, in Python, that,
when you do overload an operator like

3323
02:45:25,150 --> 02:45:27,490
plus, what's going to
happen automatically,

3324
02:45:27,490 --> 02:45:32,860
as soon as Python sees that, is it's
going to call that __add__ method,

3325
02:45:32,860 --> 02:45:35,260
and it's going to pass
into it to arguments--

3326
02:45:35,260 --> 02:45:38,530
whatever the operand is on the
left-- potter, in this case--

3327
02:45:38,530 --> 02:45:41,890
and whatever the operand is on
the right-- weasley, in this case.

3328
02:45:41,890 --> 02:45:46,720
And those values are going to get passed
in as self and other, respectively.

3329
02:45:46,720 --> 02:45:49,570
What that means is that we can
access their contents up here

3330
02:45:49,570 --> 02:45:51,680
in our implementation of add as follows.

3331
02:45:51,680 --> 02:45:55,330
Let me go ahead and define a local
variable called galleons and set that

3332
02:45:55,330 --> 02:45:58,720
equal to, for instance,
the sum of self.galleons--

3333
02:45:58,720 --> 02:46:01,330
whatever's in Potter's
vault in this case,

3334
02:46:01,330 --> 02:46:04,270
plus whatever is in Wesley's
vault in this case, which

3335
02:46:04,270 --> 02:46:06,190
would be other.galleons.

3336
02:46:06,190 --> 02:46:07,900
Let me do the same for sickles.

3337
02:46:07,900 --> 02:46:11,320
self.sickles + other.sickles.

3338
02:46:11,320 --> 02:46:13,180
And let me lastly do that for knuts.

3339
02:46:13,180 --> 02:46:17,017
So self.knuts + other.knuts.

3340
02:46:17,017 --> 02:46:18,850
But at the end of the
day, I'm going to need

3341
02:46:18,850 --> 02:46:22,720
to return a brand new bigger vault
that contains all of those contents

3342
02:46:22,720 --> 02:46:23,440
together.

3343
02:46:23,440 --> 02:46:28,000
And if we ultimately want to assign that
bigger vault to a variable like total

3344
02:46:28,000 --> 02:46:32,300
here, on the left, we'd better
return a value from this add method.

3345
02:46:32,300 --> 02:46:36,010
So I'm going to go ahead and give myself
a brand new vault, as by returning

3346
02:46:36,010 --> 02:46:40,120
capital Vault, which of course, is going
to call my vault function into which

3347
02:46:40,120 --> 02:46:42,955
I can now pass some of those
initialization arguments.

3348
02:46:42,955 --> 02:46:44,830
Well, how many galleon,
sickles, and knuts do

3349
02:46:44,830 --> 02:46:46,750
I want this brand new vault to contain?

3350
02:46:46,750 --> 02:46:50,890
Well, I want it to contain this
many galleons this many sickles,

3351
02:46:50,890 --> 02:46:52,510
and this many knuts.

3352
02:46:52,510 --> 02:46:54,910
So ultimately, what we're
doing in this implementation

3353
02:46:54,910 --> 02:46:59,020
of add is adding together those
galleons, sickles, and knuts, passing

3354
02:46:59,020 --> 02:47:02,170
them to the vault function so that
we get a brand new bigger vault,

3355
02:47:02,170 --> 02:47:05,030
and return that altogether.

3356
02:47:05,030 --> 02:47:07,270
So now I've defined
this new special method

3357
02:47:07,270 --> 02:47:13,450
called add that should now just
make plus work for two vaults.

3358
02:47:13,450 --> 02:47:14,050
Let's see.

3359
02:47:14,050 --> 02:47:17,950
Let me run down to my terminal window,
Python of vault.py and hit Enter.

3360
02:47:17,950 --> 02:47:23,170
And voila, and now we've implemented
an overloaded operator, plus,

3361
02:47:23,170 --> 02:47:25,360
to do what you and I
as humans would hope

3362
02:47:25,360 --> 02:47:27,670
would be the case when you
add two vaults together.

3363
02:47:27,670 --> 02:47:30,130
But I've now written the
code more specifically

3364
02:47:30,130 --> 02:47:35,710
to teach Python what it means
concretely to add two vaults together.

3365
02:47:35,710 --> 02:47:37,900
And it's with very
similar code in effect,

3366
02:47:37,900 --> 02:47:40,750
underneath the hood, that Python
is doing this for two strings,

3367
02:47:40,750 --> 02:47:45,070
to concatenate them together, to joining
two lists into a new list with list,

3368
02:47:45,070 --> 02:47:48,080
and so many other classes as well.

3369
02:47:48,080 --> 02:47:53,380
Any questions now on operator
overloading or this example here.

3370
02:47:53,380 --> 02:47:55,090
AUDIENCE: How would
you go about creating

3371
02:47:55,090 --> 02:48:03,040
a function for adding a student and
a vault for two separate classes?

3372
02:48:03,040 --> 02:48:04,445
Would that be possible?

3373
02:48:04,445 --> 02:48:06,320
DAVID J. MALAN: Let me
see what happens here.

3374
02:48:06,320 --> 02:48:07,270
I don't know offhand.

3375
02:48:07,270 --> 02:48:08,063
Let's do this.

3376
02:48:08,063 --> 02:48:09,730
Let's create a str and see what happens.

3377
02:48:09,730 --> 02:48:12,080
If I add Potter plus a str--

3378
02:48:12,080 --> 02:48:12,700
str object.

3379
02:48:12,700 --> 02:48:13,870
Yeah, so it would work.

3380
02:48:13,870 --> 02:48:15,910
I'm just figuring this
out as I go here, Eric.

3381
02:48:15,910 --> 02:48:18,190
So just to be clear,
what I did was I just

3382
02:48:18,190 --> 02:48:20,170
changed weasley to str
just to see what would

3383
02:48:20,170 --> 02:48:25,360
happen when I add a vault plus a
str, and it will work, theoretically.

3384
02:48:25,360 --> 02:48:25,990
Why?

3385
02:48:25,990 --> 02:48:32,770
Because so long as the type of value on
the left has an add method implemented,

3386
02:48:32,770 --> 02:48:35,510
other can be any type that you want.

3387
02:48:35,510 --> 02:48:37,810
You just have to decide
and code what it's

3388
02:48:37,810 --> 02:48:40,840
going to mean conceptually to
add a vault plus a string, which,

3389
02:48:40,840 --> 02:48:44,660
in this case, probably doesn't make
any sense at all, but it's possible.

3390
02:48:44,660 --> 02:48:46,420
It's going to be the
operand on the left.

3391
02:48:46,420 --> 02:48:47,440
And I'm inferring that.

3392
02:48:47,440 --> 02:48:49,180
I did not know the answer a moment ago.

3393
02:48:49,180 --> 02:48:54,130
I'm inferring that because what I got
was an attribute error here on line 11

3394
02:48:54,130 --> 02:48:58,330
because Python did not like
this. other.galleons didn't work,

3395
02:48:58,330 --> 02:49:00,890
but I could make it work
by figuring something out.

3396
02:49:00,890 --> 02:49:02,020
Really good question.

3397
02:49:02,020 --> 02:49:03,520
Didn't know that one myself.

3398
02:49:03,520 --> 02:49:07,120
Other questions on operator overloading?

3399
02:49:07,120 --> 02:49:09,495
AUDIENCE: Can you define
new operators in Python?

3400
02:49:09,495 --> 02:49:10,870
DAVID J. MALAN: I don't think so.

3401
02:49:10,870 --> 02:49:15,790
There is a very long but precise list
of operators that you can overload.

3402
02:49:15,790 --> 02:49:19,720
I do not believe you can
assign arbitrary characters

3403
02:49:19,720 --> 02:49:21,760
to be operators in Python.

3404
02:49:21,760 --> 02:49:23,682
Let me defer to Carter in the chat to--

3405
02:49:23,682 --> 02:49:26,390
OK, I'm seeing two of my colleagues
are saying, no, not possible.

3406
02:49:26,390 --> 02:49:28,383
So I'm going to go with
my first instinct, no.

3407
02:49:28,383 --> 02:49:29,800
Otherwise, that'd be kind of cool.

3408
02:49:29,800 --> 02:49:32,080
You could make emoji do
whatever you want to.

3409
02:49:32,080 --> 02:49:35,200
How about one final question
on operator overloading?

3410
02:49:35,200 --> 02:49:39,640
AUDIENCE: Is that the only
operation you can do as far as--

3411
02:49:39,640 --> 02:49:41,250
can you do a subtraction as well?

3412
02:49:41,250 --> 02:49:42,250
DAVID J. MALAN: You can.

3413
02:49:42,250 --> 02:49:44,800
You can do so many others let me.

3414
02:49:44,800 --> 02:49:47,810
If, Carter, you don't mind
pulling up this URL here--

3415
02:49:47,810 --> 02:49:50,960
so this link here-- special
method names and today's slides,

3416
02:49:50,960 --> 02:49:54,430
you'll see a long list of all of
the operators that you can overload.

3417
02:49:54,430 --> 02:49:57,790
You can do less than, equals
than, plus equals, minus equals.

3418
02:49:57,790 --> 02:50:00,490
Pretty much any symbol you've
seen me type on the screen

3419
02:50:00,490 --> 02:50:04,380
can be overloaded in
the context of classes.

3420
02:50:04,380 --> 02:50:06,757
So even though, today,
we focused entirely

3421
02:50:06,757 --> 02:50:09,840
on object-oriented programming, this
is a technique that we've been using,

3422
02:50:09,840 --> 02:50:13,020
really, since the first week of
the class because those ints,

3423
02:50:13,020 --> 02:50:16,480
those strs, those floats, those
lists, those dictionaries,

3424
02:50:16,480 --> 02:50:20,280
and so much more were already underneath
the hood this whole time-- classes

3425
02:50:20,280 --> 02:50:21,333
and objects thereof.

3426
02:50:21,333 --> 02:50:23,250
But you now, as a
programmer, have the ability

3427
02:50:23,250 --> 02:50:26,790
to create your own classes with your
own instance or class variables,

3428
02:50:26,790 --> 02:50:30,090
with your own instance or class
methods, with your own properties,

3429
02:50:30,090 --> 02:50:33,180
and even with your own custom
behavior for operators.

3430
02:50:33,180 --> 02:50:35,820
So ultimately, you can
absolutely continue

3431
02:50:35,820 --> 02:50:40,500
using those simple tuples or lists or
those dictionaries or other structures

3432
02:50:40,500 --> 02:50:41,010
as well.

3433
02:50:41,010 --> 02:50:44,610
But object-oriented programming, and
with it, classes and now these objects

3434
02:50:44,610 --> 02:50:46,410
is just another tool in your toolkit.

3435
02:50:46,410 --> 02:50:49,260
And daresay, as your code
gets more sophisticated

3436
02:50:49,260 --> 02:50:51,240
and your problems get
bigger, you'll find

3437
02:50:51,240 --> 02:50:54,900
that being able to model these real
world or even fantasy world entities

3438
02:50:54,900 --> 02:50:57,660
with classes and related
data and functionality

3439
02:50:57,660 --> 02:51:01,800
will ultimately just allow you to define
code that's not just correct but ever

3440
02:51:01,800 --> 02:51:04,060
well-designed as well.

3441
02:51:04,060 --> 02:51:06,770
This was CS50.

3442
02:51:06,770 --> 02:51:12,230